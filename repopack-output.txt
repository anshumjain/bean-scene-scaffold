This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-10-08T01:53:45.324Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
components.json
eslint.config.js
FEEDBACK_SETUP.md
index.html
MIGRATION_GUIDE.md
package.json
postcss.config.js
public/placeholder.svg
public/robots.txt
README.md
scripts/addReviews.js
scripts/apply-migrations.bat
scripts/apply-migrations.sh
scripts/enrichCafes.ts
scripts/expandCafes.js
scripts/migrations/20250127000000_add_cafe_photos_table.down.sql
scripts/migrations/20250127000000_add_cafe_photos_table.up.sql
scripts/nodeSupabaseClient.ts
scripts/README.md
scripts/refreshAmenities.js
scripts/seedCafes.backup.ts
scripts/seedCafes.ts
scripts/seedPosts.ts
scripts/seedReviewsAmenities.ts
src/api/place/details.ts
src/api/place/photo.ts
src/App.css
src/App.tsx
src/components/Cafe/CafeHeader.tsx
src/components/Cafe/CafePhotoUpload.tsx
src/components/Cafe/CafeReviews.tsx
src/components/Cafe/ParkingInfo.tsx
src/components/Cafe/WeatherWidget.tsx
src/components/Feed/FeedItemCard.tsx
src/components/Feed/PostCard.tsx
src/components/Filters/ExploreFilters.tsx
src/components/Filters/RadiusFilter.tsx
src/components/Layout/AppLayout.tsx
src/components/Layout/BottomNav.tsx
src/components/Layout/GlobalWeatherBar.tsx
src/components/Onboarding.tsx
src/components/ui/accordion.tsx
src/components/ui/alert-dialog.tsx
src/components/ui/alert.tsx
src/components/ui/aspect-ratio.tsx
src/components/ui/avatar.tsx
src/components/ui/badge.tsx
src/components/ui/breadcrumb.tsx
src/components/ui/button.tsx
src/components/ui/calendar.tsx
src/components/ui/card.tsx
src/components/ui/carousel.tsx
src/components/ui/chart.tsx
src/components/ui/checkbox.tsx
src/components/ui/collapsible.tsx
src/components/ui/command.tsx
src/components/ui/context-menu.tsx
src/components/ui/dialog.tsx
src/components/ui/drawer.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/form.tsx
src/components/ui/hover-card.tsx
src/components/ui/input-otp.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/menubar.tsx
src/components/ui/navigation-menu.tsx
src/components/ui/pagination.tsx
src/components/ui/popover.tsx
src/components/ui/progress.tsx
src/components/ui/radio-group.tsx
src/components/ui/resizable.tsx
src/components/ui/scroll-area.tsx
src/components/ui/select.tsx
src/components/ui/separator.tsx
src/components/ui/sheet.tsx
src/components/ui/sidebar.tsx
src/components/ui/skeleton.tsx
src/components/ui/slider.tsx
src/components/ui/sonner.tsx
src/components/ui/switch.tsx
src/components/ui/table.tsx
src/components/ui/tabs.tsx
src/components/ui/textarea.tsx
src/components/ui/toast.tsx
src/components/ui/toaster.tsx
src/components/ui/toggle-group.tsx
src/components/ui/toggle.tsx
src/components/ui/tooltip.tsx
src/components/ui/use-toast.ts
src/components/UsernameSelection.tsx
src/data/schema.md
src/hooks/use-google-analytics.ts
src/hooks/use-mobile.tsx
src/hooks/use-toast.ts
src/index.css
src/integrations/supabase/client.ts
src/integrations/supabase/types.ts
src/lib/utils.ts
src/main.tsx
src/pages/admin/Dashboard.tsx
src/pages/admin/Login.tsx
src/pages/CafeDetail.tsx
src/pages/CheckIn.tsx
src/pages/CreatePost.tsx
src/pages/DataValidation.tsx
src/pages/Feed.tsx
src/pages/Feedback.tsx
src/pages/Home.tsx
src/pages/ImageUpload.tsx
src/pages/Moments.tsx
src/pages/NotFound.tsx
src/pages/Profile.tsx
src/pages/RecentlyViewed.tsx
src/pages/Search.tsx
src/pages/Share.tsx
src/pages/TestMigration.tsx
src/services/activityService.ts
src/services/adminFeedbackService.ts
src/services/analyticsService.ts
src/services/API_INTEGRATION_GUIDE.md
src/services/cafeService.ts
src/services/cloudinaryService.ts
src/services/favoritesService.ts
src/services/feedbackService.ts
src/services/feedService.ts
src/services/googleAnalyticsService.ts
src/services/googlePlacesService.ts
src/services/imageOptimizationService.ts
src/services/monitoringService.ts
src/services/parkingService.ts
src/services/postService.ts
src/services/recentlyViewedService.ts
src/services/reviewService.ts
src/services/scheduledService.ts
src/services/types.ts
src/services/userService.ts
src/services/utils.ts
src/services/validationService.ts
src/services/weatherService.ts
src/styles/coffee-theme.css
src/utils/distanceUtils.ts
src/utils/emojiPlaceholders.ts
src/vite-env.d.ts
supabase/config.toml
supabase/functions/add-reviews/index.ts
supabase/functions/enrich-cafes/index.ts
supabase/functions/refresh-amenities/index.ts
supabase/migrations/20250106_create_feedback_table.sql
supabase/migrations/20250916232849_e59e0193-bf5e-4e98-b8fb-3d8957a31bcb.sql
supabase/migrations/20250930034553_b8e4c817-9eab-43b4-829a-3dfe638d8ce4.sql
supabase/migrations/20250930034745_5fca4937-3697-4265-aa27-41cc99bdbcf1.sql
supabase/migrations/20251006_add_favorites_and_user_activities.sql
supabase/migrations/20251006_add_username_device_to_posts.sql
supabase/migrations/20251006_add_username_to_users.sql
supabase/migrations/20251006_complete_feature_implementation.sql
supabase/migrations/20251006_fix_favorites_rls.sql
tailwind.config.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vercel.json
vite.config.ts

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

================
File: eslint.config.js
================
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";

export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": ["warn", { allowConstantExport: true }],
      "@typescript-eslint/no-unused-vars": "off",
    },
  },
);

================
File: FEEDBACK_SETUP.md
================
# Feedback System Setup Guide

## üéØ **Admin Feedback Management - Implementation Complete!**

The feedback management system has been successfully implemented in your admin dashboard. Here's what you need to do to activate it:

## üìã **Step 1: Run the Database Migration**

The feedback table needs to be created in your Supabase database. Run this migration:

```bash
# Option 1: Using npm script (if Supabase CLI is installed)
npm run migrate

# Option 2: Manual SQL execution
# Copy and paste the contents of supabase/migrations/20250106_create_feedback_table.sql
# into your Supabase SQL Editor and run it
```

## üöÄ **Step 2: Access the Admin Dashboard**

1. Navigate to `/admin/login` in your app
2. Login with your admin credentials
3. You'll now see a new **"User Feedback"** section in the dashboard

## üìä **What You'll See in the Admin Dashboard**

### **Feedback Statistics**
- **Total Feedback**: Count of all submitted feedback
- **Follow-up Requests**: Users who want to be contacted
- **This Week**: Recent feedback submissions
- **Bug Reports**: Critical issues that need attention

### **Feedback Type Breakdown**
- **Bug Reports** (Red) - Critical issues
- **Feature Requests** (Blue) - Enhancement suggestions  
- **General Feedback** (Green) - General comments
- **Support** (Purple) - Help requests

### **Feedback List**
- **Filter by Type**: Dropdown to filter by feedback category
- **Refresh Button**: Manual refresh of feedback data
- **Individual Feedback Cards** showing:
  - Feedback type badge
  - Subject and details
  - Submission date
  - User information (if available)
  - Follow-up email (if requested)
  - Unique feedback ID

## üîß **Features Available**

### **For Admins:**
- ‚úÖ View all feedback submissions
- ‚úÖ Filter by feedback type
- ‚úÖ See follow-up contact information
- ‚úÖ Track feedback statistics
- ‚úÖ Identify urgent bug reports
- ‚úÖ Monitor user engagement

### **For Users:**
- ‚úÖ Submit feedback via `/feedback` page
- ‚úÖ Choose feedback type (bug, feature, general, support)
- ‚úÖ Optionally provide email for follow-up
- ‚úÖ Anonymous feedback support

## üìß **How to Respond to Users**

### **For Follow-up Requests:**
1. Look for feedback with the "Follow-up" badge
2. Note the contact email address
3. Respond directly to the user's email

### **For Bug Reports:**
1. Filter by "Bug Reports" type
2. Review the issue details
3. Prioritize based on severity
4. Follow up with users if they provided contact info

### **For Feature Requests:**
1. Filter by "Feature Requests" type
2. Review suggestions
3. Consider implementation feasibility
4. Add to product roadmap if valuable

## üóÑÔ∏è **Database Structure**

The feedback is stored in the `feedback` table with these fields:
- `id` - Unique identifier
- `feedback_type` - bug, feature, general, support
- `subject` - Brief description
- `details` - Full feedback text
- `allow_followup` - Boolean for follow-up requests
- `contact_email` - User's email (if follow-up requested)
- `user_id` - Associated user (if logged in)
- `device_id` - Anonymous user identifier
- `created_at` - Submission timestamp
- `updated_at` - Last modification timestamp

## üéâ **You're All Set!**

Once you run the migration, your admin dashboard will have full feedback management capabilities. Users can submit feedback through the app, and you can view and manage all submissions through the admin interface.

## üîç **Quick Access Methods**

1. **Admin Dashboard**: `/admin/login` ‚Üí User Feedback section
2. **Direct SQL**: Supabase SQL Editor ‚Üí `SELECT * FROM feedback ORDER BY created_at DESC;`
3. **Supabase Dashboard**: Table Editor ‚Üí `feedback` table

The system is now ready to collect and manage user feedback effectively! üöÄ

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bean Scene - Houston Cafe Discovery & Social Check-ins</title>
    <meta name="description" content="Discover Houston's best coffee spots and share your cafe experiences with Bean Scene. Check in, share photos, and connect with fellow coffee enthusiasts." />
    <meta name="author" content="Bean Scene" />
    <meta name="keywords" content="houston coffee, cafe discovery, coffee check-in, social coffee, houston cafes, coffee community" />

    <meta property="og:title" content="Bean Scene - Houston Cafe Discovery" />
    <meta property="og:description" content="Discover Houston's best coffee spots and share your cafe experiences with Bean Scene." />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RFNKYG6WL5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RFNKYG6WL5');
    </script>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: MIGRATION_GUIDE.md
================
# BeanScene Database Migration Guide

This guide explains how to apply the complete database migration for all BeanScene features.

## üö® Important: Before You Start

**The migration includes ALL features from the implementation plan:**
- User identity & authentication (username, device ID)
- Favorites system
- User activity tracking
- Admin analytics functions
- Enhanced cafe data (amenities, parking)

## üìã Prerequisites

1. **Supabase CLI**: Install if not already installed
   ```bash
   npm install -g supabase
   ```

2. **Environment Setup**: Ensure your `.env` file contains:
   ```
   VITE_SUPABASE_URL=your_supabase_url
   VITE_SUPABASE_ANON_KEY=your_supabase_anon_key
   ```

3. **Backup**: Consider backing up your database before applying migrations

## üöÄ Quick Migration (Recommended)

### Option 1: Using npm script (Cross-platform)
```bash
npm run migrate
```

### Option 2: Using platform-specific scripts

**Windows:**
```bash
scripts\apply-migrations.bat
```

**Linux/Mac:**
```bash
chmod +x scripts/apply-migrations.sh
./scripts/apply-migrations.sh
```

### Option 3: Manual steps
```bash
# 1. Apply migrations
supabase db push

# 2. Regenerate TypeScript types
supabase gen types typescript --local > src/integrations/supabase/types.ts
```

## üìä What the Migration Does

### Database Schema Changes
1. **Users Table**:
   - Adds `username` column (unique)
   - Updates RLS policies for public username access

2. **Posts Table**:
   - Adds `username` column (for display)
   - Adds `device_id` column (for anonymous posts)
   - Makes `user_id` nullable (for anonymous posts)

3. **New Tables**:
   - `favorites` - User cafe favorites with device ID support
   - `user_activities` - Activity log for all user actions

4. **Cafes Table**:
   - Adds `amenities` JSONB column
   - Adds `parking_info` TEXT column

### Database Functions
- `get_user_by_username()` - Public profile lookup
- `get_user_activity_feed()` - Activity feed
- `get_user_favorites()` - User favorites
- `is_cafe_favorited()` - Favorite status check
- `get_daily_active_users()` - Analytics
- `get_monthly_active_users()` - Analytics
- `get_engagement_metrics()` - Analytics

### Security & Performance
- Row Level Security (RLS) policies
- Proper indexes for performance
- Function permissions
- Anonymous user support

## ‚úÖ Verification Steps

After migration, verify these work:

1. **Username Selection**:
   - Go to Profile page
   - Should prompt for username if not set

2. **Favorites**:
   - Visit any cafe detail page
   - Heart icon should toggle favorites

3. **Activity Tracking**:
   - Create a post or favorite a cafe
   - Check Profile page activity feed

4. **Admin Dashboard**:
   - Visit `/admin/dashboard`
   - Should show analytics with real data

5. **Public Profiles**:
   - Visit `/user/[username]`
   - Should show user profile

## üêõ Troubleshooting

### Common Issues

1. **Migration Fails**:
   ```bash
   # Check Supabase status
   supabase status
   
   # Reset local database if needed
   supabase db reset
   ```

2. **TypeScript Errors**:
   ```bash
   # Regenerate types manually
   supabase gen types typescript --local > src/integrations/supabase/types.ts
   
   # Restart TypeScript server in your IDE
   ```

3. **RLS Policy Errors**:
   - Check if you're authenticated
   - Verify RLS policies in Supabase dashboard

4. **Function Permission Errors**:
   - Ensure functions are created with proper permissions
   - Check Supabase logs for detailed errors

### Rollback (If Needed)

If you need to rollback:
```bash
# Reset to previous migration
supabase db reset

# Or manually drop new tables (NOT RECOMMENDED)
# Only do this if you understand the consequences
```

## üìà Post-Migration Steps

1. **Install Dependencies**:
   ```bash
   npm install
   ```

2. **Seed Sample Data** (Optional):
   ```bash
   npm run seed:reviews
   npm run seed:posts
   ```

3. **Test Features**:
   - Create a test user account
   - Test username selection
   - Test favorites functionality
   - Test activity tracking
   - Check admin dashboard

4. **Deploy**:
   - Push to your repository
   - Deploy to production
   - Run migration on production database

## üîç Migration File Details

The main migration file is:
- `supabase/migrations/20251006_complete_feature_implementation.sql`

This single file contains all the changes needed for the complete feature implementation.

## üìû Support

If you encounter issues:
1. Check the Supabase logs: `supabase logs`
2. Verify your environment variables
3. Ensure Supabase CLI is up to date
4. Check the migration file for syntax errors

## üéâ Success!

Once migration is complete, you'll have:
- ‚úÖ Complete user identity system
- ‚úÖ Favorites functionality
- ‚úÖ Activity tracking
- ‚úÖ Admin analytics dashboard
- ‚úÖ Public user profiles
- ‚úÖ Enhanced cafe data
- ‚úÖ Proper TypeScript types
- ‚úÖ Security policies
- ‚úÖ Performance optimizations

Your BeanScene app is now ready for production! üöÄ

================
File: package.json
================
{
  "name": "vite_react_shadcn_ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint .",
    "preview": "vite preview",
    "migrate": "supabase db push && supabase gen types typescript --local > src/integrations/supabase/types.ts",
    "seed:reviews": "tsx scripts/seedReviewsAmenities.ts",
    "seed:posts": "tsx scripts/seedPosts.ts"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@radix-ui/react-accordion": "^1.2.11",
    "@radix-ui/react-alert-dialog": "^1.1.14",
    "@radix-ui/react-aspect-ratio": "^1.1.7",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.2",
    "@radix-ui/react-collapsible": "^1.1.11",
    "@radix-ui/react-context-menu": "^2.2.15",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-hover-card": "^1.1.14",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-menubar": "^1.1.15",
    "@radix-ui/react-navigation-menu": "^1.2.13",
    "@radix-ui/react-popover": "^1.1.14",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.3.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slider": "^1.3.5",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-toast": "^1.2.14",
    "@radix-ui/react-toggle": "^1.1.9",
    "@radix-ui/react-toggle-group": "^1.1.10",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@supabase/supabase-js": "^2.57.4",
    "@tanstack/react-query": "^5.83.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "date-fns": "^3.6.0",
    "dotenv": "^17.2.2",
    "@faker-js/faker": "^9.4.0",
    "embla-carousel-react": "^8.6.0",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.462.0",
    "next-themes": "^0.3.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.61.1",
    "react-resizable-panels": "^2.1.9",
    "react-router-dom": "^6.30.1",
    "recharts": "^2.15.4",
    "sonner": "^1.7.4",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.9",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@eslint/js": "^9.32.0",
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^22.16.5",
    "@types/react": "^18.3.23",
    "@types/react-dom": "^18.3.7",
    "@vitejs/plugin-react-swc": "^3.11.0",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.32.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^15.15.0",
    "lovable-tagger": "^1.1.9",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.20.6",
    "typescript": "^5.8.3",
    "typescript-eslint": "^8.38.0",
    "vite": "^5.4.19"
  }
}

================
File: postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

================
File: public/placeholder.svg
================
<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="1200" fill="none"><rect width="1200" height="1200" fill="#EAEAEA" rx="3"/><g opacity=".5"><g opacity=".5"><path fill="#FAFAFA" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/></g><path stroke="url(#a)" stroke-width="2.418" d="M0-1.209h553.581" transform="scale(1 -1) rotate(45 1163.11 91.165)"/><path stroke="url(#b)" stroke-width="2.418" d="M404.846 598.671h391.726"/><path stroke="url(#c)" stroke-width="2.418" d="M599.5 795.742V404.017"/><path stroke="url(#d)" stroke-width="2.418" d="m795.717 796.597-391.441-391.44"/><path fill="#fff" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/><g clip-path="url(#e)"><path fill="#666" fill-rule="evenodd" d="M616.426 586.58h-31.434v16.176l3.553-3.554.531-.531h9.068l.074-.074 8.463-8.463h2.565l7.18 7.181V586.58Zm-15.715 14.654 3.698 3.699 1.283 1.282-2.565 2.565-1.282-1.283-5.2-5.199h-6.066l-5.514 5.514-.073.073v2.876a2.418 2.418 0 0 0 2.418 2.418h26.598a2.418 2.418 0 0 0 2.418-2.418v-8.317l-8.463-8.463-7.181 7.181-.071.072Zm-19.347 5.442v4.085a6.045 6.045 0 0 0 6.046 6.045h26.598a6.044 6.044 0 0 0 6.045-6.045v-7.108l1.356-1.355-1.282-1.283-.074-.073v-17.989h-38.689v23.43l-.146.146.146.147Z" clip-rule="evenodd"/></g><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/></g><defs><linearGradient id="a" x1="554.061" x2="-.48" y1=".083" y2=".087" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="b" x1="796.912" x2="404.507" y1="599.963" y2="599.965" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="c" x1="600.792" x2="600.794" y1="403.677" y2="796.082" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="d" x1="404.85" x2="796.972" y1="403.903" y2="796.02" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><clipPath id="e"><path fill="#fff" d="M581.364 580.535h38.689v38.689h-38.689z"/></clipPath></defs></svg>

================
File: public/robots.txt
================
User-agent: Googlebot
Allow: /

User-agent: Bingbot
Allow: /

User-agent: Twitterbot
Allow: /

User-agent: facebookexternalhit
Allow: /

User-agent: *
Allow: /

================
File: README.md
================
# BeanScene ‚òï

**Discover caf√©s, vibes, and connections in Houston**

BeanScene is a Houston coffee discovery app that helps you find the perfect caf√© for your mood, whether you're looking for a quiet study spot, a vibrant social hub, or a cozy date location.

## ‚ú® Features

### üè† **Core Features**
- **Caf√© Discovery**: Find cafes near you with detailed information, photos, and reviews
- **Check-ins**: Share your caf√© experiences with photos, ratings, and tags
- **Favorites**: Save your favorite spots for easy access
- **Feed**: Discover what's happening at cafes around Houston
- **Profile**: Track your caf√© journey and connect with other coffee lovers

### üéØ **Smart Features**
- **Location-based Search**: Find cafes within walking distance
- **Mood-based Filtering**: Filter by atmosphere (quiet, social, study-friendly, etc.)
- **Real-time Reviews**: See what others are saying about each caf√©
- **Photo Sharing**: Upload and share your caf√© photos
- **Anonymous Mode**: Use the app without creating an account

### üé® **Design**
- **Coffee-themed UI**: Beautiful brown and cream color palette
- **Mobile-first**: Optimized for mobile devices
- **Smooth Animations**: Delightful micro-interactions throughout
- **Accessibility**: Built with accessibility in mind

## üöÄ Getting Started

### Prerequisites
- Node.js 18+ and npm
- Supabase account (for database)
- Google Places API key (for caf√© data)
- Cloudinary account (for image storage)

### Installation

1. **Clone the repository**
   ```bash
   git clone <your-repo-url>
   cd bean-scene-scaffold
   ```

2. **Install dependencies**
   ```bash
   npm install
   ```

3. **Set up environment variables**
   Create a `.env.local` file in the root directory:
   ```bash
   # Supabase
   VITE_SUPABASE_URL=your_supabase_url
   VITE_SUPABASE_ANON_KEY=your_supabase_anon_key
   
   # Google Places API (server-side only)
   GOOGLE_PLACES_API_KEY=your_google_places_api_key
   
   # Cloudinary
   VITE_CLOUDINARY_CLOUD_NAME=your_cloudinary_cloud_name
   VITE_CLOUDINARY_API_KEY=your_cloudinary_api_key
   ```

4. **Set up the database**
   ```bash
   # Install Supabase CLI
   npm install -g supabase
   
   # Apply migrations
   npm run migrate
   ```

5. **Start the development server**
   ```bash
   npm run dev
   ```

6. **Open your browser**
   Navigate to `http://localhost:8080`

## üèóÔ∏è Tech Stack

### **Frontend**
- **React 18** with TypeScript
- **Vite** for fast development and building
- **Tailwind CSS** for styling
- **shadcn/ui** for UI components
- **React Router** for navigation
- **React Query** for data fetching

### **Backend**
- **Supabase** for database and authentication
- **PostgreSQL** with Row Level Security (RLS)
- **Supabase Edge Functions** for serverless functions

### **Services**
- **Google Places API** for caf√© data
- **Cloudinary** for image storage and optimization
- **Geolocation API** for location-based features

## üìÅ Project Structure

```
src/
‚îú‚îÄ‚îÄ components/          # Reusable UI components
‚îÇ   ‚îú‚îÄ‚îÄ Cafe/           # Caf√©-specific components
‚îÇ   ‚îú‚îÄ‚îÄ Feed/           # Feed and post components
‚îÇ   ‚îú‚îÄ‚îÄ Layout/         # Layout components
‚îÇ   ‚îî‚îÄ‚îÄ ui/             # shadcn/ui components
‚îú‚îÄ‚îÄ pages/              # Page components
‚îú‚îÄ‚îÄ services/           # API and business logic
‚îú‚îÄ‚îÄ hooks/              # Custom React hooks
‚îú‚îÄ‚îÄ utils/              # Utility functions
‚îú‚îÄ‚îÄ styles/             # Global styles and themes
‚îî‚îÄ‚îÄ integrations/       # Third-party integrations
```

## üóÑÔ∏è Database Schema

### **Core Tables**
- `cafes` - Caf√© information and details
- `posts` - User check-ins and reviews
- `users` - User profiles and preferences
- `favorites` - User's favorite cafes
- `feedback` - User feedback and support requests

### **Features**
- Row Level Security (RLS) for data protection
- Support for both authenticated and anonymous users
- Comprehensive indexing for performance
- Automatic timestamp tracking

## üöÄ Deployment

### **Vercel (Recommended)**
1. Connect your GitHub repository to Vercel
2. Set environment variables in Vercel dashboard
3. Deploy automatically on push to main branch

### **Other Platforms**
The app can be deployed to any platform that supports:
- Node.js 18+
- Static file serving
- Environment variables

## ü§ù Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## üìù Development Scripts

```bash
# Development
npm run dev          # Start development server
npm run build        # Build for production
npm run preview      # Preview production build

# Database
npm run migrate      # Apply Supabase migrations
npm run seed:reviews # Seed review data
npm run seed:posts   # Seed post data

# Code Quality
npm run lint         # Run ESLint
```

## üêõ Troubleshooting

### **Common Issues**

1. **Database connection errors**
   - Verify Supabase URL and keys are correct
   - Check if migrations have been applied

2. **Google Places API errors**
   - Ensure API key is valid and has Places API enabled
   - Check API quotas and billing

3. **Image upload issues**
   - Verify Cloudinary credentials
   - Check file size limits

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- **Houston Coffee Community** for inspiration and feedback
- **shadcn/ui** for beautiful UI components
- **Supabase** for the amazing backend platform
- **Vercel** for seamless deployment

---

**Made with ‚òï in Houston, TX**

================
File: scripts/addReviews.js
================
// scripts/addReviews.js
// Fetch top 3 Google reviews per cafe using Google Places Details API

const fs = require('fs');
const fetch = require('node-fetch');

const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;
if (!GOOGLE_API_KEY) throw new Error('GOOGLE_API_KEY env var required');

const cafes = JSON.parse(fs.readFileSync('cafes_amenities.json', 'utf-8'));
const reviews = [];
let apiCalls = 0;
const MAX_API_CALLS = 2000;
const reviewSet = new Set();

async function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function fetchDetails(placeId) {
  if (apiCalls >= MAX_API_CALLS) return null;
  const url = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${placeId}&fields=reviews&key=${GOOGLE_API_KEY}`;
  apiCalls++;
  const resp = await fetch(url);
  if (!resp.ok) return null;
  const json = await resp.json();
  return json.result?.reviews || [];
}

(async () => {
  for (const cafe of cafes) {
    if (apiCalls >= MAX_API_CALLS) break;
    const googleReviews = await fetchDetails(cafe.place_id);
    for (const review of (googleReviews || []).slice(0, 3)) {
      const key = `${cafe.place_id}|${review.author_name}|${review.text}`;
      if (!reviewSet.has(key)) {
        reviewSet.add(key);
        reviews.push({
          cafe_id: cafe.place_id,
          author_name: review.author_name,
          review_text: review.text,
          rating: review.rating,
          time: review.time,
          profile_photo_url: review.profile_photo_url,
        });
      }
    }
    await sleep(100);
  }
  fs.writeFileSync('cafe_reviews.json', JSON.stringify(reviews, null, 2));
  console.log(`Done. Reviews: ${reviews.length}, API calls: ${apiCalls}`);
})();

================
File: scripts/apply-migrations.bat
================
@echo off
REM BeanScene Database Migration Script for Windows
REM This script applies all migrations and regenerates TypeScript types

echo üöÄ Starting BeanScene database migration...

REM Check if supabase CLI is installed
where supabase >nul 2>nul
if %ERRORLEVEL% NEQ 0 (
    echo ‚ùå Supabase CLI not found. Please install it first:
    echo    npm install -g supabase
    exit /b 1
)

REM Check if we're in a Supabase project
if not exist "supabase\config.toml" (
    echo ‚ùå Not in a Supabase project directory. Please run this from the project root.
    exit /b 1
)

echo üìã Applying database migrations...

REM Apply migrations
supabase db push

if %ERRORLEVEL% EQU 0 (
    echo ‚úÖ Database migrations applied successfully!
) else (
    echo ‚ùå Failed to apply migrations. Please check the errors above.
    exit /b 1
)

echo üîÑ Regenerating TypeScript types...

REM Generate types
supabase gen types typescript --local > src\integrations\supabase\types.ts

if %ERRORLEVEL% EQU 0 (
    echo ‚úÖ TypeScript types regenerated successfully!
) else (
    echo ‚ùå Failed to regenerate types. Please check the errors above.
    exit /b 1
)

echo üßπ Cleaning up old migration files...

REM Remove the individual migration files since we have the complete one
if exist "supabase\migrations\20251006_add_username_to_users.sql" del "supabase\migrations\20251006_add_username_to_users.sql"
if exist "supabase\migrations\20251006_add_username_device_to_posts.sql" del "supabase\migrations\20251006_add_username_device_to_posts.sql"
if exist "supabase\migrations\20251006_add_favorites_and_user_activities.sql" del "supabase\migrations\20251006_add_favorites_and_user_activities.sql"

echo ‚úÖ Cleanup completed!

echo.
echo üéâ Migration completed successfully!
echo.
echo Next steps:
echo 1. Run 'npm install' to install dependencies
echo 2. Run 'npm run dev' to start the development server
echo 3. Test the new features:
echo    - Username selection in profile
echo    - Favorites functionality
echo    - Activity tracking
echo    - Admin analytics dashboard
echo.
echo To seed sample data:
echo   npm run seed:reviews
echo   npm run seed:posts

================
File: scripts/apply-migrations.sh
================
#!/bin/bash

# BeanScene Database Migration Script
# This script applies all migrations and regenerates TypeScript types

echo "üöÄ Starting BeanScene database migration..."

# Check if supabase CLI is installed
if ! command -v supabase &> /dev/null; then
    echo "‚ùå Supabase CLI not found. Please install it first:"
    echo "   npm install -g supabase"
    exit 1
fi

# Check if we're in a Supabase project
if [ ! -f "supabase/config.toml" ]; then
    echo "‚ùå Not in a Supabase project directory. Please run this from the project root."
    exit 1
fi

echo "üìã Applying database migrations..."

# Apply migrations
supabase db push

if [ $? -eq 0 ]; then
    echo "‚úÖ Database migrations applied successfully!"
else
    echo "‚ùå Failed to apply migrations. Please check the errors above."
    exit 1
fi

echo "üîÑ Regenerating TypeScript types..."

# Generate types
supabase gen types typescript --local > src/integrations/supabase/types.ts

if [ $? -eq 0 ]; then
    echo "‚úÖ TypeScript types regenerated successfully!"
else
    echo "‚ùå Failed to regenerate types. Please check the errors above."
    exit 1
fi

echo "üßπ Cleaning up old migration files..."

# Remove the individual migration files since we have the complete one
rm -f supabase/migrations/20251006_add_username_to_users.sql
rm -f supabase/migrations/20251006_add_username_device_to_posts.sql
rm -f supabase/migrations/20251006_add_favorites_and_user_activities.sql

echo "‚úÖ Cleanup completed!"

echo ""
echo "üéâ Migration completed successfully!"
echo ""
echo "Next steps:"
echo "1. Run 'npm install' to install dependencies"
echo "2. Run 'npm run dev' to start the development server"
echo "3. Test the new features:"
echo "   - Username selection in profile"
echo "   - Favorites functionality"
echo "   - Activity tracking"
echo "   - Admin analytics dashboard"
echo ""
echo "To seed sample data:"
echo "  npm run seed:reviews"
echo "  npm run seed:posts"

================
File: scripts/enrichCafes.ts
================
/**
 * Enrich Cafes Script
 * 
 * This script fetches missing data from Google Places Details API and updates Supabase.
 * It will:
 * 1. Fetch cafes needing enrichment (missing opening_hours or other data)
 * 2. Call Google Places Details API for each cafe
 * 3. Update cafes table with opening_hours, phone_number, website, and parking_info
 * 4. Insert Google Reviews into cafe_reviews table (top 5 per cafe)
 * 
 * Usage: bun scripts/enrichCafes.ts
 * 
 * Note: Requires GOOGLE_PLACES_API_KEY environment variable
 * Cost: ~$0.017 per cafe (Details API)
 * For 1200 cafes: ~$20.40 (well within $200 monthly free credit)
 */

import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

const SUPABASE_URL = process.env.VITE_SUPABASE_URL || process.env.VITE_API_BASE_URL;
const SUPABASE_ANON_KEY = process.env.VITE_SUPABASE_PUBLISHABLE_KEY;
const GOOGLE_PLACES_API_KEY = process.env.GOOGLE_PLACES_API_KEY;

if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
  console.error('‚ùå Missing Supabase credentials');
  process.exit(1);
}

if (!GOOGLE_PLACES_API_KEY) {
  console.error('‚ùå Missing GOOGLE_PLACES_API_KEY environment variable');
  process.exit(1);
}

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Sleep utility for rate limiting
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

interface PlaceDetails {
  opening_hours?: {
    weekday_text: string[];
  };
  formatted_phone_number?: string;
  website?: string;
  reviews?: Array<{
    author_name: string;
    rating: number;
    text: string;
    profile_photo_url?: string;
    time: number;
  }>;
  editorial_summary?: {
    overview?: string;
  };
}

/**
 * Fetch Place Details from Google Places API
 */
async function fetchPlaceDetails(placeId: string): Promise<PlaceDetails | null> {
  try {
    const fields = 'opening_hours,formatted_phone_number,website,reviews,editorial_summary';
    const url = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${placeId}&fields=${fields}&key=${GOOGLE_PLACES_API_KEY}`;
    
    const response = await fetch(url);
    const data = await response.json();
    
    if (data.status !== 'OK') {
      console.error(`  ‚ö†Ô∏è  Places API error for ${placeId}:`, data.status, data.error_message || '');
      return null;
    }
    
    return data.result;
  } catch (error) {
    console.error(`  ‚ùå Error fetching place details for ${placeId}:`, error);
    return null;
  }
}

/**
 * Infer parking info from editorial summary and reviews using heuristic patterns
 * Option 2: Text-based heuristics
 */
function inferParkingInfo(editorial?: string, reviews?: PlaceDetails['reviews']): string {
  // Combine all text sources
  const text = [
    editorial || '',
    ...(reviews || []).map(r => r.text)
  ].join(' ').toLowerCase();
  
  // Heuristic pattern matching
  if (text.includes('parking lot') || text.includes('free parking') || text.includes('ample parking')) {
    return 'Free parking lot available';
  }
  if (text.includes('street parking')) {
    return 'Street parking available';
  }
  if (text.includes('parking garage') || text.includes('garage parking')) {
    return 'Parking garage nearby';
  }
  if (text.includes('valet')) {
    return 'Valet parking available';
  }
  if (text.includes('no parking') || text.includes('limited parking') || text.includes('difficult to park')) {
    return 'Limited parking - street only';
  }
  if (text.includes('validated parking')) {
    return 'Validated parking available';
  }
  
  // Default for Houston cafes (most have street parking)
  return 'Street parking available';
}

/**
 * Main enrichment function
 */
async function enrichCafes() {
  console.log('üöÄ Starting cafe enrichment...\n');
  
  // Fetch cafes needing enrichment (those without opening_hours)
  const { data: cafes, error } = await supabase
    .from('cafes')
    .select('id, place_id, name, neighborhood')
    .is('opening_hours', null)
    .order('created_at', { ascending: true });
  
  if (error) {
    console.error('‚ùå Error fetching cafes:', error);
    return;
  }
  
  if (!cafes || cafes.length === 0) {
    console.log('‚úÖ All cafes are already enriched!');
    return;
  }
  
  console.log(`üìä Found ${cafes.length} cafes to enrich\n`);
  
  let successCount = 0;
  let failCount = 0;
  let reviewsInserted = 0;
  
  // Process cafes with rate limiting (10 requests/second = 100ms between requests)
  for (let i = 0; i < cafes.length; i++) {
    const cafe = cafes[i];
    const progress = ((i + 1) / cafes.length * 100).toFixed(1);
    
    console.log(`[${i + 1}/${cafes.length}] (${progress}%) Processing: ${cafe.name} (${cafe.neighborhood})`);
    
    // Fetch place details
    const details = await fetchPlaceDetails(cafe.place_id);
    
    if (!details) {
      console.log(`  ‚ö†Ô∏è  Skipped (API error)\n`);
      failCount++;
      await sleep(100); // Rate limiting
      continue;
    }
    
    // Prepare update data
    const updateData: any = {};
    
    if (details.opening_hours?.weekday_text) {
      updateData.opening_hours = details.opening_hours.weekday_text;
    }
    
    if (details.formatted_phone_number) {
      updateData.phone_number = details.formatted_phone_number;
    }
    
    if (details.website) {
      updateData.website = details.website;
    }
    
    // Infer parking info
    const parkingInfo = inferParkingInfo(
      details.editorial_summary?.overview,
      details.reviews
    );
    updateData.parking_info = parkingInfo;
    
    // Update cafe in database
    const { error: updateError } = await supabase
      .from('cafes')
      .update(updateData)
      .eq('id', cafe.id);
    
    if (updateError) {
      console.log(`  ‚ùå Failed to update cafe:`, updateError.message);
      failCount++;
    } else {
      console.log(`  ‚úÖ Updated cafe data`);
      successCount++;
    }
    
    // Insert reviews (top 5)
    if (details.reviews && details.reviews.length > 0) {
      const reviewsToInsert = details.reviews.slice(0, 5).map(review => ({
        cafe_id: cafe.id,
        reviewer_name: review.author_name,
        rating: review.rating,
        review_text: review.text,
        profile_photo_url: review.profile_photo_url || null,
        time: new Date(review.time * 1000).toISOString()
      }));
      
      const { error: reviewError } = await supabase
        .from('cafe_reviews')
        .upsert(reviewsToInsert, { 
          onConflict: 'cafe_id,reviewer_name,review_text',
          ignoreDuplicates: true 
        });
      
      if (reviewError) {
        console.log(`  ‚ö†Ô∏è  Failed to insert reviews:`, reviewError.message);
      } else {
        console.log(`  üìù Inserted ${reviewsToInsert.length} reviews`);
        reviewsInserted += reviewsToInsert.length;
      }
    }
    
    console.log(); // Empty line for readability
    
    // Rate limiting: 10 requests per second
    await sleep(100);
    
    // Progress update every 50 cafes
    if ((i + 1) % 50 === 0) {
      console.log(`\nüìà Progress Report:`);
      console.log(`   Processed: ${i + 1}/${cafes.length}`);
      console.log(`   Success: ${successCount}`);
      console.log(`   Failed: ${failCount}`);
      console.log(`   Reviews: ${reviewsInserted}\n`);
    }
  }
  
  // Final summary
  console.log('\n' + '='.repeat(50));
  console.log('üéâ ENRICHMENT COMPLETE!\n');
  console.log(`üìä Final Statistics:`);
  console.log(`   Total Processed: ${cafes.length}`);
  console.log(`   ‚úÖ Successfully Enriched: ${successCount}`);
  console.log(`   ‚ùå Failed: ${failCount}`);
  console.log(`   üìù Reviews Inserted: ${reviewsInserted}`);
  console.log(`   üí∞ Estimated Cost: $${(cafes.length * 0.017).toFixed(2)}`);
  console.log('='.repeat(50) + '\n');
}

// Run the script
enrichCafes()
  .then(() => {
    console.log('‚úÖ Script completed successfully');
    process.exit(0);
  })
  .catch((error) => {
    console.error('‚ùå Script failed:', error);
    process.exit(1);
  });

================
File: scripts/expandCafes.js
================
// scripts/expandCafes.js
// Crawl Houston and surrounding zones for cafes using Google Places API (grid-based)
// Zones: Houston, Katy, Sugar Land, Cypress, The Woodlands, Pearland
// Deduplicate by place_id or (name+address). Output up to 1200 unique cafes. ‚â§2000 API calls.

const fs = require('fs');
const fetch = require('node-fetch');
const { v4: uuidv4 } = require('uuid');

const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;
if (!GOOGLE_API_KEY) throw new Error('GOOGLE_API_KEY env var required');

const ZONES = [
  { name: 'Houston', lat: 29.7604, lng: -95.3698, radius: 18000 },
  { name: 'Katy', lat: 29.7858, lng: -95.8245, radius: 9000 },
  { name: 'Sugar Land', lat: 29.6197, lng: -95.6349, radius: 9000 },
  { name: 'Cypress', lat: 29.9691, lng: -95.6972, radius: 9000 },
  { name: 'The Woodlands', lat: 30.1658, lng: -95.4613, radius: 9000 },
  { name: 'Pearland', lat: 29.5636, lng: -95.2861, radius: 9000 },
];

const GRID_STEP = 0.045; // ~5km
const MAX_CAFES = 1200;
const MAX_API_CALLS = 2000;

const cafes = new Map();
let apiCalls = 0;

async function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function fetchPlaces(lat, lng, radius) {
  if (apiCalls >= MAX_API_CALLS) return [];
  const url = `https://maps.googleapis.com/maps/api/place/nearbysearch/json?location=${lat},${lng}&radius=${radius}&type=cafe&key=${GOOGLE_API_KEY}`;
  apiCalls++;
  const resp = await fetch(url);
  if (!resp.ok) return [];
  const json = await resp.json();
  return json.results || [];
}

function dedupeAndAdd(results) {
  for (const cafe of results) {
    const key = cafe.place_id || (cafe.name + '|' + cafe.vicinity);
    if (!cafes.has(key)) {
      cafes.set(key, {
        id: uuidv4(),
        place_id: cafe.place_id,
        name: cafe.name,
        address: cafe.vicinity,
        lat: cafe.geometry.location.lat,
        lng: cafe.geometry.location.lng,
        rating: cafe.rating,
        user_ratings_total: cafe.user_ratings_total,
        types: cafe.types,
        photos: cafe.photos,
        icon: cafe.icon,
        reference: cafe.reference,
        scope: cafe.scope,
      });
    }
  }
}

async function crawlZone(zone) {
  const { lat, lng, radius } = zone;
  // Grid: step north/south/east/west
  for (let dLat = -0.18; dLat <= 0.18; dLat += GRID_STEP) {
    for (let dLng = -0.18; dLng <= 0.18; dLng += GRID_STEP) {
      if (cafes.size >= MAX_CAFES || apiCalls >= MAX_API_CALLS) return;
      const clat = lat + dLat;
      const clng = lng + dLng;
      const results = await fetchPlaces(clat, clng, 1500);
      dedupeAndAdd(results);
      await sleep(100); // avoid rate limit
    }
  }
}

(async () => {
  for (const zone of ZONES) {
    await crawlZone(zone);
    if (cafes.size >= MAX_CAFES || apiCalls >= MAX_API_CALLS) break;
  }
  // Output to file
  fs.writeFileSync('cafes_expanded.json', JSON.stringify(Array.from(cafes.values()), null, 2));
  console.log(`Done. Cafes: ${cafes.size}, API calls: ${apiCalls}`);
})();

================
File: scripts/migrations/20250127000000_add_cafe_photos_table.down.sql
================
-- DOWN: Remove cafe_photos table and related triggers
DROP TRIGGER IF EXISTS trigger_update_cafe_hero_photo ON public.cafe_photos;
DROP FUNCTION IF EXISTS update_cafe_hero_photo();
DROP TABLE IF EXISTS public.cafe_photos;
ALTER TABLE public.cafes DROP COLUMN IF EXISTS hero_updated_at;

================
File: scripts/migrations/20250127000000_add_cafe_photos_table.up.sql
================
-- UP: Create cafe_photos table for user-generated photos
CREATE TABLE public.cafe_photos (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  cafe_id UUID REFERENCES public.cafes(id) ON DELETE CASCADE NOT NULL,
  photo_url TEXT NOT NULL,
  uploaded_by UUID REFERENCES public.users(id) ON DELETE SET NULL,
  uploaded_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  is_approved BOOLEAN NOT NULL DEFAULT true,
  is_hero BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create indexes for performance
CREATE INDEX idx_cafe_photos_cafe_id ON public.cafe_photos(cafe_id);
CREATE INDEX idx_cafe_photos_uploaded_by ON public.cafe_photos(uploaded_by);
CREATE INDEX idx_cafe_photos_is_hero ON public.cafe_photos(is_hero) WHERE is_hero = true;
CREATE INDEX idx_cafe_photos_uploaded_at ON public.cafe_photos(uploaded_at DESC);

-- Create trigger to update cafe hero_photo_url when is_hero changes
CREATE OR REPLACE FUNCTION update_cafe_hero_photo()
RETURNS TRIGGER AS $$
BEGIN
  -- If this photo is being set as hero, unset all other hero photos for this cafe
  IF NEW.is_hero = true THEN
    UPDATE public.cafe_photos 
    SET is_hero = false 
    WHERE cafe_id = NEW.cafe_id AND id != NEW.id;
    
    -- Update the cafe's hero_photo_url
    UPDATE public.cafes 
    SET hero_photo_url = NEW.photo_url, updated_at = now()
    WHERE id = NEW.cafe_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_cafe_hero_photo
  AFTER INSERT OR UPDATE ON public.cafe_photos
  FOR EACH ROW
  WHEN (NEW.is_hero = true)
  EXECUTE FUNCTION update_cafe_hero_photo();

-- Add hero_updated_at column to cafes table for tracking
ALTER TABLE public.cafes ADD COLUMN IF NOT EXISTS hero_updated_at TIMESTAMP WITH TIME ZONE;

-- Update the trigger to also set hero_updated_at
CREATE OR REPLACE FUNCTION update_cafe_hero_photo()
RETURNS TRIGGER AS $$
BEGIN
  -- If this photo is being set as hero, unset all other hero photos for this cafe
  IF NEW.is_hero = true THEN
    UPDATE public.cafe_photos 
    SET is_hero = false 
    WHERE cafe_id = NEW.cafe_id AND id != NEW.id;
    
    -- Update the cafe's hero_photo_url and hero_updated_at
    UPDATE public.cafes 
    SET hero_photo_url = NEW.photo_url, hero_updated_at = now(), updated_at = now()
    WHERE id = NEW.cafe_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

================
File: scripts/nodeSupabaseClient.ts
================
import { createClient } from '@supabase/supabase-js';
import 'dotenv/config';

// Node.js compatible Supabase client
const SUPABASE_URL = process.env.VITE_SUPABASE_URL || "https://hhdcequsdmosxzjebdyj.supabase.co";
const SUPABASE_ANON_KEY = process.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoZGNlcXVzZG1vc3h6amViZHlqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNjQwODMsImV4cCI6MjA3MzY0MDA4M30.BJ8tbA2zBC_IgC3Li_uE5P1-cPHA1Gi6mESaJVToPqA";
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Node.js compatible Google Places sync
export async function syncGooglePlacesCafes() {
  const GOOGLE_PLACES_API_KEY = process.env.GOOGLE_PLACES_API_KEY;
  
  if (!GOOGLE_PLACES_API_KEY) {
    console.error('Google Places API key not found');
    return { data: 0, success: false, error: 'API key missing' };
  }
  
  console.log('Starting Google Places sync...');
  
  try {
    const queries = ['coffee shop houston', 'cafe houston'];
    let totalSynced = 0;
    
    for (const query of queries) {
      console.log(`Searching for: ${query}`);
      
      const url = `https://maps.googleapis.com/maps/api/place/textsearch/json?query=${encodeURIComponent(query)}&location=29.7604,-95.3698&radius=50000&key=${GOOGLE_PLACES_API_KEY}`;
      
      const response = await fetch(url);
      const data = await response.json();
      
      console.log(`Results found:`, data.results?.length || 0);
      
      if (data.results) {
        for (const place of data.results) {
          await saveCafeToDatabase(place);
          totalSynced++;
        }
      }
    }
    
    return { data: totalSynced, success: true };
  } catch (error) {
    console.error('Sync error:', error);
    return { data: 0, success: false, error: 'Sync failed' };
  }
}

async function saveCafeToDatabase(place: any) {
  const cafeData = {
    place_id: place.place_id,
    name: place.name,
    address: place.formatted_address,
    latitude: place.geometry.location.lat,
    longitude: place.geometry.location.lng,
    google_rating: place.rating,
    price_level: place.price_level,
    is_active: true
  };
  
  const { error } = await supabase
    .from('cafes')
    .upsert(cafeData, { onConflict: 'place_id' });
  
  if (error) {
    console.error('Error saving cafe:', error);
  } else {
    console.log(`Saved: ${cafeData.name}`);
  }
}

================
File: scripts/README.md
================
# BeanScene Database Seeding Scripts

This directory contains scripts to populate the BeanScene database with realistic sample data.

## Prerequisites

1. **Environment Variables**: Ensure your `.env` file contains:
   ```
   VITE_SUPABASE_URL=your_supabase_url
   VITE_SUPABASE_ANON_KEY=your_supabase_anon_key
   ```

2. **Dependencies**: Install required packages:
   ```bash
   npm install @faker-js/faker tsx
   ```

3. **Database Setup**: Run all migrations first:
   ```bash
   supabase db push
   ```

## Available Scripts

### 1. Seed Reviews and Amenities (`seedReviewsAmenities.ts`)

Fetches real data from Google Places API to populate:
- Cafe reviews from Google Places
- Opening hours
- Phone numbers
- Websites
- Price levels

**Usage:**
```bash
npm run seed:reviews
```

**Features:**
- Processes 50 cafes per batch
- Skips cafes that already have reviews (idempotent)
- Respects API rate limits with delays
- Logs progress and success/failure rates
- Updates cafe details with missing information

**Estimated Cost:** ~$0.85 for 50 cafes (Google Places API pricing)

### 2. Seed Posts (`seedPosts.ts`)

Generates realistic user posts with:
- Random usernames
- Realistic review text
- Coffee-related tags
- Unsplash coffee images
- Ratings between 3-5 stars
- Timestamps over the past 2-3 weeks

**Usage:**
```bash
npm run seed:posts
```

**Features:**
- Creates 50 diverse posts
- Uses realistic Houston coffee shop names
- Generates authentic review content
- Includes proper tagging system
- Distributes posts across different cafes

## Running the Scripts

### Option 1: Individual Scripts
```bash
# Seed reviews and amenities first
npm run seed:reviews

# Then seed posts
npm run seed:posts
```

### Option 2: All at Once
```bash
npm run seed:reviews && npm run seed:posts
```

## Expected Results

After running both scripts, you should have:

- **Reviews**: 3-5 Google reviews per cafe (for cafes with available data)
- **Posts**: 50 user-generated posts with images and reviews
- **User Activities**: Activity logs for all generated posts
- **Analytics Data**: Real metrics for the admin dashboard

## Troubleshooting

### Common Issues

1. **Google Places API Errors**
   - Ensure API key is configured
   - Check API quotas and billing
   - Verify place IDs are valid

2. **Supabase Connection Issues**
   - Verify environment variables
   - Check Supabase project status
   - Ensure RLS policies allow inserts

3. **Rate Limiting**
   - Scripts include built-in delays
   - Reduce batch sizes if needed
   - Check API usage in Google Cloud Console

### Monitoring Progress

Both scripts provide detailed logging:
- Progress indicators
- Success/failure counts
- Error details for failed operations
- Final summary statistics

## Data Quality

The seeded data includes:
- **Realistic usernames**: Coffee-themed usernames
- **Authentic reviews**: Human-written review templates
- **Proper tagging**: Coffee-related tags from the app's tag system
- **Realistic ratings**: 3-5 star ratings (no perfect scores)
- **Diverse content**: Mix of check-ins, reviews, and photo posts

## Next Steps

After seeding:
1. Verify data in Supabase dashboard
2. Test the app with populated data
3. Check admin analytics dashboard
4. Validate user profiles and activity feeds

## Cost Considerations

- **Google Places API**: ~$0.017 per place details request
- **Supabase**: Minimal cost for database operations
- **Unsplash**: Free for development use

Total estimated cost for full seeding: ~$1-2

================
File: scripts/refreshAmenities.js
================
// scripts/refreshAmenities.js
// Update amenities for all cafes using Google Places Details API

const fs = require('fs');
const fetch = require('node-fetch');

const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;
if (!GOOGLE_API_KEY) throw new Error('GOOGLE_API_KEY env var required');

const cafes = JSON.parse(fs.readFileSync('cafes_expanded.json', 'utf-8'));
const updated = [];
let apiCalls = 0;
const MAX_API_CALLS = 2000;

async function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function fetchDetails(placeId) {
  if (apiCalls >= MAX_API_CALLS) return null;
  const url = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${placeId}&fields=opening_hours,price_level,wheelchair_accessible_entrance,parking&key=${GOOGLE_API_KEY}`;
  apiCalls++;
  const resp = await fetch(url);
  if (!resp.ok) return null;
  const json = await resp.json();
  return json.result || null;
}

(async () => {
  for (const cafe of cafes) {
    if (apiCalls >= MAX_API_CALLS) break;
    const details = await fetchDetails(cafe.place_id);
    if (details) {
      cafe.opening_hours = details.opening_hours?.weekday_text || [];
      cafe.price_level = details.price_level;
      cafe.wheelchair_accessible_entrance = details.wheelchair_accessible_entrance;
      cafe.parking = details.parking;
      updated.push(cafe);
    } else {
      updated.push(cafe);
    }
    await sleep(100);
  }
  fs.writeFileSync('cafes_amenities.json', JSON.stringify(updated, null, 2));
  console.log(`Done. Updated: ${updated.length}, API calls: ${apiCalls}`);
})();

================
File: scripts/seedCafes.backup.ts
================
import { createClient } from '@supabase/supabase-js';

// Node.js compatible Supabase client
const SUPABASE_URL = process.env.VITE_SUPABASE_URL || "https://hhdcequsdmosxzjebdyj.supabase.co";
const SUPABASE_ANON_KEY = process.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoZGNlcXVzZG1vc3h6amViZHlqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNjQwODMsImV4cCI6MjA3MzY0MDA4M30.BJ8tbA2zBC_IgC3Li_uE5P1-cPHA1Gi6mESaJVToPqA";
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Convert Google's price level strings to integers for database
function convertPriceLevel(priceLevel: string): number | null {
  switch (priceLevel) {
    case 'PRICE_LEVEL_FREE': return 0;
    case 'PRICE_LEVEL_INEXPENSIVE': return 1;
    case 'PRICE_LEVEL_MODERATE': return 2;
    case 'PRICE_LEVEL_EXPENSIVE': return 3;
    case 'PRICE_LEVEL_VERY_EXPENSIVE': return 4;
    default: return null;
  }
}

async function syncGooglePlacesCafes() {
  const GOOGLE_PLACES_API_KEY = process.env.GOOGLE_PLACES_API_KEY;
  
  if (!GOOGLE_PLACES_API_KEY) {
    console.error('Google Places API key not found');
    return { data: 0, success: false };
  }
  
  console.log('Starting Google Places sync...');
  
  // Houston metro area coordinate grid for comprehensive coverage
  const houstonCoordinates = [
    { lat: 29.7604, lng: -95.3698, name: "Downtown Houston" },
    { lat: 29.8016, lng: -95.3981, name: "Heights/North Houston" },
    { lat: 29.7372, lng: -95.2891, name: "East Houston" },
    { lat: 29.7604, lng: -95.4934, name: "West Houston" },
    { lat: 29.6774, lng: -95.3698, name: "South Houston" },
    { lat: 29.7755, lng: -95.4095, name: "Montrose/River Oaks" },
    { lat: 29.7372, lng: -95.4147, name: "Southwest Houston" },
    { lat: 29.7982, lng: -95.2891, name: "Northeast Houston" },
    { lat: 29.6774, lng: -95.2891, name: "Southeast Houston" }
  ];
  
  const searchTerms = ['coffee shop', 'cafe', 'coffee house'];
  let totalSynced = 0;
  const processedPlaceIds = new Set(); // Track duplicates
  
  for (const location of houstonCoordinates) {
    for (const searchTerm of searchTerms) {
      const query = `${searchTerm} ${location.name}`;
      console.log(`Searching: ${query}`);
      
      try {
        const response = await fetch('https://places.googleapis.com/v1/places:searchText', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Goog-Api-Key': GOOGLE_PLACES_API_KEY,
            'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.location,places.rating,places.priceLevel,places.photos'
          },
          body: JSON.stringify({
            textQuery: query,
            locationBias: {
              circle: {
                center: { latitude: location.lat, longitude: location.lng },
                radius: 25000 // 25km radius from each point
              }
            },
            maxResultCount: 60 // Google's maximum per query
          })
        });
        
        const data = await response.json();
        console.log(`API Response status: ${response.status}`);
        console.log(`Results found: ${data.places?.length || 0}`);
        
        if (data.error) {
          console.error('Google API Error:', data.error);
          continue;
        }
        
        if (data.places) {
          for (const place of data.places) {
            // Skip duplicates across different searches
            if (processedPlaceIds.has(place.id)) {
              console.log(`Skipping duplicate: ${place.displayName?.text || place.displayName}`);
              continue;
            }
            
            processedPlaceIds.add(place.id);
            
            try {
              // Get the first photo reference if available
              let heroPhotoReference = null;
              if (place.photos && place.photos.length > 0) {
                heroPhotoReference = place.photos[0].name;
              }
              
              const cafeData = {
                place_id: place.id,
                name: place.displayName?.text || place.displayName,
                address: place.formattedAddress,
                latitude: place.location.latitude,
                longitude: place.location.longitude,
                google_rating: place.rating,
                price_level: convertPriceLevel(place.priceLevel), // Convert string to integer
                google_photo_reference: heroPhotoReference,
                is_active: true
              };
              
              console.log(`Processing cafe: ${cafeData.name}`);
              
              const { error } = await supabase
                .from('cafes')
                .upsert(cafeData, { onConflict: 'place_id' });
              
              if (error) {
                console.error('Error saving cafe:', error);
              } else {
                console.log(`‚úÖ Saved: ${cafeData.name}`);
                totalSynced++;
              }
            } catch (placeError) {
              console.error('Error processing place:', placeError);
            }
          }
        }
        
        // Rate limiting - wait between API calls to avoid hitting limits
        await new Promise(resolve => setTimeout(resolve, 1500));
        
      } catch (fetchError) {
        console.error(`Error fetching data for "${query}":`, fetchError);
      }
    }
  }
  
  console.log(`Sync completed. Total cafes synced: ${totalSynced}`);
  return { data: totalSynced, success: true };
}

// Run the sync
(async () => {
  try {
    console.log('Starting cafe seeding...');
    const result = await syncGooglePlacesCafes();
    console.log('Seeding result:', result);
    
    if (result.success && result.data > 0) {
      console.log(`SUCCESS: ${result.data} Houston coffee shops have been seeded to your database!`);
    } else {
      console.log('No cafes were seeded. Check the logs above for any errors.');
    }
  } catch (err) {
    console.error('Fatal error:', err);
  }
})();

================
File: scripts/seedCafes.ts
================
import { createClient } from '@supabase/supabase-js';
import { config } from 'dotenv';
import { resolve } from 'path';

// Load environment variables from .env.local
config({ path: resolve(process.cwd(), '.env.local') });

// Node.js compatible Supabase client
const SUPABASE_URL = process.env.VITE_SUPABASE_URL || "https://hhdcequsdmosxzjebdyj.supabase.co";
const SUPABASE_ANON_KEY = process.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoZGNlcXVzZG1vc3h6amViZHlqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNjQwODMsImV4cCI6MjA3MzY0MDA4M30.BJ8tbA2zBC_IgC3Li_uE5P1-cPHA1Gi6mESaJVToPqA";
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Convert Google's price level strings to integers for database
function convertPriceLevel(priceLevel: string): number | null {
  switch (priceLevel) {
    case 'PRICE_LEVEL_FREE': return 0;
    case 'PRICE_LEVEL_INEXPENSIVE': return 1;
    case 'PRICE_LEVEL_MODERATE': return 2;
    case 'PRICE_LEVEL_EXPENSIVE': return 3;
    case 'PRICE_LEVEL_VERY_EXPENSIVE': return 4;
    default: return null;
  }
}

async function syncGooglePlacesCafes() {
  const GOOGLE_PLACES_API_KEY = process.env.GOOGLE_PLACES_API_KEY;
  
  if (!GOOGLE_PLACES_API_KEY) {
    console.error('‚ùå Google Places API key not found in .env.local');
    console.error('üí° Make sure GOOGLE_PLACES_API_KEY is set in .env.local file');
    return { data: 0, success: false };
  }
  
  console.log('üöÄ Starting comprehensive Houston metro cafe seeding...');
  console.log(`üîë API Key loaded: ${GOOGLE_PLACES_API_KEY.substring(0, 10)}...${GOOGLE_PLACES_API_KEY.substring(GOOGLE_PLACES_API_KEY.length - 4)}\n`);
  
  // EXPANDED: 25 Houston metro area zones for complete coverage
  const houstonCoordinates = [
    // Inner Loop (5km radius)
    { lat: 29.7604, lng: -95.3698, name: "Downtown Houston", radius: 5000 },
    { lat: 29.7755, lng: -95.4095, name: "Montrose/Museum District", radius: 5000 },
    { lat: 29.8016, lng: -95.3981, name: "Heights", radius: 5000 },
    { lat: 29.7372, lng: -95.2891, name: "East End/EaDo", radius: 5000 },
    { lat: 29.6774, lng: -95.3698, name: "Medical Center", radius: 5000 },
    { lat: 29.7982, lng: -95.2891, name: "Near Northside", radius: 5000 },
    { lat: 29.6774, lng: -95.2891, name: "Southeast Houston", radius: 5000 },
    { lat: 29.7604, lng: -95.4934, name: "West Houston/Galleria", radius: 5000 },
    { lat: 29.8200, lng: -95.4000, name: "North Heights", radius: 5000 },
    
    // Inner Suburbs (8km radius)
    { lat: 29.5600, lng: -95.0890, name: "Clear Lake/NASA", radius: 8000 },
    { lat: 29.9600, lng: -95.3400, name: "North Houston/Intercontinental", radius: 8000 },
    { lat: 29.7200, lng: -95.6500, name: "West Houston/Katy Edge", radius: 8000 },
    { lat: 29.5400, lng: -95.4500, name: "Southwest Houston", radius: 8000 },
    { lat: 30.0600, lng: -95.5500, name: "The Woodlands South", radius: 8000 },
    { lat: 29.6900, lng: -95.5600, name: "Westchase/Bellaire", radius: 8000 },
    
    // Outer Metro (10km radius)
    { lat: 30.1587, lng: -95.4969, name: "The Woodlands", radius: 10000 },
    { lat: 29.8197, lng: -95.6404, name: "Northwest Houston/Cypress", radius: 10000 },
    { lat: 29.6200, lng: -95.2000, name: "Pasadena/Deer Park", radius: 10000 },
    { lat: 29.5500, lng: -95.1000, name: "League City/Webster", radius: 10000 },
    { lat: 29.7800, lng: -95.8200, name: "Katy", radius: 10000 },
    { lat: 30.0200, lng: -95.1400, name: "Humble/Atascocita", radius: 10000 },
    { lat: 29.6100, lng: -95.6300, name: "Sugar Land/Missouri City", radius: 10000 },
    { lat: 29.5200, lng: -95.6700, name: "Richmond/Rosenberg", radius: 10000 },
    { lat: 30.3200, lng: -95.4600, name: "Conroe/Montgomery County", radius: 10000 },
    { lat: 29.4600, lng: -95.0400, name: "Galveston County North", radius: 10000 }
  ];
  
  // EXPANDED: Comprehensive search terms including chains
  const searchTerms = [
    'coffee shop',
    'cafe', 
    'coffee house',
    'espresso bar',
    'coffee roaster',
    'Starbucks',
    'Dunkin',
    'specialty coffee',
    'third wave coffee',
    'coffee bar',
    'breakfast coffee',
    'coffee beans'
  ];
  
  let totalSynced = 0;
  let totalApiCalls = 0;
  const processedPlaceIds = new Set(); // Track duplicates
  const startTime = Date.now();
  
  console.log(`üìç Zones: ${houstonCoordinates.length}`);
  console.log(`üîç Search terms: ${searchTerms.length}`);
  console.log(`üéØ Expected API calls: ~${houstonCoordinates.length * searchTerms.length}\n`);
  
  for (let i = 0; i < houstonCoordinates.length; i++) {
    const location = houstonCoordinates[i];
    console.log(`\nüìç Zone ${i + 1}/${houstonCoordinates.length}: ${location.name}`);
    
    for (const searchTerm of searchTerms) {
      const query = `${searchTerm} ${location.name}`;
      console.log(`  üîç Searching: "${searchTerm}"`);
      
      try {
        totalApiCalls++;
        
        const response = await fetch('https://places.googleapis.com/v1/places:searchText', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Goog-Api-Key': GOOGLE_PLACES_API_KEY,
            'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.location,places.rating,places.priceLevel,places.photos,places.types,places.businessStatus'
          },
          body: JSON.stringify({
            textQuery: query,
            locationBias: {
              circle: {
                center: { latitude: location.lat, longitude: location.lng },
                radius: location.radius
              }
            },
            maxResultCount: 20 // Reduced to save API calls
          })
        });
        
        const data = await response.json();
        
        if (data.error) {
          console.error(`    ‚ùå Google API Error:`, data.error);
          continue;
        }
        
        if (response.status === 429) {
          console.error(`    ‚ö†Ô∏è Rate limit hit! Waiting 60 seconds...`);
          await new Promise(resolve => setTimeout(resolve, 60000));
          continue;
        }
        
        const resultsCount = data.places?.length || 0;
        console.log(`    üìä Found ${resultsCount} results`);
        
        if (data.places) {
          for (const place of data.places) {
            // Skip duplicates across different searches
            if (processedPlaceIds.has(place.id)) {
              continue;
            }
            
            // Skip permanently closed businesses
            if (place.businessStatus === 'CLOSED_PERMANENTLY') {
              console.log(`    ‚è≠Ô∏è Skipping closed: ${place.displayName?.text}`);
              continue;
            }
            
            processedPlaceIds.add(place.id);
            
            try {
              // Get the first photo reference if available
              let heroPhotoReference = null;
              if (place.photos && place.photos.length > 0) {
                heroPhotoReference = place.photos[0].name;
              }
              
              const cafeData = {
                place_id: place.id,
                name: place.displayName?.text || place.displayName,
                address: place.formattedAddress,
                latitude: place.location.latitude,
                longitude: place.location.longitude,
                google_rating: place.rating,
                price_level: convertPriceLevel(place.priceLevel),
                google_photo_reference: heroPhotoReference,
                is_active: true,
                tags: []
              };
              
              const { error } = await supabase
                .from('cafes')
                .upsert(cafeData, { onConflict: 'place_id' });
              
              if (error) {
                console.error(`    ‚ùå Error saving ${cafeData.name}:`, error.message);
              } else {
                totalSynced++;
                console.log(`    ‚úÖ Saved: ${cafeData.name}`);
              }
            } catch (placeError) {
              console.error('    ‚ùå Error processing place:', placeError);
            }
          }
        }
        
        // Rate limiting - wait between API calls
        await new Promise(resolve => setTimeout(resolve, 1200));
        
      } catch (fetchError) {
        console.error(`    ‚ùå Error fetching "${query}":`, fetchError);
      }
    }
    
    // Progress update after each zone
    const elapsed = ((Date.now() - startTime) / 1000 / 60).toFixed(1);
    console.log(`  üìä Progress: ${totalSynced} cafes saved | ${totalApiCalls} API calls | ${elapsed} min elapsed`);
  }
  
  const endTime = Date.now();
  const duration = ((endTime - startTime) / 1000 / 60).toFixed(2);
  
  console.log('\n‚úÖ Seeding Complete!');
  console.log(`üìä Final Stats:`);
  console.log(`  - Unique cafes saved: ${totalSynced}`);
  console.log(`  - Total API calls used: ${totalApiCalls}`);
  console.log(`  - Total duration: ${duration} minutes`);
  console.log(`  - Average: ${(totalApiCalls / parseFloat(duration)).toFixed(1)} calls/minute`);
  
  return { data: totalSynced, success: true, apiCalls: totalApiCalls };
}

// Run the sync
(async () => {
  try {
    console.log('üé¨ Starting comprehensive Houston metro cafe seeding...\n');
    const result = await syncGooglePlacesCafes();
    
    if (result.success && result.data > 0) {
      console.log(`\nüéâ SUCCESS: ${result.data} Houston coffee shops have been seeded to your database!`);
      console.log(`üí∞ API calls used: ${result.apiCalls}`);
    } else {
      console.log('\n‚ö†Ô∏è No cafes were seeded. Check the logs above for errors.');
    }
    
    process.exit(0);
  } catch (err) {
    console.error('\nüí• Fatal error:', err);
    process.exit(1);
  }
})();

================
File: scripts/seedPosts.ts
================
import { createClient } from '@supabase/supabase-js';
import { faker } from '@faker-js/faker';

// Initialize Supabase client
const supabaseUrl = process.env.VITE_SUPABASE_URL || 'https://your-project.supabase.co';
const supabaseKey = process.env.VITE_SUPABASE_ANON_KEY || 'your-anon-key';
const supabase = createClient(supabaseUrl, supabaseKey);

interface Cafe {
  id: string;
  place_id: string;
  name: string;
  neighborhood: string;
}

interface PostData {
  user_id: string | null;
  cafe_id: string;
  place_id: string;
  image_url: string;
  rating: number;
  text_review: string;
  tags: string[];
  username: string;
  device_id: string;
}

const COFFEE_TAGS = [
  "latte-art", "cozy-vibes", "laptop-friendly", "third-wave", "cold-brew",
  "pastries", "rooftop", "instagram-worthy", "pet-friendly", "outdoor-seating",
  "wifi", "quiet", "busy", "date-spot", "group-friendly", "drive-thru"
];

const REVIEW_TEMPLATES = [
  "Amazing coffee and great atmosphere! Perfect for working remotely.",
  "Love the latte art here. The baristas really know their craft.",
  "Cozy spot with excellent pastries. The croissants are to die for!",
  "Great place to meet friends. The outdoor seating is perfect for Houston weather.",
  "Fast service and consistently good coffee. My go-to morning spot.",
  "The cold brew here is incredible. Highly recommend!",
  "Beautiful space with lots of natural light. Great for photos too.",
  "Friendly staff and delicious coffee. Will definitely be back.",
  "Perfect study spot with reliable wifi and comfortable seating.",
  "Love the local vibe here. Feels like a hidden gem in the neighborhood.",
  "The pastries are fresh and the coffee is always on point.",
  "Great location with plenty of parking. Coffee quality is excellent.",
  "Chill atmosphere, perfect for a casual coffee date.",
  "The baristas are knowledgeable and the coffee selection is impressive.",
  "Clean, modern space with great energy. Coffee tastes amazing.",
  "Love coming here on weekends. The vibe is always relaxed and welcoming.",
  "Excellent coffee and even better service. Highly recommend!",
  "Great spot for remote work. Quiet but not too quiet.",
  "The seasonal drinks are always creative and delicious.",
  "Perfect neighborhood coffee shop. Feels like home away from home."
];

const USERNAMES = [
  "coffee_lover_houston", "bean_scene_regular", "houston_cafe_hunter", "coffee_addict_tx",
  "latte_art_fan", "third_wave_coffee", "houston_roaster", "cafe_hopper_houston",
  "coffee_critic_tx", "bean_enthusiast", "houston_coffee_guide", "cafe_explorer_houston",
  "coffee_photographer", "houston_bean_lover", "cafe_reviewer_tx", "coffee_blogger_houston",
  "bean_scene_member", "houston_coffee_nerd", "cafe_regular_houston", "coffee_aficionado_tx"
];

async function fetchCafes(): Promise<Cafe[]> {
  const { data, error } = await supabase
    .from('cafes')
    .select('id, place_id, name, neighborhood')
    .eq('is_active', true)
    .limit(100);

  if (error) {
    console.error('Error fetching cafes:', error);
    return [];
  }

  return data || [];
}

function generateRandomPost(cafe: Cafe): PostData {
  const username = faker.helpers.arrayElement(USERNAMES);
  const deviceId = faker.string.uuid();
  const rating = faker.number.int({ min: 3, max: 5 });
  const reviewText = faker.helpers.arrayElement(REVIEW_TEMPLATES);
  const tags = faker.helpers.arrayElements(COFFEE_TAGS, { min: 1, max: 4 });
  
  // Generate realistic image URL (using Unsplash coffee images)
  const imageUrl = `https://images.unsplash.com/photo-${faker.helpers.arrayElement([
    '1509042239860-f550ce710b93', // Coffee cup
    '1495474472287-4d71bcdd2085', // Coffee beans
    '1447933601403-0c6688de566e', // Latte art
    '1461023051463-6d8b0c3d0b8a', // Coffee shop
    '1506905925346-21bda4d32df4', // Coffee brewing
    '1511920170033-f8396924c348', // Coffee cup with art
    '1498804103079-a6351b050096', // Coffee and pastries
    '1501339847302-ac426a4a7cbb', // Coffee shop interior
    '1514432324607-a09d9b4aefdd', // Coffee cup close up
    '1506905925346-21bda4d32df4'  // Coffee brewing
  ])}?w=800&h=600&fit=crop&crop=center`;

  return {
    user_id: null, // Anonymous posts
    cafe_id: cafe.id,
    place_id: cafe.place_id,
    image_url: imageUrl,
    rating,
    text_review: reviewText,
    tags,
    username,
    device_id: deviceId
  };
}

function generateRandomDate(daysAgo: number): string {
  const date = new Date();
  date.setDate(date.getDate() - faker.number.int({ min: 1, max: daysAgo }));
  date.setHours(faker.number.int({ min: 6, max: 22 })); // Coffee shop hours
  date.setMinutes(faker.number.int({ min: 0, max: 59 }));
  return date.toISOString();
}

async function insertPosts(posts: PostData[]): Promise<void> {
  const { error } = await supabase
    .from('posts')
    .insert(posts);

  if (error) {
    console.error('Error inserting posts:', error);
    throw error;
  }
}

async function seedPosts(): Promise<void> {
  console.log('Starting posts seeding...');
  
  try {
    const cafes = await fetchCafes();
    console.log(`Found ${cafes.length} cafes`);

    if (cafes.length === 0) {
      console.log('No cafes found. Please seed cafes first.');
      return;
    }

    const postsToCreate = 50;
    const posts: PostData[] = [];

    console.log(`Generating ${postsToCreate} posts...`);

    for (let i = 0; i < postsToCreate; i++) {
      const randomCafe = faker.helpers.arrayElement(cafes);
      const post = generateRandomPost(randomCafe);
      posts.push(post);
    }

    // Insert posts in batches
    const batchSize = 10;
    let inserted = 0;

    for (let i = 0; i < posts.length; i += batchSize) {
      const batch = posts.slice(i, i + batchSize);
      await insertPosts(batch);
      inserted += batch.length;
      console.log(`Inserted ${inserted}/${posts.length} posts`);
      
      // Add small delay between batches
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    console.log('\n=== Posts Seeding Complete ===');
    console.log(`Total posts created: ${inserted}`);
    console.log(`Posts per cafe: ${Math.round(inserted / cafes.length)}`);

  } catch (error) {
    console.error('Posts seeding failed:', error);
    process.exit(1);
  }
}

// Run the seeding script
if (require.main === module) {
  seedPosts()
    .then(() => {
      console.log('Posts seeding completed successfully');
      process.exit(0);
    })
    .catch((error) => {
      console.error('Posts seeding failed:', error);
      process.exit(1);
    });
}

export { seedPosts };

================
File: scripts/seedReviewsAmenities.ts
================
import { createClient } from '@supabase/supabase-js';
import { googlePlacesService } from '../src/services/googlePlacesService';

// Initialize Supabase client
const supabaseUrl = process.env.VITE_SUPABASE_URL || 'https://your-project.supabase.co';
const supabaseKey = process.env.VITE_SUPABASE_ANON_KEY || 'your-anon-key';
const supabase = createClient(supabaseUrl, supabaseKey);

interface Cafe {
  id: string;
  place_id: string;
  name: string;
}

interface GoogleReview {
  author_name: string;
  rating: number;
  text: string;
  time: number;
  profile_photo_url?: string;
}

interface GooglePlaceDetails {
  reviews?: GoogleReview[];
  opening_hours?: {
    weekday_text: string[];
  };
  website?: string;
  formatted_phone_number?: string;
  price_level?: number;
  photos?: Array<{
    photo_reference: string;
  }>;
}

async function fetchCafes(): Promise<Cafe[]> {
  const { data, error } = await supabase
    .from('cafes')
    .select('id, place_id, name')
    .eq('is_active', true)
    .limit(50); // Process 50 cafes per batch

  if (error) {
    console.error('Error fetching cafes:', error);
    return [];
  }

  return data || [];
}

async function checkExistingReviews(cafeId: string): Promise<boolean> {
  const { data, error } = await supabase
    .from('cafe_reviews')
    .select('id')
    .eq('cafe_id', cafeId)
    .limit(1);

  if (error) {
    console.error('Error checking existing reviews:', error);
    return false;
  }

  return (data?.length || 0) > 0;
}

async function insertReviews(cafeId: string, reviews: GoogleReview[]): Promise<void> {
  const reviewData = reviews.map(review => ({
    cafe_id: cafeId,
    reviewer_name: review.author_name,
    rating: review.rating,
    review_text: review.text,
    profile_photo_url: review.profile_photo_url,
    time: new Date(review.time * 1000).toISOString()
  }));

  const { error } = await supabase
    .from('cafe_reviews')
    .insert(reviewData);

  if (error) {
    console.error('Error inserting reviews:', error);
    throw error;
  }
}

async function updateCafeDetails(cafeId: string, details: GooglePlaceDetails): Promise<void> {
  const updateData: any = {};

  if (details.opening_hours?.weekday_text) {
    updateData.opening_hours = details.opening_hours.weekday_text;
  }

  if (details.website) {
    updateData.website = details.website;
  }

  if (details.formatted_phone_number) {
    updateData.phone_number = details.formatted_phone_number;
  }

  if (details.price_level) {
    updateData.price_level = details.price_level;
  }

  if (Object.keys(updateData).length > 0) {
    const { error } = await supabase
      .from('cafes')
      .update(updateData)
      .eq('id', cafeId);

    if (error) {
      console.error('Error updating cafe details:', error);
      throw error;
    }
  }
}

async function processCafe(cafe: Cafe): Promise<void> {
  try {
    console.log(`Processing cafe: ${cafe.name} (${cafe.place_id})`);

    // Check if reviews already exist
    const hasReviews = await checkExistingReviews(cafe.id);
    if (hasReviews) {
      console.log(`  Skipping ${cafe.name} - reviews already exist`);
      return;
    }

    // Fetch Google Places details
    const details = await googlePlacesService.getPlaceDetails(cafe.place_id);
    
    if (!details) {
      console.log(`  No details found for ${cafe.name}`);
      return;
    }

    // Insert reviews if available
    if (details.reviews && details.reviews.length > 0) {
      const topReviews = details.reviews
        .filter(review => review.text && review.text.length > 10)
        .slice(0, 5); // Top 5 reviews

      if (topReviews.length > 0) {
        await insertReviews(cafe.id, topReviews);
        console.log(`  Added ${topReviews.length} reviews for ${cafe.name}`);
      }
    }

    // Update cafe details
    await updateCafeDetails(cafe.id, details);
    console.log(`  Updated details for ${cafe.name}`);

    // Add delay to respect API rate limits
    await new Promise(resolve => setTimeout(resolve, 100));

  } catch (error) {
    console.error(`  Error processing ${cafe.name}:`, error);
  }
}

async function seedReviewsAndAmenities(): Promise<void> {
  console.log('Starting reviews and amenities seeding...');
  
  try {
    const cafes = await fetchCafes();
    console.log(`Found ${cafes.length} cafes to process`);

    let processed = 0;
    let succeeded = 0;
    let failed = 0;

    for (const cafe of cafes) {
      try {
        await processCafe(cafe);
        succeeded++;
      } catch (error) {
        console.error(`Failed to process ${cafe.name}:`, error);
        failed++;
      }
      
      processed++;
      console.log(`Progress: ${processed}/${cafes.length} (${Math.round((processed / cafes.length) * 100)}%)`);
    }

    console.log('\n=== Seeding Complete ===');
    console.log(`Total processed: ${processed}`);
    console.log(`Succeeded: ${succeeded}`);
    console.log(`Failed: ${failed}`);
    console.log(`Success rate: ${Math.round((succeeded / processed) * 100)}%`);

  } catch (error) {
    console.error('Seeding failed:', error);
    process.exit(1);
  }
}

// Run the seeding script
if (require.main === module) {
  seedReviewsAndAmenities()
    .then(() => {
      console.log('Seeding completed successfully');
      process.exit(0);
    })
    .catch((error) => {
      console.error('Seeding failed:', error);
      process.exit(1);
    });
}

export { seedReviewsAndAmenities };

================
File: src/api/place/details.ts
================
import type { NextRequest } from 'next/server';

const GOOGLE_PLACES_API_KEY = process.env.GOOGLE_PLACES_API_KEY;

export async function GET(request: NextRequest) {
  if (!GOOGLE_PLACES_API_KEY) {
    return new Response(JSON.stringify({ 
      status: 'ERROR', 
      error_message: 'Google Places API key not configured' 
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  const { searchParams } = new URL(request.url);
  const placeId = searchParams.get('place_id');
  const fields = searchParams.get('fields') || 'name,photos';

  if (!placeId) {
    return new Response(JSON.stringify({ 
      status: 'ERROR', 
      error_message: 'place_id parameter is required' 
    }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  try {
    const url = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${placeId}&fields=${fields}&key=${GOOGLE_PLACES_API_KEY}`;
    
    const response = await fetch(url);
    const data = await response.json();

    return new Response(JSON.stringify(data), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    return new Response(JSON.stringify({ 
      status: 'ERROR', 
      error_message: 'Failed to fetch place details' 
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

================
File: src/api/place/photo.ts
================
import type { NextRequest } from 'next/server';

const GOOGLE_PLACES_API_KEY = process.env.GOOGLE_PLACES_API_KEY;

export async function GET(request: NextRequest) {
  if (!GOOGLE_PLACES_API_KEY) {
    return new Response('Google Places API key not configured', { status: 500 });
  }

  const { searchParams } = new URL(request.url);
  const photoreference = searchParams.get('photoreference');
  const maxwidth = searchParams.get('maxwidth') || '800';
  const maxheight = searchParams.get('maxheight') || '600';

  if (!photoreference) {
    return new Response('photoreference parameter is required', { status: 400 });
  }

  try {
    const url = `https://maps.googleapis.com/maps/api/place/photo?maxwidth=${maxwidth}&maxheight=${maxheight}&photoreference=${photoreference}&key=${GOOGLE_PLACES_API_KEY}`;
    
    const response = await fetch(url);
    
    if (!response.ok) {
      return new Response('Failed to fetch photo', { status: response.status });
    }

    const imageBuffer = await response.arrayBuffer();
    
    return new Response(imageBuffer, {
      status: 200,
      headers: {
        'Content-Type': response.headers.get('Content-Type') || 'image/jpeg',
        'Cache-Control': 'public, max-age=86400' // Cache for 24 hours
      }
    });
  } catch (error) {
    return new Response('Failed to fetch photo', { status: 500 });
  }
}

================
File: src/App.css
================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: src/App.tsx
================
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { useState, useEffect } from "react";
import Onboarding from "@/components/Onboarding";
import Home from "./pages/Home";
import Feed from "./pages/Feed";
import Search from "./pages/Search";
import CheckIn from "./pages/CheckIn";
import RecentlyViewed from "./pages/RecentlyViewed";
import Profile from "./pages/Profile";
import CafeDetail from "./pages/CafeDetail";
import ImageUpload from "./pages/ImageUpload";
import DataValidation from "./pages/DataValidation";
import TestMigration from "./pages/TestMigration";
import Moments from "./pages/Moments";
import Share from "./pages/Share";
import CreatePost from "./pages/CreatePost";
import Feedback from "./pages/Feedback";
import NotFound from "./pages/NotFound";
import AdminLogin from "./pages/admin/Login";
import AdminDashboard from "./pages/admin/Dashboard";

const queryClient = new QueryClient();

const App = () => {
  const [showOnboarding, setShowOnboarding] = useState(false);

  useEffect(() => {
    // Check if user has seen onboarding
    const hasSeenOnboarding = localStorage.getItem('hasSeenOnboarding');

    if (!hasSeenOnboarding) {
      setShowOnboarding(true);
    }
  }, []);

  const handleOnboardingComplete = () => {
    localStorage.setItem('hasSeenOnboarding', 'true');
    setShowOnboarding(false);
  };

  if (showOnboarding) {
    return <Onboarding onComplete={handleOnboardingComplete} />;
  }

  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
        <Toaster />
        <Sonner />
        <BrowserRouter>
          <Routes>
            <Route path="/" element={<Search />} />
            <Route path="/explore" element={<Search />} />
            <Route path="/home" element={<Home />} />
            <Route path="/moments" element={<Moments />} />
            <Route path="/share" element={<Share />} />
            <Route path="/checkin" element={<CheckIn />} />
            <Route path="/post" element={<CreatePost />} />
            <Route path="/recent" element={<RecentlyViewed />} />
            <Route path="/profile" element={<Profile />} />
            <Route path="/cafe/:id" element={<CafeDetail />} />
            <Route path="/cafe/:id/upload" element={<ImageUpload />} />
            <Route path="/feedback" element={<Feedback />} />
            <Route path="/admin/validation" element={<DataValidation />} />
            <Route path="/test-migration" element={<TestMigration />} />
            <Route path="/admin/login" element={<AdminLogin />} />
            <Route path="/admin/dashboard" element={<AdminDashboard />} />
            <Route path="*" element={<NotFound />} />
          </Routes>
        </BrowserRouter>
      </TooltipProvider>
    </QueryClientProvider>
  );
};

export default App;

================
File: src/components/Cafe/CafeHeader.tsx
================
import { MapPin, Phone, Clock, Star, DollarSign, Globe, Navigation, Share2, Copy } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card } from "@/components/ui/card";
import { CafePhotoUpload } from "@/components/Cafe/CafePhotoUpload"; // Correct named import
import { ParkingInfoComponent } from "@/components/Cafe/ParkingInfo";
import { WeatherWidget } from "@/components/Cafe/WeatherWidget";
import { useToast } from "@/hooks/use-toast";
import { getCafeEmoji } from "@/utils/emojiPlaceholders";

interface CafeHeaderProps {
  cafe: {
    id?: string; // Add cafe ID for photo uploads
    placeId?: string; // Add place ID for parking info
    name: string;
    address: string;
    neighborhood: string;
    rating: number;
    userRating?: number;
    hours: string;
    phone?: string;
    website?: string;
    priceLevel: number;
    topTags: string[];
    reviewSnippet: string;
    isOpen?: boolean;
    heroImage?: string;
  };
  loading?: boolean;
  onPhotoAdded?: (photoUrl: string) => void; // Add callback for photo updates
}

export function CafeHeader({ cafe, loading = false, onPhotoAdded }: CafeHeaderProps) {
  const { toast } = useToast();

  const renderPriceLevel = (level: number) => {
    return Array.from({ length: 4 }, (_, i) => (
      <DollarSign
        key={i}
        className={`w-3 h-3 ${
          i < level ? "text-primary fill-primary" : "text-muted-foreground"
        }`}
      />
    ));
  };

  const handleDirections = () => {
    const address = encodeURIComponent(`${cafe.address}, ${cafe.neighborhood}, Houston, TX`);
    const mapsUrl = `https://maps.google.com/maps?q=${address}`;
    window.open(mapsUrl, '_blank');
  };

  const handleCall = () => {
    if (cafe.phone) {
      window.location.href = `tel:${cafe.phone}`;
    }
  };

  const handleVisitWebsite = () => {
    if (cafe.website) {
      window.open(cafe.website, '_blank');
    }
  };

  const handleShare = async () => {
    const shareData = {
      title: cafe.name,
      text: `Check out ${cafe.name} in ${cafe.neighborhood}!`,
      url: window.location.href
    };

    try {
      if (navigator.share && navigator.canShare(shareData)) {
        await navigator.share(shareData);
      } else {
        // Fallback to clipboard
        await navigator.clipboard.writeText(shareData.url);
        toast({
          title: "Link copied!",
          description: "Cafe link copied to clipboard"
        });
      }
    } catch (error) {
      // Final fallback - copy to clipboard
      try {
        await navigator.clipboard.writeText(shareData.url);
        toast({
          title: "Link copied!",
          description: "Cafe link copied to clipboard"
        });
      } catch (clipboardError) {
        toast({
          title: "Share failed",
          description: "Unable to share or copy link",
          variant: "destructive"
        });
      }
    }
  };

  const getOpenStatus = (hours: string, isOpen?: boolean) => {
    if (isOpen !== undefined) {
      return isOpen ? "Open" : "Closed";
    }
    // Parse hours for status (mock logic)
    return Math.random() > 0.3 ? "Open" : "Closed";
  };

  const openStatus = getOpenStatus(cafe.hours, cafe.isOpen);
  const isCurrentlyOpen = openStatus === "Open";

  if (loading) {
    return (
      <div className="bg-card shadow-warm border-b border-border p-6">
        <div className="space-y-4 animate-pulse">
          <div className="h-8 bg-muted rounded w-3/4"></div>
          <div className="h-4 bg-muted rounded w-full"></div>
          <div className="h-4 bg-muted rounded w-1/2"></div>
          <div className="flex gap-4">
            <div className="h-4 bg-muted rounded w-16"></div>
            <div className="h-4 bg-muted rounded w-16"></div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Hero Image or Photo Upload */}
      {cafe.heroImage ? (
        <div className="relative h-48 -mx-6 -mt-6">
          <img
            src={cafe.heroImage}
            alt={cafe.name}
            className="w-full h-full object-cover"
          />
          <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-black/20 to-transparent" />
          <div className="absolute bottom-4 left-6 right-6">
            <h1 className="text-2xl font-bold text-white mb-1">{cafe.name}</h1>
            <div className="flex items-center gap-2 text-white/90">
              <MapPin className="w-4 h-4" />
              <span className="text-sm">{cafe.neighborhood}</span>
            </div>
          </div>
        </div>
      ) : cafe.id ? (
        // Show photo upload component if no hero image and we have cafe ID
        <div className="-mx-6 -mt-6">
          <CafePhotoUpload 
            cafeId={cafe.id}
            placeId={cafe.placeId}
            cafeName={cafe.name}
            onPhotoAdded={onPhotoAdded}
          />
          {/* Cafe name and neighborhood below upload component */}
          <div className="p-6 pb-0">
            <h1 className="text-2xl font-bold text-foreground mb-1">{cafe.name}</h1>
            <div className="flex items-center gap-2 text-muted-foreground">
              <MapPin className="w-4 h-4" />
              <span className="text-sm">{cafe.neighborhood}</span>
            </div>
          </div>
        </div>
      ) : (
        // Fallback emoji placeholder if no ID (shouldn't happen in practice)
        <div className="relative h-48 -mx-6 -mt-6 bg-gradient-to-br from-[#8b5a3c] to-[#6b4423] flex items-center justify-center">
          <div className="text-center text-white">
            <div className="text-8xl mb-4">{getCafeEmoji(cafe.id || cafe.placeId || cafe.name)}</div>
            <h1 className="text-2xl font-bold mb-1">{cafe.name}</h1>
            <div className="flex items-center gap-2 text-white/90 justify-center">
              <MapPin className="w-4 h-4" />
              <span className="text-sm">{cafe.neighborhood}</span>
            </div>
          </div>
        </div>
      )}

      <div className="space-y-4">
        {/* Address and Contact */}
        <Card className="p-4 bg-muted/30 border-0">
          <div className="space-y-3">
            <div className="flex items-start gap-2">
              <MapPin className="w-4 h-4 text-muted-foreground mt-1" />
              <div className="flex-1">
                <p className="text-sm font-medium">{cafe.address}</p>
                <p className="text-xs text-muted-foreground">{cafe.neighborhood}, Houston</p>
              </div>
              <Button 
                size="sm" 
                variant="ghost" 
                className="h-8 px-2 text-primary"
                onClick={handleDirections}
              >
                <Navigation className="w-4 h-4 mr-1" />
                Directions
              </Button>
            </div>

            {cafe.phone && (
              <div className="flex items-center gap-2 pt-2 border-t border-border">
                <Phone className="w-4 h-4 text-muted-foreground" />
                <span className="text-sm">{cafe.phone}</span>
                <Button 
                  size="sm" 
                  variant="ghost" 
                  className="h-8 px-2 text-primary ml-auto"
                  onClick={handleCall}
                >
                  Call
                </Button>
              </div>
            )}

            {cafe.website && (
              <div className="flex items-center gap-2 pt-2 border-t border-border">
                <Globe className="w-4 h-4 text-muted-foreground" />
                <span className="text-sm truncate flex-1">{cafe.website}</span>
                <Button 
                  size="sm" 
                  variant="ghost" 
                  className="h-8 px-2 text-primary"
                  onClick={handleVisitWebsite}
                >
                  Visit
                </Button>
              </div>
            )}
          </div>
        </Card>

        {/* Hours and Status */}
        <div className="flex items-center justify-between p-4 bg-muted/30 rounded-lg">
          <div className="flex items-center gap-2">
            <Clock className="w-4 h-4 text-muted-foreground" />
            <span className="text-sm">{cafe.hours}</span>
          </div>
          <Badge 
            variant={isCurrentlyOpen ? "default" : "secondary"}
            className={isCurrentlyOpen ? "bg-green-600 hover:bg-green-700" : ""}
          >
            {openStatus}
          </Badge>
        </div>

        {/* Parking Info */}
        {cafe.placeId && (
          <ParkingInfoComponent 
            placeId={cafe.placeId} 
            cafeName={cafe.name} 
          />
        )}

        {/* Ratings and Price */}
        <div className="flex items-center justify-between p-4 bg-card border border-border rounded-lg shadow-warm">
          <div className="flex items-center gap-4">
            <div className="flex items-center gap-1">
              <Star className="w-4 h-4 fill-yellow-400 text-yellow-400" />
              <span className="font-semibold">{cafe.rating}</span>
              <span className="text-muted-foreground text-sm">Google</span>
            </div>
            {cafe.userRating && (
              <div className="flex items-center gap-1">
                <Star className="w-4 h-4 fill-primary text-primary" />
                <span className="font-semibold">{cafe.userRating}</span>
                <span className="text-muted-foreground text-sm">Bean Scene</span>
              </div>
            )}
          </div>
          <div className="flex items-center gap-1">
            {renderPriceLevel(cafe.priceLevel)}
          </div>
        </div>

        {/* Top Tags */}
        <div className="flex flex-wrap gap-2">
          {cafe.topTags.map((tag) => (
            <Badge
              key={tag}
              variant="secondary"
              className="bg-primary/10 text-primary border-0"
            >
              #{tag}
            </Badge>
          ))}
        </div>

        {/* Review Snippet */}
        <div className="bg-muted/50 rounded-lg p-4 border-l-4 border-primary/30">
          <p className="text-sm italic text-muted-foreground">
            "{cafe.reviewSnippet}"
          </p>
        </div>

        {/* Action Buttons */}
        <div className="flex gap-3">
          <Button 
            variant="outline" 
            className="flex-1"
            onClick={handleShare}
          >
            <Share2 className="w-4 h-4 mr-2" />
            Share
          </Button>
          <Button className="flex-1 coffee-gradient text-white shadow-coffee hover:shadow-glow transition-smooth">
            Check In Here
          </Button>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/Cafe/CafePhotoUpload.tsx
================
import React, { useState, useRef } from 'react';
import { Camera, Upload, X, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { useToast } from '@/hooks/use-toast';
import { useNavigate } from 'react-router-dom';
import { uploadImage } from '@/services/cloudinaryService';

interface CafePhotoUploadProps {
  cafeId: string;
  placeId: string;
  cafeName: string;
  onPhotoAdded?: (photoUrl: string) => void;
}

export function CafePhotoUpload({ cafeId, placeId, cafeName, onPhotoAdded }: CafePhotoUploadProps) {
  const [isUploading, setIsUploading] = useState(false);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { toast } = useToast();
  const navigate = useNavigate();

  const handleUploadClick = () => {
    navigate(`/cafe/${placeId}/upload`);
  };

  return (
    <Card className="relative h-48 bg-gradient-to-br from-primary/20 via-primary/10 to-accent/20 border-2 border-dashed border-primary/30 hover:border-primary/50 transition-colors">
      <div 
        className="h-full flex flex-col items-center justify-center cursor-pointer hover:bg-primary/5 transition-colors rounded-lg"
        onClick={handleUploadClick}
      >
        <div className="flex flex-col items-center text-center p-6">
          <div className="w-12 h-12 rounded-full bg-primary/10 flex items-center justify-center mb-3">
            <Camera className="w-6 h-6 text-primary" />
          </div>
          <h3 className="font-medium text-foreground mb-1">Add a photo</h3>
          <p className="text-sm text-muted-foreground mb-3">
            Help others discover {cafeName}
          </p>
          <Button size="sm" variant="outline" className="gap-2">
            <Upload className="w-4 h-4" />
            Choose Photo
          </Button>
        </div>
      </div>
    </Card>
  );
}

================
File: src/components/Cafe/CafeReviews.tsx
================
import { useEffect, useState } from "react";
import { Star, User } from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { supabase } from "@/integrations/supabase/client";

interface Review {
  id: string;
  reviewer_name: string;
  rating: number;
  review_text: string;
  profile_photo_url?: string;
  time: string;
}

interface CafeReviewsProps {
  cafeId: string;
  maxReviews?: number;
}

export function CafeReviews({ cafeId, maxReviews = 5 }: CafeReviewsProps) {
  const [reviews, setReviews] = useState<Review[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchReviews() {
      try {
        setLoading(true);
        setError(null);

        const { data, error } = await supabase
          .from('cafe_reviews')
          .select('*')
          .eq('cafe_id', cafeId)
          .order('rating', { ascending: false })
          .order('time', { ascending: false })
          .limit(maxReviews);

        if (error) throw error;

        setReviews(data || []);
      } catch (err) {
        console.error('Error fetching reviews:', err);
        setError(err instanceof Error ? err.message : 'Failed to load reviews');
      } finally {
        setLoading(false);
      }
    }

    if (cafeId) {
      fetchReviews();
    }
  }, [cafeId, maxReviews]);

  if (loading) {
    return (
      <div className="space-y-4">
        {[1, 2, 3].map((i) => (
          <Card key={i} className="shadow-coffee border-0">
            <CardContent className="p-4">
              <div className="animate-pulse space-y-2">
                <div className="h-4 bg-muted rounded w-1/4"></div>
                <div className="h-3 bg-muted rounded w-full"></div>
                <div className="h-3 bg-muted rounded w-3/4"></div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    );
  }

  if (error) {
    return (
      <Card className="shadow-coffee border-0">
        <CardContent className="p-4 text-center">
          <p className="text-sm text-muted-foreground">Unable to load reviews</p>
        </CardContent>
      </Card>
    );
  }

  if (reviews.length === 0) {
    return (
      <Card className="shadow-coffee border-0">
        <CardContent className="p-4 text-center">
          <p className="text-sm text-muted-foreground">No reviews yet</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="space-y-4">
      {reviews.map((review) => (
        <Card key={review.id} className="shadow-coffee border-0">
          <CardContent className="p-4">
            {/* Reviewer Info */}
            <div className="flex items-start gap-3 mb-3">
              <Avatar className="w-10 h-10">
                {review.profile_photo_url ? (
                  <AvatarImage src={review.profile_photo_url} alt={review.reviewer_name} />
                ) : null}
                <AvatarFallback>
                  <User className="w-5 h-5" />
                </AvatarFallback>
              </Avatar>
              
              <div className="flex-1 min-w-0">
                <div className="flex items-center justify-between mb-1">
                  <h4 className="font-semibold text-sm truncate">{review.reviewer_name}</h4>
                  <div className="flex items-center gap-1 ml-2">
                    <Star className="w-4 h-4 fill-yellow-400 text-yellow-400" />
                    <span className="text-sm font-medium">{review.rating}</span>
                  </div>
                </div>
                
                <p className="text-xs text-muted-foreground">
                  {new Date(review.time).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                  })}
                </p>
              </div>
            </div>

            {/* Review Text */}
            <p className="text-sm text-foreground leading-relaxed">
              {review.review_text}
            </p>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}

================
File: src/components/Cafe/ParkingInfo.tsx
================
import { useState, useEffect } from 'react';
import { MapPin, DollarSign, Info } from 'lucide-react';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { getParkingInfo, getParkingStatus, type ParkingInfo } from '@/services/parkingService';

interface ParkingInfoProps {
  placeId: string;
  cafeName: string;
}

export function ParkingInfoComponent({ placeId, cafeName }: ParkingInfoProps) {
  const [parkingInfo, setParkingInfo] = useState<ParkingInfo | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadParkingInfo = async () => {
      try {
        setLoading(true);
        const result = await getParkingInfo(placeId);
        
        if (result.success && result.data) {
          setParkingInfo(result.data);
        } else {
          setError(result.error || 'Failed to load parking info');
        }
      } catch (err) {
        setError('Failed to load parking info');
      } finally {
        setLoading(false);
      }
    };

    loadParkingInfo();
  }, [placeId]);

  if (loading) {
    return (
      <Card className="p-4 bg-muted/30 border-0">
        <div className="flex items-center gap-2">
          <MapPin className="w-4 h-4 text-muted-foreground animate-pulse" />
          <span className="text-sm text-muted-foreground">Loading parking info...</span>
        </div>
      </Card>
    );
  }

  if (error || !parkingInfo) {
    return (
      <Card className="p-4 bg-muted/30 border-0">
        <div className="flex items-center gap-2">
          <MapPin className="w-4 h-4 text-muted-foreground" />
          <span className="text-sm text-muted-foreground">Parking info unavailable</span>
        </div>
      </Card>
    );
  }

  const status = getParkingStatus(parkingInfo);

  return (
    <Card className="p-4 bg-muted/30 border-0">
      <div className="flex items-start gap-3">
        <div className="flex-shrink-0">
          <span className="text-lg">{status.icon}</span>
        </div>
        
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2 mb-1">
            <h4 className="text-sm font-medium">Parking</h4>
            <Badge 
              variant="secondary" 
              className={`text-xs ${status.color} bg-transparent border-0 p-0`}
            >
              {status.status}
            </Badge>
          </div>
          
          <div className="space-y-1">
            <div className="flex items-center gap-2">
              <DollarSign className="w-3 h-3 text-muted-foreground" />
              <span className="text-sm text-muted-foreground">{parkingInfo.cost}</span>
            </div>
            
            {parkingInfo.notes && (
              <div className="flex items-start gap-2">
                <Info className="w-3 h-3 text-muted-foreground mt-0.5 flex-shrink-0" />
                <span className="text-xs text-muted-foreground">{parkingInfo.notes}</span>
              </div>
            )}
          </div>
        </div>
      </div>
    </Card>
  );
}

================
File: src/components/Cafe/WeatherWidget.tsx
================
import { useEffect, useState } from 'react';
import { Cloud, Droplets, Wind, Clock } from 'lucide-react';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { getHoustonWeather, getWeatherIcon, getWeatherColor, type WeatherData } from '@/services/weatherService';

function getDefaultUnit() {
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem('weatherUnit');
    if (stored === 'C' || stored === 'F') return stored;
    const locale = navigator.language || '';
    if (locale.startsWith('en-US')) return 'F';
  }
  return 'C';
}

export function WeatherWidget({ unit: propUnit }: { unit?: 'F' | 'C' }) {
  const [weather, setWeather] = useState<WeatherData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [unit, setUnit] = useState<'F' | 'C'>(propUnit || getDefaultUnit());

  useEffect(() => {
    if (propUnit) setUnit(propUnit);
  }, [propUnit]);

  useEffect(() => {
    const loadWeather = async () => {
      try {
        setLoading(true);
        const result = await getHoustonWeather();
        if (result.success && result.data) {
          setWeather(result.data);
        } else {
          setError(result.error || 'Failed to load weather');
        }
      } catch (err) {
        setError('Failed to load weather');
      } finally {
        setLoading(false);
      }
    };
    loadWeather();
  }, []);

  useEffect(() => {
    if (!propUnit) localStorage.setItem('weatherUnit', unit);
  }, [unit, propUnit]);

  const toggleUnit = () => setUnit(u => (u === 'F' ? 'C' : 'F'));

  function toCelsius(f: number) { return ((f - 32) * 5) / 9; }
  function toFahrenheit(c: number) { return (c * 9) / 5 + 32; }

  if (loading) {
    return (
      <Card className="p-4 bg-muted/30 border-0">
        <div className="flex items-center gap-2">
          <Cloud className="w-4 h-4 text-muted-foreground animate-pulse" />
          <span className="text-sm text-muted-foreground">Loading weather...</span>
        </div>
      </Card>
    );
  }

  if (error || !weather) {
    return (
      <Card className="p-4 bg-muted/30 border-0">
        <div className="flex items-center gap-2">
          <Cloud className="w-4 h-4 text-muted-foreground" />
          <span className="text-sm text-muted-foreground">Weather unavailable</span>
        </div>
      </Card>
    );
  }

  const weatherIcon = getWeatherIcon(weather.condition);
  const tempF = weather.temperature;
  const tempC = toCelsius(tempF);
  const displayTemp = unit === 'F' ? Math.round(tempF) : Math.round(tempC);
  const temperatureColor = getWeatherColor(unit === 'F' ? tempF : tempC);

  // Precipitation
  const precipitation = weather.precipitation;
  const precipitationDisplay =
    precipitation !== undefined && precipitation !== null
      ? `${precipitation}%`
      : 'No precipitation data';

  // 6-12h summary (use weather.summary if available)
  const summary = weather.summary || 'No summary available';

  return (
    <Card className="p-4 bg-muted/30 border-0">
      <div className="flex items-start gap-3">
        <div className="flex-shrink-0">
          <span className="text-2xl">{weatherIcon}</span>
        </div>
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2 mb-1">
            <h4 className="text-sm font-medium">Houston Weather</h4>
            <Badge variant="secondary" className="text-xs">
              <Clock className="w-3 h-3 mr-1" />
              Live
            </Badge>
            <button
              className="ml-2 px-2 py-0.5 rounded text-xs border border-border bg-background hover:bg-muted transition"
              onClick={toggleUnit}
              aria-label="Toggle temperature unit"
              type="button"
            >
              {unit === 'F' ? '¬∞F' : '¬∞C'}
            </button>
          </div>
          <div className="space-y-1">
            <div className="flex items-center gap-2">
              <span className={`text-lg font-semibold ${temperatureColor}`}>{displayTemp}¬∞{unit}</span>
              <span className="text-sm text-muted-foreground">{weather.condition}</span>
            </div>
            <div className="flex items-center gap-4 text-xs text-muted-foreground">
              <div className="flex items-center gap-1">
                <Droplets className="w-3 h-3" />
                <span>{precipitationDisplay}</span>
              </div>
              <div className="flex items-center gap-1">
                <Wind className="w-3 h-3" />
                <span>{weather.windSpeed} mph</span>
              </div>
              <div className="flex items-center gap-1">
                <span>Humidity:</span>
                <span>{weather.humidity}%</span>
              </div>
            </div>
            <div className="text-xs text-muted-foreground mt-1">
              <span>{summary}</span>
            </div>
          </div>
        </div>
      </div>
    </Card>
  );
}

================
File: src/components/Feed/FeedItemCard.tsx
================
import { useNavigate } from "react-router-dom";
import { MapPin, Star, Coffee } from "lucide-react";
import { FeedItem } from "@/services/types";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { PostCard } from "./PostCard";
import { getCafeEmoji } from "@/utils/emojiPlaceholders";

interface FeedItemCardProps {
  item: FeedItem;
  onTagClick?: (tag: string) => void;
}

export function FeedItemCard({ item, onTagClick }: FeedItemCardProps) {
  const navigate = useNavigate();

  // Render post items using existing PostCard
  if (item.type === "post" && item.post) {
    return (
      <PostCard 
        post={{
          id: item.post.id,
          cafeName: item.post.cafe?.name || 'Unknown Cafe',
          neighborhood: item.post.cafe?.neighborhood || 'Houston',
          imageUrl: item.post.imageUrl,
          tags: item.post.tags,
          rating: item.post.rating,
          textReview: item.post.textReview,
          createdAt: new Date(item.createdAt).toLocaleString(),
          likes: item.post.likes,
          comments: item.post.comments
        }} 
      />
    );
  }

  // Render cafe items
  if (item.type === "cafe" && item.cafe) {
    const cafe = item.cafe;
    const heroPhoto = cafe.photos?.[0];
    
    return (
      <Card className="shadow-warm border-0 overflow-hidden">
        <CardContent className="p-0">
          {/* Hero Photo */}
          <div className="relative h-48 bg-muted">
            {heroPhoto ? (
              <img
                src={heroPhoto}
                alt={cafe.name}
                className="w-full h-full object-cover"
              />
            ) : (
              <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-[#8b5a3c] to-[#6b4423] text-white text-6xl rounded-lg shadow-lg">
                {getCafeEmoji(cafe.id || cafe.placeId)}
              </div>
            )}
          </div>

          <div className="p-4">
          {/* Cafe Name - Clickable */}
          <button
            onClick={(e) => {
              e.stopPropagation();
              navigate(`/cafe/${cafe.placeId}`);
            }}
            className="text-xl font-bold hover:text-primary transition-smooth text-left w-full mb-2"
          >
            {cafe.name}
          </button>

            {/* Top Tags - Clickable */}
            <div className="flex flex-wrap gap-2 mb-3">
              {cafe.tags.slice(0, 3).map((tag) => (
                <Badge
                  key={tag}
                  variant="secondary"
                  className="cursor-pointer hover:bg-primary/20 transition-smooth bg-primary/10 text-primary border-0"
                  onClick={(e) => {
                    e.stopPropagation();
                    onTagClick?.(tag);
                  }}
                >
                  #{tag}
                </Badge>
              ))}
              {cafe.tags.length > 3 && (
                <Badge variant="secondary" className="bg-muted/50 text-muted-foreground border-0">
                  +{cafe.tags.length - 3}
                </Badge>
              )}
            </div>

            {/* Google Rating + Address */}
            <div className="flex items-center justify-between mb-4">
              <div className="flex items-center gap-2">
                {cafe.googleRating && (
                  <div className="flex items-center gap-1">
                    <Star className="w-4 h-4 text-yellow-500 fill-current" />
                    <span className="font-medium">{cafe.googleRating}</span>
                    <span className="text-xs text-muted-foreground">Google</span>
                  </div>
                )}
              </div>
              
              <div className="flex items-center gap-1 text-sm text-muted-foreground">
                <MapPin className="w-3 h-3" />
                <span>{cafe.neighborhood}</span>
              </div>
            </div>

            <div className="text-sm text-muted-foreground mb-4 line-clamp-2">
              {cafe.address}
            </div>

            {/* Check In Button */}
            <Button
              onClick={(e) => {
                e.stopPropagation();
                navigate(`/checkin?cafeId=${cafe.placeId}`);
              }}
              className="w-full coffee-gradient text-white shadow-coffee hover:shadow-glow transition-smooth"
            >
              Check in here
            </Button>
          </div>
        </CardContent>
      </Card>
    );
  }

  return null;
}

================
File: src/components/Feed/PostCard.tsx
================
import { useState } from "react";
import { Heart, MessageCircle, MapPin, Star } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { toast } from "@/hooks/use-toast";

interface PostCardProps {
  post: {
    id: string;
    cafeName: string;
    neighborhood: string;
    imageUrl: string;
    tags: string[];
    rating: number;
    textReview: string;
    createdAt: string;
    likes: number;
    comments: number;
    username?: string;
  };
  type?: 'check-in' | 'post';
}

export function PostCard({ post, type = 'post' }: PostCardProps) {
  const [liked, setLiked] = useState(false);
  const [likeCount, setLikeCount] = useState(post.likes);
  const [liking, setLiking] = useState(false);

  // Handle like functionality
  const handleLike = async () => {
    if (liking) return;
    
    setLiking(true);
    const newLiked = !liked;
    const newCount = newLiked ? likeCount + 1 : likeCount - 1;
    
    // Optimistic update
    setLiked(newLiked);
    setLikeCount(newCount);
    
    try {
      // Simulate API call delay
      await new Promise(resolve => setTimeout(resolve, 300));
      
      toast({
        title: newLiked ? "Liked!" : "Unliked",
        description: newLiked ? "Added to your favorites" : "Removed from favorites",
      });
    } catch (error) {
      // Revert on error
      setLiked(!newLiked);
      setLikeCount(liked ? likeCount + 1 : likeCount - 1);
      
      toast({
        title: "Error",
        description: "Failed to update like. Please try again.",
        variant: "destructive"
      });
    } finally {
      setLiking(false);
    }
  };

  // Handle disabled comments
  const handleComments = () => {
    toast({
      title: "Coming Soon",
      description: "Comments feature will be available soon!",
    });
  };

  return (
    <Card className="overflow-hidden shadow-coffee border-0 bg-card/80 backdrop-blur-sm">
      {/* Label */}
      <div className="px-4 pt-4">
        <span className={`inline-block text-xs font-bold rounded px-2 py-1 mb-2 ${type === 'check-in' ? 'bg-green-100 text-green-700' : 'bg-blue-100 text-blue-700'}`}>{type === 'check-in' ? 'Check-In' : 'Shared Photo'}</span>
      </div>
      {/* Header */}
      <div className="p-4 pb-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <MapPin className="w-4 h-4 text-primary" />
            <div>
              <h3 className="font-semibold text-sm">{post.cafeName}</h3>
              <p className="text-xs text-muted-foreground">{post.neighborhood}</p>
            </div>
          </div>
          <div className="flex items-center gap-1">
            <Star className="w-4 h-4 fill-yellow-400 text-yellow-400" />
            <span className="text-sm font-medium">{post.rating}</span>
          </div>
        </div>
      </div>

      {/* Image */}
      <div className="relative">
        <img
          src={post.imageUrl}
          alt={`${post.cafeName} post`}
          className="w-full h-64 object-cover"
        />
      </div>

      {/* Content */}
      <div className="p-4">
        {/* Tags */}
        <div className="flex flex-wrap gap-2 mb-3">
          {post.tags.map((tag) => (
            <Badge
              key={tag}
              variant="secondary"
              className="text-xs px-2 py-1 bg-accent/50 text-accent-foreground border-0"
            >
              #{tag}
            </Badge>
          ))}
        </div>

        {/* Review Text */}
        <p className="text-sm text-foreground mb-3 leading-relaxed">
          {post.textReview}
        </p>
        
        {/* Username */}
        {post.username && (
          <p className="text-xs text-muted-foreground mb-3">
            by @{post.username}
          </p>
        )}

        {/* Actions */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            {/* Functional Like Button */}
            <Button 
              variant="ghost" 
              size="sm" 
              className={`h-8 px-2 transition-smooth ${liked ? 'text-red-500' : ''}`}
              onClick={handleLike}
              disabled={liking}
            >
              <Heart className={`w-4 h-4 mr-1 transition-smooth ${liked ? 'fill-current' : ''} ${liking ? 'scale-110' : ''}`} />
              <span className="text-sm">{likeCount}</span>
            </Button>
            
            {/* Disabled Comments Button */}
            <Button 
              variant="ghost" 
              size="sm" 
              className="h-8 px-2 opacity-50 cursor-not-allowed"
              onClick={handleComments}
            >
              <MessageCircle className="w-4 h-4 mr-1" />
              <span className="text-sm">{post.comments}</span>
            </Button>
          </div>
          <span className="text-xs text-muted-foreground">{post.createdAt}</span>
        </div>
      </div>
    </Card>
  );
}

================
File: src/components/Filters/ExploreFilters.tsx
================
import { useState } from "react";
import { Filter, X, DollarSign, Star, Clock, MapPin, Navigation } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent } from "@/components/ui/card";
import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetDescription, SheetTrigger } from "@/components/ui/sheet";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { HOUSTON_NEIGHBORHOODS } from "@/services/types";

export interface FilterState {
  priceLevel: number[];
  rating: number;
  distance: number;
  openNow: boolean;
  neighborhoods: string[];
}

interface ExploreFiltersProps {
  filters: FilterState;
  onFiltersChange: (filters: FilterState) => void;
  onClearFilters: () => void;
  isOpen?: boolean;
  onOpenChange?: (open: boolean) => void;
  userLocation?: { latitude: number; longitude: number } | null;
  onRequestLocation?: () => void;
  isRequestingLocation?: boolean;
}

export function ExploreFilters({ 
  filters, 
  onFiltersChange, 
  onClearFilters,
  isOpen: externalIsOpen,
  onOpenChange: externalOnOpenChange,
  userLocation,
  onRequestLocation,
  isRequestingLocation = false
}: ExploreFiltersProps) {
  const [internalIsOpen, setInternalIsOpen] = useState(false);
  const isOpen = externalIsOpen !== undefined ? externalIsOpen : internalIsOpen;
  const setIsOpen = externalOnOpenChange || setInternalIsOpen;

  const hasActiveFilters = 
    filters.priceLevel.length > 0 ||
    filters.rating > 0 ||
    filters.distance < 25 ||
    filters.openNow ||
    filters.neighborhoods.length > 0;

  const activeFilterCount = 
    (filters.priceLevel.length > 0 ? 1 : 0) +
    (filters.rating > 0 ? 1 : 0) +
    (filters.distance < 25 ? 1 : 0) +
    (filters.openNow ? 1 : 0) +
    (filters.neighborhoods.length > 0 ? 1 : 0);

  const renderPriceLevel = (level: number, isSelected: boolean) => {
    return Array.from({ length: 4 }, (_, i) => (
      <DollarSign
        key={i}
        className={`w-3 h-3 ${
          i < level
            ? isSelected 
              ? "text-primary fill-primary" 
              : "text-foreground fill-foreground"
            : "text-muted-foreground"
        }`}
      />
    ));
  };

  const togglePriceLevel = (level: number) => {
    const newPriceLevels = filters.priceLevel.includes(level)
      ? filters.priceLevel.filter(p => p !== level)
      : [...filters.priceLevel, level];
    onFiltersChange({ ...filters, priceLevel: newPriceLevels });
  };

  return (
    <>
      <Sheet open={isOpen} onOpenChange={setIsOpen}>
      <SheetContent side="right" className="w-full sm:max-w-lg bg-gradient-to-b from-[#faf8f5] to-[#f5efe8] flex flex-col">
          <SheetHeader className="pb-4 border-b border-[#d9cdb8] flex-shrink-0">
            <SheetTitle className="flex items-center justify-between text-[#4a3728] text-lg">
              <div className="flex items-center gap-2">
                <Filter className="w-4 h-4 text-[#8b5a3c]" />
                <span>Filter & Sort</span>
              </div>
              {hasActiveFilters && (
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={onClearFilters}
                  className="text-[#8b5a3c] hover:bg-[#d9cdb8]/50 text-sm"
                >
                  Clear All
                </Button>
              )}
            </SheetTitle>
            <SheetDescription className="text-[#8b5a3c] text-sm">
              Filter cafes by distance, price, rating, and more.
            </SheetDescription>
          </SheetHeader>

          <div className="flex-1 pt-3">
            <div className="space-y-4 pb-4">

            {/* Distance Filter */}
            <div className="bg-white/60 rounded-lg p-3 border border-[#d9cdb8]/50">
              <Label className="text-sm font-semibold mb-2 block text-[#4a3728] flex items-center gap-2">
                <MapPin className="w-3 h-3 text-[#8b5a3c]" />
                Distance: {filters.distance < 25 ? `${filters.distance} mi` : "All"}
              </Label>
              
              {!userLocation ? (
                <div className="text-center py-2">
                  <Button
                    onClick={onRequestLocation}
                    disabled={isRequestingLocation}
                    className="bg-[#8b5a3c] hover:bg-[#6b4423] text-white text-xs px-3 py-1.5 h-auto"
                  >
                    {isRequestingLocation ? (
                      <>
                        <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-white mr-1"></div>
                        Getting Location...
                      </>
                    ) : (
                      <>
                        <Navigation className="w-3 h-3 mr-1" />
                        Enable Location
                      </>
                    )}
                  </Button>
                </div>
              ) : (
                <>
                  <div className="px-2">
                    <Slider
                      value={[filters.distance]}
                      onValueChange={([value]) => onFiltersChange({ ...filters, distance: value })}
                      max={25}
                      min={1}
                      step={1}
                      className="w-full"
                    />
                  </div>
                  <div className="flex justify-between text-xs text-[#8b5a3c] mt-1 font-medium">
                    <span>1 mi</span>
                    <span>All</span>
                  </div>
                </>
              )}
            </div>

            {/* Price Level */}
            <div className="bg-white/60 rounded-lg p-3 border border-[#d9cdb8]/50">
              <Label className="text-sm font-semibold mb-2 block text-[#4a3728] flex items-center gap-2">
                <DollarSign className="w-3 h-3 text-[#8b5a3c]" />
                Price Level
              </Label>
              <div className="flex gap-1.5">
                {[1, 2, 3, 4].map((level) => (
                  <Button
                    key={level}
                    variant={filters.priceLevel.includes(level) ? "default" : "outline"}
                    size="sm"
                    onClick={() => togglePriceLevel(level)}
                    className={`flex items-center gap-1 h-8 text-xs ${
                      filters.priceLevel.includes(level) 
                        ? "bg-[#8b5a3c] hover:bg-[#6b4423] text-white" 
                        : "bg-white border-[#d9cdb8] hover:bg-[#f5efe8] hover:border-[#8b5a3c] text-[#4a3728]"
                    }`}
                  >
                    {renderPriceLevel(level, filters.priceLevel.includes(level))}
                  </Button>
                ))}
              </div>
            </div>

            {/* Rating */}
            <div className="bg-white/60 rounded-lg p-3 border border-[#d9cdb8]/50">
              <Label className="text-sm font-semibold mb-2 block text-[#4a3728] flex items-center gap-2">
                <Star className="w-3 h-3 text-[#8b5a3c]" />
                Rating: {filters.rating > 0 ? filters.rating.toFixed(1) : "Any"}
              </Label>
              <div className="px-2">
                <Slider
                  value={[filters.rating]}
                  onValueChange={([value]) => onFiltersChange({ ...filters, rating: value })}
                  max={5}
                  min={0}
                  step={0.1}
                  className="w-full"
                />
              </div>
              <div className="flex justify-between text-xs text-[#8b5a3c] mt-1 font-medium">
                <span>Any</span>
                <span>5.0 ‚≠ê</span>
              </div>
            </div>

            {/* Open Now */}
            <div className="bg-white/60 rounded-lg p-3 border border-[#d9cdb8]/50">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Clock className="w-3 h-3 text-[#8b5a3c]" />
                  <Label htmlFor="open-now" className="text-sm font-semibold text-[#4a3728]">Open Now</Label>
                </div>
                <Switch
                  id="open-now"
                  checked={filters.openNow}
                  onCheckedChange={(checked) => onFiltersChange({ ...filters, openNow: checked })}
                />
              </div>
            </div>
            </div>
          </div>

          {/* Apply Filters Button - Fixed at bottom */}
          <div className="mt-4 pt-3 border-t border-[#d9cdb8] flex-shrink-0">
            <Button
              onClick={() => setIsOpen(false)}
              className="w-full bg-gradient-to-r from-[#8b5a3c] to-[#6b4423] hover:from-[#6b4423] hover:to-[#4a3728] text-white font-semibold py-2 rounded-lg shadow-lg text-sm"
            >
              ‚ú® Apply Filters
            </Button>
          </div>
        </SheetContent>
      </Sheet>

      {/* Active Filter Pills */}
      {hasActiveFilters && (
        <div className="flex flex-wrap gap-2 mt-3">
          {filters.priceLevel.map((level) => (
            <Badge
              key={`price-${level}`}
              className="flex items-center gap-1 text-xs bg-[#8b5a3c] text-white hover:bg-[#6b4423]"
            >
              {renderPriceLevel(level, true)}
              <Button
                variant="ghost"
                size="sm"
                className="h-4 w-4 p-0 hover:bg-transparent"
                onClick={() => togglePriceLevel(level)}
              >
                <X className="h-3 w-3" />
              </Button>
            </Badge>
          ))}
          
          {filters.rating > 0 && (
            <Badge className="flex items-center gap-1 text-xs bg-[#8b5a3c] text-white hover:bg-[#6b4423]">
              <Star className="w-3 h-3" />
              {filters.rating.toFixed(1)}+
              <Button
                variant="ghost"
                size="sm"
                className="h-4 w-4 p-0 hover:bg-transparent"
                onClick={() => onFiltersChange({ ...filters, rating: 0 })}
              >
                <X className="h-3 w-3" />
              </Button>
            </Badge>
          )}
          
          {filters.distance < 25 && (
            <Badge className="flex items-center gap-1 text-xs bg-[#8b5a3c] text-white hover:bg-[#6b4423]">
              <MapPin className="w-3 h-3" />
              {filters.distance} mi
              <Button
                variant="ghost"
                size="sm"
                className="h-4 w-4 p-0 hover:bg-transparent"
                onClick={() => onFiltersChange({ ...filters, distance: 25 })}
              >
                <X className="h-3 w-3" />
              </Button>
            </Badge>
          )}


          
          {filters.openNow && (
            <Badge className="flex items-center gap-1 text-xs bg-[#8b5a3c] text-white hover:bg-[#6b4423]">
              <Clock className="w-3 h-3" />
              Open Now
              <Button
                variant="ghost"
                size="sm"
                className="h-4 w-4 p-0 hover:bg-transparent"
                onClick={() => onFiltersChange({ ...filters, openNow: false })}
              >
                <X className="h-3 w-3" />
              </Button>
            </Badge>
          )}
        </div>
      )}
    </>
  );
}

================
File: src/components/Filters/RadiusFilter.tsx
================
import { useState } from 'react';
import { MapPin, Navigation } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Slider } from '@/components/ui/slider';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';

interface RadiusFilterProps {
  radius: number;
  onRadiusChange: (radius: number) => void;
  userLocation?: { lat: number; lng: number } | null;
  onRequestLocation: () => void;
  locationError?: string;
}

export function RadiusFilter({ 
  radius, 
  onRadiusChange, 
  userLocation, 
  onRequestLocation,
  locationError 
}: RadiusFilterProps) {
  const [isExpanded, setIsExpanded] = useState(false);

  const radiusOptions = [
    { value: 1, label: '1 mile', color: 'bg-green-500' },
    { value: 3, label: '3 miles', color: 'bg-yellow-500' },
    { value: 5, label: '5 miles', color: 'bg-orange-500' },
    { value: 10, label: '10 miles', color: 'bg-red-500' },
    { value: 25, label: 'Show All', color: 'bg-gray-500' }
  ];

  const getCurrentRadiusOption = () => {
    return radiusOptions.find(option => option.value === radius) || radiusOptions[4];
  };

  const currentOption = getCurrentRadiusOption();

  if (!userLocation) {
    return (
      <Card className="p-4 bg-muted/30 border-0">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Navigation className="w-4 h-4 text-muted-foreground" />
            <span className="text-sm font-medium">Near Me</span>
          </div>
          <Button
            variant="outline"
            size="sm"
            onClick={onRequestLocation}
            className="text-xs"
          >
            Enable Location
          </Button>
        </div>
        {locationError && (
          <p className="text-xs text-muted-foreground mt-2">{locationError}</p>
        )}
      </Card>
    );
  }

  return (
    <Card className="p-4 bg-muted/30 border-0">
      <div className="space-y-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <MapPin className="w-4 h-4 text-muted-foreground" />
            <span className="text-sm font-medium">Search Radius</span>
          </div>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setIsExpanded(!isExpanded)}
            className="text-xs"
          >
            {isExpanded ? 'Collapse' : 'Customize'}
          </Button>
        </div>

        {/* Quick Radius Options */}
        <div className="flex gap-2 flex-wrap">
          {radiusOptions.map((option) => (
            <Button
              key={option.value}
              variant={radius === option.value ? "default" : "outline"}
              size="sm"
              onClick={() => onRadiusChange(option.value)}
              className="text-xs h-8"
            >
              <div className={`w-2 h-2 rounded-full ${option.color} mr-1`} />
              {option.label}
            </Button>
          ))}
        </div>

        {/* Current Selection */}
        <div className="flex items-center gap-2">
          <Badge variant="secondary" className="text-xs">
            <div className={`w-2 h-2 rounded-full ${currentOption.color} mr-1`} />
            {currentOption.label}
          </Badge>
          <span className="text-xs text-muted-foreground">
            {radius < 25 ? `Within ${radius} mile${radius > 1 ? 's' : ''}` : 'All Houston cafes'}
          </span>
        </div>

        {/* Expanded Custom Slider */}
        {isExpanded && (
          <div className="pt-3 border-t border-border">
            <Label className="text-sm font-medium mb-3 block">
              Custom Radius: {radius} mile{radius > 1 ? 's' : ''}
            </Label>
            <div className="px-3">
              <Slider
                value={[radius]}
                onValueChange={([value]) => onRadiusChange(value)}
                max={25}
                min={1}
                step={1}
                className="w-full"
              />
            </div>
            <div className="flex justify-between text-xs text-muted-foreground mt-1">
              <span>1 mi</span>
              <span>25 mi</span>
            </div>
          </div>
        )}
      </div>
    </Card>
  );
}

================
File: src/components/Layout/AppLayout.tsx
================
import { ReactNode } from "react";
import { BottomNav } from "./BottomNav";
import { GlobalWeatherBar } from "./GlobalWeatherBar";

interface AppLayoutProps {
  children: ReactNode;
  showBottomNav?: boolean;
  showWeather?: boolean;
}

export function AppLayout({ children, showBottomNav = true, showWeather = true }: AppLayoutProps) {
  return (
    <div className="min-h-screen bg-background">
      {showWeather && <GlobalWeatherBar />}
      <main className={cn("w-full", showBottomNav && "pb-16")}>
        {children}
      </main>
      {showBottomNav && <BottomNav />}
    </div>
  );
}

function cn(...classes: string[]) {
  return classes.filter(Boolean).join(" ");
}

================
File: src/components/Layout/BottomNav.tsx
================
import { Home, Search, Plus, Heart, User } from "lucide-react";
import { NavLink } from "react-router-dom";
import { cn } from "@/lib/utils";

const navItems = [
  { icon: Home, label: "Origins", href: "/home" },
  { icon: Search, label: "Explore", href: "/explore" },
  { icon: Plus, label: "Share", href: "/share" },
  { icon: Heart, label: "Moments", href: "/moments" },
  { icon: User, label: "Profile", href: "/profile" },
];

export function BottomNav() {
  return (
    <nav className="fixed bottom-0 left-0 right-0 z-50 coffee-bottom-nav">
      <div className="flex items-center justify-around h-16 max-w-md mx-auto px-4">
        {navItems.map(({ icon: Icon, label, href }) => (
          <NavLink
            key={href}
            to={href}
            className={({ isActive }) =>
              cn(
                "flex flex-col items-center gap-1 p-2 rounded-lg transition-smooth min-w-0 coffee-nav-item",
                isActive
                  ? "coffee-nav-active bg-primary/10"
                  : "coffee-nav-inactive hover:bg-muted/50"
              )
            }
          >
            <Icon className="w-5 h-5 flex-shrink-0" />
            <span className="text-xs leading-tight text-center">{label}</span>
          </NavLink>
        ))}
      </div>
    </nav>
  );
}

================
File: src/components/Layout/GlobalWeatherBar.tsx
================
import { useEffect, useState } from "react";
import { Cloud } from "lucide-react";
import { getHoustonWeather, type WeatherData } from "@/services/weatherService";

export function GlobalWeatherBar() {
  const [weather, setWeather] = useState<WeatherData | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchWeather() {
      setLoading(true);
      const result = await getHoustonWeather();
      if (result.success) {
        setWeather(result.data);
      }
      setLoading(false);
    }
    fetchWeather();
  }, []);

  if (loading || !weather) {
    return null;
  }

  return (
    <div className="sticky top-0 z-40 bg-primary/10 backdrop-blur-md border-b border-primary/20">
      <div className="max-w-md mx-auto px-4 py-2 flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Cloud className="w-4 h-4 text-primary" />
          <span className="text-sm font-medium">Houston</span>
        </div>
        <div className="flex items-center gap-3">
          <span className="text-sm">{weather.icon}</span>
          <span className="text-sm font-semibold">{Math.round(weather.temperature)}¬∞F</span>
          <span className="text-sm text-muted-foreground">{weather.condition}</span>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/Onboarding.tsx
================
import React, { useState, useEffect } from 'react';
import { MapPin, Sparkles, Coffee, ChevronRight } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';

const onboardingSteps = [
  {
    icon: MapPin,
    title: "Discover Caf√©s Near You",
    description: "Find the best spots around you, cozy corners, local gems, and new favorites.",
    insight: "Your coffee runs could spark unexpected connections.",
    emoji: "üìç"
  },
  {
    icon: Sparkles,
    title: "Choose Your Vibe",
    description: "Cozy, laptop-friendly, or lively, pick the space that fits your mood.",
    insight: "Every vibe is an opportunity to focus, relax, or meet someone new.",
    emoji: "‚ú®"
  },
  {
    icon: Coffee,
    title: "More Than Coffee",
    description: "Turn your everyday coffee into something more, catch-ups, co-working, or a friendly hello.",
    insight: "We're creating a culture where real-life interactions happen naturally, one caf√© at a time.",
    emoji: "‚òï"
  }
];

export default function Onboarding({ onComplete }) {
  const [currentStep, setCurrentStep] = useState(0);
  const [touchStart, setTouchStart] = useState(0);
  const [touchEnd, setTouchEnd] = useState(0);

  const handleNext = () => {
    if (currentStep < onboardingSteps.length - 1) {
      setCurrentStep(currentStep + 1);
    } else {
      onComplete?.();
    }
  };

  const handleTouchStart = (e) => {
    setTouchStart(e.targetTouches[0].clientX);
  };

  const handleTouchMove = (e) => {
    setTouchEnd(e.targetTouches[0].clientX);
  };

  const handleTouchEnd = () => {
    if (touchStart - touchEnd > 75) {
      handleNext();
    }
    if (touchStart - touchEnd < -75 && currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };

  const currentCard = onboardingSteps[currentStep];
  const Icon = currentCard.icon;
  const isLastStep = currentStep === onboardingSteps.length - 1;

  return (
    <div className="fixed inset-0 z-50 bg-background flex items-center justify-center">
      <div className="w-full h-full max-w-md mx-auto flex flex-col justify-center p-8">
        <div 
          className="flex flex-col space-y-8"
          onTouchStart={handleTouchStart}
          onTouchMove={handleTouchMove}
          onTouchEnd={handleTouchEnd}
        >
          {/* Icon */}
          <div className="flex justify-center">
            <div className="w-20 h-20 rounded-full bg-primary/10 flex items-center justify-center">
              <Icon className="w-10 h-10 text-primary" strokeWidth={1.5} />
            </div>
          </div>

          {/* Content */}
          <div className="text-center space-y-6">
            <h2 className="text-3xl font-bold leading-tight">
              {currentCard.title}
            </h2>
            
            <p className="text-lg text-muted-foreground leading-relaxed">
              {currentCard.description}
            </p>

            <div className="pt-2 pb-2">
              <p className="text-sm text-muted-foreground/80 leading-relaxed italic">
                üí° {currentCard.insight}
              </p>
            </div>
          </div>

          {/* Progress Dots */}
          <div className="flex justify-center gap-2">
            {onboardingSteps.map((_, index) => (
              <button
                key={index}
                onClick={() => setCurrentStep(index)}
                className={`h-2 rounded-full transition-all ${
                  index === currentStep 
                    ? 'w-8 bg-primary' 
                    : 'w-2 bg-muted'
                }`}
                aria-label={`Go to step ${index + 1}`}
              />
            ))}
          </div>

          {/* CTA */}
          <div className="space-y-3">
            <Button 
              size="lg" 
              className="w-full"
              onClick={handleNext}
            >
              {isLastStep ? (
                <>Start Exploring ‚Üí</>
              ) : (
                <>
                  Next
                  <ChevronRight className="ml-2 w-5 h-5" />
                </>
              )}
            </Button>

            {!isLastStep && (
              <button
                onClick={onComplete}
                className="w-full text-sm text-muted-foreground hover:text-foreground transition-colors"
              >
                Skip
              </button>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/ui/accordion.tsx
================
import * as React from "react";
import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDown } from "lucide-react";

import { cn } from "@/lib/utils";

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item ref={ref} className={cn("border-b", className)} {...props} />
));
AccordionItem.displayName = "AccordionItem";

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
));

AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };

================
File: src/components/ui/alert-dialog.tsx
================
import * as React from "react";
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

const AlertDialog = AlertDialogPrimitive.Root;

const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-2 text-center sm:text-left", className)} {...props} />
);
AlertDialogHeader.displayName = "AlertDialogHeader";

const AlertDialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
);
AlertDialogFooter.displayName = "AlertDialogFooter";

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title ref={ref} className={cn("text-lg font-semibold", className)} {...props} />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
AlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action ref={ref} className={cn(buttonVariants(), className)} {...props} />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(buttonVariants({ variant: "outline" }), "mt-2 sm:mt-0", className)}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};

================
File: src/components/ui/alert.tsx
================
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div ref={ref} role="alert" className={cn(alertVariants({ variant }), className)} {...props} />
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h5 ref={ref} className={cn("mb-1 font-medium leading-none tracking-tight", className)} {...props} />
  ),
);
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("text-sm [&_p]:leading-relaxed", className)} {...props} />
  ),
);
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };

================
File: src/components/ui/aspect-ratio.tsx
================
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio";

const AspectRatio = AspectRatioPrimitive.Root;

export { AspectRatio };

================
File: src/components/ui/avatar.tsx
================
import * as React from "react";
import * as AvatarPrimitive from "@radix-ui/react-avatar";

import { cn } from "@/lib/utils";

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn("relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full", className)}
    {...props}
  />
));
Avatar.displayName = AvatarPrimitive.Root.displayName;

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image ref={ref} className={cn("aspect-square h-full w-full", className)} {...props} />
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn("flex h-full w-full items-center justify-center rounded-full bg-muted", className)}
    {...props}
  />
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;

export { Avatar, AvatarImage, AvatarFallback };

================
File: src/components/ui/badge.tsx
================
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return <div className={cn(badgeVariants({ variant }), className)} {...props} />;
}

export { Badge, badgeVariants };

================
File: src/components/ui/breadcrumb.tsx
================
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { ChevronRight, MoreHorizontal } from "lucide-react";

import { cn } from "@/lib/utils";

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode;
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />);
Breadcrumb.displayName = "Breadcrumb";

const BreadcrumbList = React.forwardRef<HTMLOListElement, React.ComponentPropsWithoutRef<"ol">>(
  ({ className, ...props }, ref) => (
    <ol
      ref={ref}
      className={cn(
        "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
        className,
      )}
      {...props}
    />
  ),
);
BreadcrumbList.displayName = "BreadcrumbList";

const BreadcrumbItem = React.forwardRef<HTMLLIElement, React.ComponentPropsWithoutRef<"li">>(
  ({ className, ...props }, ref) => (
    <li ref={ref} className={cn("inline-flex items-center gap-1.5", className)} {...props} />
  ),
);
BreadcrumbItem.displayName = "BreadcrumbItem";

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean;
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a";

  return <Comp ref={ref} className={cn("transition-colors hover:text-foreground", className)} {...props} />;
});
BreadcrumbLink.displayName = "BreadcrumbLink";

const BreadcrumbPage = React.forwardRef<HTMLSpanElement, React.ComponentPropsWithoutRef<"span">>(
  ({ className, ...props }, ref) => (
    <span
      ref={ref}
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("font-normal text-foreground", className)}
      {...props}
    />
  ),
);
BreadcrumbPage.displayName = "BreadcrumbPage";

const BreadcrumbSeparator = ({ children, className, ...props }: React.ComponentProps<"li">) => (
  <li role="presentation" aria-hidden="true" className={cn("[&>svg]:size-3.5", className)} {...props}>
    {children ?? <ChevronRight />}
  </li>
);
BreadcrumbSeparator.displayName = "BreadcrumbSeparator";

const BreadcrumbEllipsis = ({ className, ...props }: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
);
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis";

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
};

================
File: src/components/ui/button.tsx
================
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-smooth focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90 shadow-coffee hover:shadow-warm",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        // Coffee-themed variants using design system
        coffee: "coffee-gradient text-white shadow-coffee hover:shadow-glow transition-smooth",
        cream: "cream-gradient text-foreground shadow-warm hover:shadow-coffee transition-smooth",
        warm: "warm-gradient text-accent-foreground shadow-coffee hover:shadow-warm transition-smooth",
        glass: "glass-effect text-white hover:bg-white/20 border border-white/30",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />;
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };

================
File: src/components/ui/calendar.tsx
================
import * as React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { DayPicker } from "react-day-picker";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({ className, classNames, showOutsideDays = true, ...props }: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell: "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(buttonVariants({ variant: "ghost" }), "h-9 w-9 p-0 font-normal aria-selected:opacity-100"),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ..._props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ..._props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  );
}
Calendar.displayName = "Calendar";

export { Calendar };

================
File: src/components/ui/card.tsx
================
import * as React from "react";

import { cn } from "@/lib/utils";

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("rounded-lg border bg-card text-card-foreground shadow-sm", className)} {...props} />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("flex flex-col space-y-1.5 p-6", className)} {...props} />
  ),
);
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h3 ref={ref} className={cn("text-2xl font-semibold leading-none tracking-tight", className)} {...props} />
  ),
);
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <p ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
  ),
);
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />,
);
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("flex items-center p-6 pt-0", className)} {...props} />
  ),
);
CardFooter.displayName = "CardFooter";

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };

================
File: src/components/ui/carousel.tsx
================
import * as React from "react";
import useEmblaCarousel, { type UseEmblaCarouselType } from "embla-carousel-react";
import { ArrowLeft, ArrowRight } from "lucide-react";

import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";

type CarouselApi = UseEmblaCarouselType[1];
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>;
type CarouselOptions = UseCarouselParameters[0];
type CarouselPlugin = UseCarouselParameters[1];

type CarouselProps = {
  opts?: CarouselOptions;
  plugins?: CarouselPlugin;
  orientation?: "horizontal" | "vertical";
  setApi?: (api: CarouselApi) => void;
};

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0];
  api: ReturnType<typeof useEmblaCarousel>[1];
  scrollPrev: () => void;
  scrollNext: () => void;
  canScrollPrev: boolean;
  canScrollNext: boolean;
} & CarouselProps;

const CarouselContext = React.createContext<CarouselContextProps | null>(null);

function useCarousel() {
  const context = React.useContext(CarouselContext);

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />");
  }

  return context;
}

const Carousel = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement> & CarouselProps>(
  ({ orientation = "horizontal", opts, setApi, plugins, className, children, ...props }, ref) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins,
    );
    const [canScrollPrev, setCanScrollPrev] = React.useState(false);
    const [canScrollNext, setCanScrollNext] = React.useState(false);

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return;
      }

      setCanScrollPrev(api.canScrollPrev());
      setCanScrollNext(api.canScrollNext());
    }, []);

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev();
    }, [api]);

    const scrollNext = React.useCallback(() => {
      api?.scrollNext();
    }, [api]);

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          scrollPrev();
        } else if (event.key === "ArrowRight") {
          event.preventDefault();
          scrollNext();
        }
      },
      [scrollPrev, scrollNext],
    );

    React.useEffect(() => {
      if (!api || !setApi) {
        return;
      }

      setApi(api);
    }, [api, setApi]);

    React.useEffect(() => {
      if (!api) {
        return;
      }

      onSelect(api);
      api.on("reInit", onSelect);
      api.on("select", onSelect);

      return () => {
        api?.off("select", onSelect);
      };
    }, [api, onSelect]);

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation: orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    );
  },
);
Carousel.displayName = "Carousel";

const CarouselContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const { carouselRef, orientation } = useCarousel();

    return (
      <div ref={carouselRef} className="overflow-hidden">
        <div
          ref={ref}
          className={cn("flex", orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col", className)}
          {...props}
        />
      </div>
    );
  },
);
CarouselContent.displayName = "CarouselContent";

const CarouselItem = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const { orientation } = useCarousel();

    return (
      <div
        ref={ref}
        role="group"
        aria-roledescription="slide"
        className={cn("min-w-0 shrink-0 grow-0 basis-full", orientation === "horizontal" ? "pl-4" : "pt-4", className)}
        {...props}
      />
    );
  },
);
CarouselItem.displayName = "CarouselItem";

const CarouselPrevious = React.forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(
  ({ className, variant = "outline", size = "icon", ...props }, ref) => {
    const { orientation, scrollPrev, canScrollPrev } = useCarousel();

    return (
      <Button
        ref={ref}
        variant={variant}
        size={size}
        className={cn(
          "absolute h-8 w-8 rounded-full",
          orientation === "horizontal"
            ? "-left-12 top-1/2 -translate-y-1/2"
            : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
          className,
        )}
        disabled={!canScrollPrev}
        onClick={scrollPrev}
        {...props}
      >
        <ArrowLeft className="h-4 w-4" />
        <span className="sr-only">Previous slide</span>
      </Button>
    );
  },
);
CarouselPrevious.displayName = "CarouselPrevious";

const CarouselNext = React.forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(
  ({ className, variant = "outline", size = "icon", ...props }, ref) => {
    const { orientation, scrollNext, canScrollNext } = useCarousel();

    return (
      <Button
        ref={ref}
        variant={variant}
        size={size}
        className={cn(
          "absolute h-8 w-8 rounded-full",
          orientation === "horizontal"
            ? "-right-12 top-1/2 -translate-y-1/2"
            : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
          className,
        )}
        disabled={!canScrollNext}
        onClick={scrollNext}
        {...props}
      >
        <ArrowRight className="h-4 w-4" />
        <span className="sr-only">Next slide</span>
      </Button>
    );
  },
);
CarouselNext.displayName = "CarouselNext";

export { type CarouselApi, Carousel, CarouselContent, CarouselItem, CarouselPrevious, CarouselNext };

================
File: src/components/ui/chart.tsx
================
import * as React from "react";
import * as RechartsPrimitive from "recharts";

import { cn } from "@/lib/utils";

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const;

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode;
    icon?: React.ComponentType;
  } & ({ color?: string; theme?: never } | { color?: never; theme: Record<keyof typeof THEMES, string> });
};

type ChartContextProps = {
  config: ChartConfig;
};

const ChartContext = React.createContext<ChartContextProps | null>(null);

function useChart() {
  const context = React.useContext(ChartContext);

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />");
  }

  return context;
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig;
    children: React.ComponentProps<typeof RechartsPrimitive.ResponsiveContainer>["children"];
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId();
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`;

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className,
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>{children}</RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  );
});
ChartContainer.displayName = "Chart";

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(([_, config]) => config.theme || config.color);

  if (!colorConfig.length) {
    return null;
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color = itemConfig.theme?.[theme as keyof typeof itemConfig.theme] || itemConfig.color;
    return color ? `  --color-${key}: ${color};` : null;
  })
  .join("\n")}
}
`,
          )
          .join("\n"),
      }}
    />
  );
};

const ChartTooltip = RechartsPrimitive.Tooltip;

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean;
      hideIndicator?: boolean;
      indicator?: "line" | "dot" | "dashed";
      nameKey?: string;
      labelKey?: string;
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref,
  ) => {
    const { config } = useChart();

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null;
      }

      const [item] = payload;
      const key = `${labelKey || item.dataKey || item.name || "value"}`;
      const itemConfig = getPayloadConfigFromPayload(config, item, key);
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label;

      if (labelFormatter) {
        return <div className={cn("font-medium", labelClassName)}>{labelFormatter(value, payload)}</div>;
      }

      if (!value) {
        return null;
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>;
    }, [label, labelFormatter, payload, hideLabel, labelClassName, config, labelKey]);

    if (!active || !payload?.length) {
      return null;
    }

    const nestLabel = payload.length === 1 && indicator !== "dot";

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className,
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`;
            const itemConfig = getPayloadConfigFromPayload(config, item, key);
            const indicatorColor = color || item.payload.fill || item.color;

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center",
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn("shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]", {
                            "h-2.5 w-2.5": indicator === "dot",
                            "w-1": indicator === "line",
                            "w-0 border-[1.5px] border-dashed bg-transparent": indicator === "dashed",
                            "my-0.5": nestLabel && indicator === "dashed",
                          })}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center",
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">{itemConfig?.label || item.name}</span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            );
          })}
        </div>
      </div>
    );
  },
);
ChartTooltipContent.displayName = "ChartTooltip";

const ChartLegend = RechartsPrimitive.Legend;

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean;
      nameKey?: string;
    }
>(({ className, hideIcon = false, payload, verticalAlign = "bottom", nameKey }, ref) => {
  const { config } = useChart();

  if (!payload?.length) {
    return null;
  }

  return (
    <div
      ref={ref}
      className={cn("flex items-center justify-center gap-4", verticalAlign === "top" ? "pb-3" : "pt-3", className)}
    >
      {payload.map((item) => {
        const key = `${nameKey || item.dataKey || "value"}`;
        const itemConfig = getPayloadConfigFromPayload(config, item, key);

        return (
          <div
            key={item.value}
            className={cn("flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground")}
          >
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }}
              />
            )}
            {itemConfig?.label}
          </div>
        );
      })}
    </div>
  );
});
ChartLegendContent.displayName = "ChartLegend";

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(config: ChartConfig, payload: unknown, key: string) {
  if (typeof payload !== "object" || payload === null) {
    return undefined;
  }

  const payloadPayload =
    "payload" in payload && typeof payload.payload === "object" && payload.payload !== null
      ? payload.payload
      : undefined;

  let configLabelKey: string = key;

  if (key in payload && typeof payload[key as keyof typeof payload] === "string") {
    configLabelKey = payload[key as keyof typeof payload] as string;
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[key as keyof typeof payloadPayload] as string;
  }

  return configLabelKey in config ? config[configLabelKey] : config[key as keyof typeof config];
}

export { ChartContainer, ChartTooltip, ChartTooltipContent, ChartLegend, ChartLegendContent, ChartStyle };

================
File: src/components/ui/checkbox.tsx
================
import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator className={cn("flex items-center justify-center text-current")}>
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };

================
File: src/components/ui/collapsible.tsx
================
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible";

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;

export { Collapsible, CollapsibleTrigger, CollapsibleContent };

================
File: src/components/ui/command.tsx
================
import * as React from "react";
import { type DialogProps } from "@radix-ui/react-dialog";
import { Command as CommandPrimitive } from "cmdk";
import { Search } from "lucide-react";

import { cn } from "@/lib/utils";
import { Dialog, DialogContent } from "@/components/ui/dialog";

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className,
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => <CommandPrimitive.Empty ref={ref} className="py-6 text-center text-sm" {...props} />);

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className,
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator ref={ref} className={cn("-mx-1 h-px bg-border", className)} {...props} />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      className,
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest text-muted-foreground", className)} {...props} />;
};
CommandShortcut.displayName = "CommandShortcut";

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};

================
File: src/components/ui/context-menu.tsx
================
import * as React from "react";
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const ContextMenu = ContextMenuPrimitive.Root;

const ContextMenuTrigger = ContextMenuPrimitive.Trigger;

const ContextMenuGroup = ContextMenuPrimitive.Group;

const ContextMenuPortal = ContextMenuPrimitive.Portal;

const ContextMenuSub = ContextMenuPrimitive.Sub;

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup;

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[state=open]:bg-accent data-[state=open]:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
));
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName;

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName;

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
));
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName;

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName;

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
));
ContextMenuCheckboxItem.displayName = ContextMenuPrimitive.CheckboxItem.displayName;

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
));
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName;

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold text-foreground", inset && "pl-8", className)}
    {...props}
  />
));
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName;

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-border", className)} {...props} />
));
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName;

const ContextMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest text-muted-foreground", className)} {...props} />;
};
ContextMenuShortcut.displayName = "ContextMenuShortcut";

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
};

================
File: src/components/ui/dialog.tsx
================
import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-accent data-[state=open]:text-muted-foreground hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)} {...props} />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

================
File: src/components/ui/drawer.tsx
================
import * as React from "react";
import { Drawer as DrawerPrimitive } from "vaul";

import { cn } from "@/lib/utils";

const Drawer = ({ shouldScaleBackground = true, ...props }: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root shouldScaleBackground={shouldScaleBackground} {...props} />
);
Drawer.displayName = "Drawer";

const DrawerTrigger = DrawerPrimitive.Trigger;

const DrawerPortal = DrawerPrimitive.Portal;

const DrawerClose = DrawerPrimitive.Close;

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay ref={ref} className={cn("fixed inset-0 z-50 bg-black/80", className)} {...props} />
));
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName;

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className,
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
));
DrawerContent.displayName = "DrawerContent";

const DrawerHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)} {...props} />
);
DrawerHeader.displayName = "DrawerHeader";

const DrawerFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("mt-auto flex flex-col gap-2 p-4", className)} {...props} />
);
DrawerFooter.displayName = "DrawerFooter";

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
DrawerTitle.displayName = DrawerPrimitive.Title.displayName;

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
DrawerDescription.displayName = DrawerPrimitive.Description.displayName;

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
};

================
File: src/components/ui/dropdown-menu.tsx
================
import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[state=open]:bg-accent focus:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest opacity-60", className)} {...props} />;
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};

================
File: src/components/ui/form.tsx
================
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import { Controller, ControllerProps, FieldPath, FieldValues, FormProvider, useFormContext } from "react-hook-form";

import { cn } from "@/lib/utils";
import { Label } from "@/components/ui/label";

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>({} as FormFieldContextValue);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>({} as FormItemContextValue);

const FormItem = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const id = React.useId();

    return (
      <FormItemContext.Provider value={{ id }}>
        <div ref={ref} className={cn("space-y-2", className)} {...props} />
      </FormItemContext.Provider>
    );
  },
);
FormItem.displayName = "FormItem";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return <Label ref={ref} className={cn(error && "text-destructive", className)} htmlFor={formItemId} {...props} />;
});
FormLabel.displayName = "FormLabel";

const FormControl = React.forwardRef<React.ElementRef<typeof Slot>, React.ComponentPropsWithoutRef<typeof Slot>>(
  ({ ...props }, ref) => {
    const { error, formItemId, formDescriptionId, formMessageId } = useFormField();

    return (
      <Slot
        ref={ref}
        id={formItemId}
        aria-describedby={!error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`}
        aria-invalid={!!error}
        {...props}
      />
    );
  },
);
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => {
    const { formDescriptionId } = useFormField();

    return <p ref={ref} id={formDescriptionId} className={cn("text-sm text-muted-foreground", className)} {...props} />;
  },
);
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, children, ...props }, ref) => {
    const { error, formMessageId } = useFormField();
    const body = error ? String(error?.message) : children;

    if (!body) {
      return null;
    }

    return (
      <p ref={ref} id={formMessageId} className={cn("text-sm font-medium text-destructive", className)} {...props}>
        {body}
      </p>
    );
  },
);
FormMessage.displayName = "FormMessage";

export { useFormField, Form, FormItem, FormLabel, FormControl, FormDescription, FormMessage, FormField };

================
File: src/components/ui/hover-card.tsx
================
import * as React from "react";
import * as HoverCardPrimitive from "@radix-ui/react-hover-card";

import { cn } from "@/lib/utils";

const HoverCard = HoverCardPrimitive.Root;

const HoverCardTrigger = HoverCardPrimitive.Trigger;

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName;

export { HoverCard, HoverCardTrigger, HoverCardContent };

================
File: src/components/ui/input-otp.tsx
================
import * as React from "react";
import { OTPInput, OTPInputContext } from "input-otp";
import { Dot } from "lucide-react";

import { cn } from "@/lib/utils";

const InputOTP = React.forwardRef<React.ElementRef<typeof OTPInput>, React.ComponentPropsWithoutRef<typeof OTPInput>>(
  ({ className, containerClassName, ...props }, ref) => (
    <OTPInput
      ref={ref}
      containerClassName={cn("flex items-center gap-2 has-[:disabled]:opacity-50", containerClassName)}
      className={cn("disabled:cursor-not-allowed", className)}
      {...props}
    />
  ),
);
InputOTP.displayName = "InputOTP";

const InputOTPGroup = React.forwardRef<React.ElementRef<"div">, React.ComponentPropsWithoutRef<"div">>(
  ({ className, ...props }, ref) => <div ref={ref} className={cn("flex items-center", className)} {...props} />,
);
InputOTPGroup.displayName = "InputOTPGroup";

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext);
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index];

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className,
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink h-4 w-px bg-foreground duration-1000" />
        </div>
      )}
    </div>
  );
});
InputOTPSlot.displayName = "InputOTPSlot";

const InputOTPSeparator = React.forwardRef<React.ElementRef<"div">, React.ComponentPropsWithoutRef<"div">>(
  ({ ...props }, ref) => (
    <div ref={ref} role="separator" {...props}>
      <Dot />
    </div>
  ),
);
InputOTPSeparator.displayName = "InputOTPSeparator";

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator };

================
File: src/components/ui/input.tsx
================
import * as React from "react";

import { cn } from "@/lib/utils";

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };

================
File: src/components/ui/label.tsx
================
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70");

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

================
File: src/components/ui/menubar.tsx
================
import * as React from "react";
import * as MenubarPrimitive from "@radix-ui/react-menubar";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const MenubarMenu = MenubarPrimitive.Menu;

const MenubarGroup = MenubarPrimitive.Group;

const MenubarPortal = MenubarPrimitive.Portal;

const MenubarSub = MenubarPrimitive.Sub;

const MenubarRadioGroup = MenubarPrimitive.RadioGroup;

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn("flex h-10 items-center space-x-1 rounded-md border bg-background p-1", className)}
    {...props}
  />
));
Menubar.displayName = MenubarPrimitive.Root.displayName;

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none data-[state=open]:bg-accent data-[state=open]:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  />
));
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName;

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[state=open]:bg-accent data-[state=open]:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
));
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName;

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName;

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(({ className, align = "start", alignOffset = -4, sideOffset = 8, ...props }, ref) => (
  <MenubarPrimitive.Portal>
    <MenubarPrimitive.Content
      ref={ref}
      align={align}
      alignOffset={alignOffset}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </MenubarPrimitive.Portal>
));
MenubarContent.displayName = MenubarPrimitive.Content.displayName;

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
MenubarItem.displayName = MenubarPrimitive.Item.displayName;

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
));
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName;

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
));
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName;

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)}
    {...props}
  />
));
MenubarLabel.displayName = MenubarPrimitive.Label.displayName;

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} />
));
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName;

const MenubarShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest text-muted-foreground", className)} {...props} />;
};
MenubarShortcut.displayname = "MenubarShortcut";

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
};

================
File: src/components/ui/navigation-menu.tsx
================
import * as React from "react";
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu";
import { cva } from "class-variance-authority";
import { ChevronDown } from "lucide-react";

import { cn } from "@/lib/utils";

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn("relative z-10 flex max-w-max flex-1 items-center justify-center", className)}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
));
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName;

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn("group flex flex-1 list-none items-center justify-center space-x-1", className)}
    {...props}
  />
));
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName;

const NavigationMenuItem = NavigationMenuPrimitive.Item;

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50",
);

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
));
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName;

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto",
      className,
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName;

const NavigationMenuLink = NavigationMenuPrimitive.Link;

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className,
      )}
      ref={ref}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName = NavigationMenuPrimitive.Viewport.displayName;

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className,
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
));
NavigationMenuIndicator.displayName = NavigationMenuPrimitive.Indicator.displayName;

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
};

================
File: src/components/ui/pagination.tsx
================
import * as React from "react";
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react";

import { cn } from "@/lib/utils";
import { ButtonProps, buttonVariants } from "@/components/ui/button";

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
);
Pagination.displayName = "Pagination";

const PaginationContent = React.forwardRef<HTMLUListElement, React.ComponentProps<"ul">>(
  ({ className, ...props }, ref) => (
    <ul ref={ref} className={cn("flex flex-row items-center gap-1", className)} {...props} />
  ),
);
PaginationContent.displayName = "PaginationContent";

const PaginationItem = React.forwardRef<HTMLLIElement, React.ComponentProps<"li">>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
));
PaginationItem.displayName = "PaginationItem";

type PaginationLinkProps = {
  isActive?: boolean;
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">;

const PaginationLink = ({ className, isActive, size = "icon", ...props }: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className,
    )}
    {...props}
  />
);
PaginationLink.displayName = "PaginationLink";

const PaginationPrevious = ({ className, ...props }: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink aria-label="Go to previous page" size="default" className={cn("gap-1 pl-2.5", className)} {...props}>
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
);
PaginationPrevious.displayName = "PaginationPrevious";

const PaginationNext = ({ className, ...props }: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink aria-label="Go to next page" size="default" className={cn("gap-1 pr-2.5", className)} {...props}>
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
);
PaginationNext.displayName = "PaginationNext";

const PaginationEllipsis = ({ className, ...props }: React.ComponentProps<"span">) => (
  <span aria-hidden className={cn("flex h-9 w-9 items-center justify-center", className)} {...props}>
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
);
PaginationEllipsis.displayName = "PaginationEllipsis";

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
};

================
File: src/components/ui/popover.tsx
================
import * as React from "react";
import * as PopoverPrimitive from "@radix-ui/react-popover";

import { cn } from "@/lib/utils";

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent };

================
File: src/components/ui/progress.tsx
================
import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn("relative h-4 w-full overflow-hidden rounded-full bg-secondary", className)}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };

================
File: src/components/ui/radio-group.tsx
================
import * as React from "react";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return <RadioGroupPrimitive.Root className={cn("grid gap-2", className)} {...props} ref={ref} />;
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };

================
File: src/components/ui/resizable.tsx
================
import { GripVertical } from "lucide-react";
import * as ResizablePrimitive from "react-resizable-panels";

import { cn } from "@/lib/utils";

const ResizablePanelGroup = ({ className, ...props }: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn("flex h-full w-full data-[panel-group-direction=vertical]:flex-col", className)}
    {...props}
  />
);

const ResizablePanel = ResizablePrimitive.Panel;

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className,
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
);

export { ResizablePanelGroup, ResizablePanel, ResizableHandle };

================
File: src/components/ui/scroll-area.tsx
================
import * as React from "react";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";

import { cn } from "@/lib/utils";

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root ref={ref} className={cn("relative overflow-hidden", className)} {...props}>
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">{children}</ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className,
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };

================
File: src/components/ui/select.tsx
================
import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label ref={ref} className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)} {...props} />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};

================
File: src/components/ui/separator.tsx
================
import * as React from "react";
import * as SeparatorPrimitive from "@radix-ui/react-separator";

import { cn } from "@/lib/utils";

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(({ className, orientation = "horizontal", decorative = true, ...props }, ref) => (
  <SeparatorPrimitive.Root
    ref={ref}
    decorative={decorative}
    orientation={orientation}
    className={cn("shrink-0 bg-border", orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]", className)}
    {...props}
  />
));
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };

================
File: src/components/ui/sheet.tsx
================
import * as SheetPrimitive from "@radix-ui/react-dialog";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<React.ElementRef<typeof SheetPrimitive.Content>, SheetContentProps>(
  ({ side = "right", className, children, ...props }, ref) => (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content ref={ref} className={cn(sheetVariants({ side }), className)} {...props}>
        {children}
        <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-secondary hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none">
          <X className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  ),
);
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-2 text-center sm:text-left", className)} {...props} />
);
SheetHeader.displayName = "SheetHeader";

const SheetFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
);
SheetFooter.displayName = "SheetFooter";

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title ref={ref} className={cn("text-lg font-semibold text-foreground", className)} {...props} />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetClose,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetOverlay,
  SheetPortal,
  SheetTitle,
  SheetTrigger,
};

================
File: src/components/ui/sidebar.tsx
================
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { VariantProps, cva } from "class-variance-authority";
import { PanelLeft } from "lucide-react";

import { useIsMobile } from "@/hooks/use-mobile";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { Sheet, SheetContent } from "@/components/ui/sheet";
import { Skeleton } from "@/components/ui/skeleton";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

const SIDEBAR_COOKIE_NAME = "sidebar:state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "16rem";
const SIDEBAR_WIDTH_MOBILE = "18rem";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";

type SidebarContext = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContext | null>(null);

function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }

  return context;
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean;
    open?: boolean;
    onOpenChange?: (open: boolean) => void;
  }
>(({ defaultOpen = true, open: openProp, onOpenChange: setOpenProp, className, style, children, ...props }, ref) => {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React.useState(false);

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open],
  );

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);
  }, [isMobile, setOpen, setOpenMobile]);

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === SIDEBAR_KEYBOARD_SHORTCUT && (event.metaKey || event.ctrlKey)) {
        event.preventDefault();
        toggleSidebar();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [toggleSidebar]);

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed";

  const contextValue = React.useMemo<SidebarContext>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar],
  );

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn("group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar", className)}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  );
});
SidebarProvider.displayName = "SidebarProvider";

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right";
    variant?: "sidebar" | "floating" | "inset";
    collapsible?: "offcanvas" | "icon" | "none";
  }
>(({ side = "left", variant = "sidebar", collapsible = "offcanvas", className, children, ...props }, ref) => {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();

  if (collapsible === "none") {
    return (
      <div
        className={cn("flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground", className)}
        ref={ref}
        {...props}
      >
        {children}
      </div>
    );
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-mobile="true"
          className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    );
  }

  return (
    <div
      ref={ref}
      className="group peer hidden text-sidebar-foreground md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        className={cn(
          "relative h-svh w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
            : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]",
        )}
      />
      <div
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
            : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className,
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
        >
          {children}
        </div>
      </div>
    </div>
  );
});
Sidebar.displayName = "Sidebar";

const SidebarTrigger = React.forwardRef<React.ElementRef<typeof Button>, React.ComponentProps<typeof Button>>(
  ({ className, onClick, ...props }, ref) => {
    const { toggleSidebar } = useSidebar();

    return (
      <Button
        ref={ref}
        data-sidebar="trigger"
        variant="ghost"
        size="icon"
        className={cn("h-7 w-7", className)}
        onClick={(event) => {
          onClick?.(event);
          toggleSidebar();
        }}
        {...props}
      >
        <PanelLeft />
        <span className="sr-only">Toggle Sidebar</span>
      </Button>
    );
  },
);
SidebarTrigger.displayName = "SidebarTrigger";

const SidebarRail = React.forwardRef<HTMLButtonElement, React.ComponentProps<"button">>(
  ({ className, ...props }, ref) => {
    const { toggleSidebar } = useSidebar();

    return (
      <button
        ref={ref}
        data-sidebar="rail"
        aria-label="Toggle Sidebar"
        tabIndex={-1}
        onClick={toggleSidebar}
        title="Toggle Sidebar"
        className={cn(
          "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] group-data-[side=left]:-right-4 group-data-[side=right]:left-0 hover:after:bg-sidebar-border sm:flex",
          "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
          "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
          "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
          "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
          "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarRail.displayName = "SidebarRail";

const SidebarInset = React.forwardRef<HTMLDivElement, React.ComponentProps<"main">>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className,
      )}
      {...props}
    />
  );
});
SidebarInset.displayName = "SidebarInset";

const SidebarInput = React.forwardRef<React.ElementRef<typeof Input>, React.ComponentProps<typeof Input>>(
  ({ className, ...props }, ref) => {
    return (
      <Input
        ref={ref}
        data-sidebar="input"
        className={cn(
          "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarInput.displayName = "SidebarInput";

const SidebarHeader = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(({ className, ...props }, ref) => {
  return <div ref={ref} data-sidebar="header" className={cn("flex flex-col gap-2 p-2", className)} {...props} />;
});
SidebarHeader.displayName = "SidebarHeader";

const SidebarFooter = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(({ className, ...props }, ref) => {
  return <div ref={ref} data-sidebar="footer" className={cn("flex flex-col gap-2 p-2", className)} {...props} />;
});
SidebarFooter.displayName = "SidebarFooter";

const SidebarSeparator = React.forwardRef<React.ElementRef<typeof Separator>, React.ComponentProps<typeof Separator>>(
  ({ className, ...props }, ref) => {
    return (
      <Separator
        ref={ref}
        data-sidebar="separator"
        className={cn("mx-2 w-auto bg-sidebar-border", className)}
        {...props}
      />
    );
  },
);
SidebarSeparator.displayName = "SidebarSeparator";

const SidebarContent = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className,
      )}
      {...props}
    />
  );
});
SidebarContent.displayName = "SidebarContent";

const SidebarGroup = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  );
});
SidebarGroup.displayName = "SidebarGroup";

const SidebarGroupLabel = React.forwardRef<HTMLDivElement, React.ComponentProps<"div"> & { asChild?: boolean }>(
  ({ className, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "div";

    return (
      <Comp
        ref={ref}
        data-sidebar="group-label"
        className={cn(
          "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarGroupLabel.displayName = "SidebarGroupLabel";

const SidebarGroupAction = React.forwardRef<HTMLButtonElement, React.ComponentProps<"button"> & { asChild?: boolean }>(
  ({ className, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";

    return (
      <Comp
        ref={ref}
        data-sidebar="group-action"
        className={cn(
          "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          // Increases the hit area of the button on mobile.
          "after:absolute after:-inset-2 after:md:hidden",
          "group-data-[collapsible=icon]:hidden",
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarGroupAction.displayName = "SidebarGroupAction";

const SidebarGroupContent = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(
  ({ className, ...props }, ref) => (
    <div ref={ref} data-sidebar="group-content" className={cn("w-full text-sm", className)} {...props} />
  ),
);
SidebarGroupContent.displayName = "SidebarGroupContent";

const SidebarMenu = React.forwardRef<HTMLUListElement, React.ComponentProps<"ul">>(({ className, ...props }, ref) => (
  <ul ref={ref} data-sidebar="menu" className={cn("flex w-full min-w-0 flex-col gap-1", className)} {...props} />
));
SidebarMenu.displayName = "SidebarMenu";

const SidebarMenuItem = React.forwardRef<HTMLLIElement, React.ComponentProps<"li">>(({ className, ...props }, ref) => (
  <li ref={ref} data-sidebar="menu-item" className={cn("group/menu-item relative", className)} {...props} />
));
SidebarMenuItem.displayName = "SidebarMenuItem";

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean;
    isActive?: boolean;
    tooltip?: string | React.ComponentProps<typeof TooltipContent>;
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(({ asChild = false, isActive = false, variant = "default", size = "default", tooltip, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "button";
  const { isMobile, state } = useSidebar();

  const button = (
    <Comp
      ref={ref}
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  );

  if (!tooltip) {
    return button;
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    };
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent side="right" align="center" hidden={state !== "collapsed" || isMobile} {...tooltip} />
    </Tooltip>
  );
});
SidebarMenuButton.displayName = "SidebarMenuButton";

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean;
    showOnHover?: boolean;
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform peer-hover/menu-button:text-sidebar-accent-foreground hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className,
      )}
      {...props}
    />
  );
});
SidebarMenuAction.displayName = "SidebarMenuAction";

const SidebarMenuBadge = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      data-sidebar="menu-badge"
      className={cn(
        "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  ),
);
SidebarMenuBadge.displayName = "SidebarMenuBadge";

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean;
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && <Skeleton className="size-4 rounded-md" data-sidebar="menu-skeleton-icon" />}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  );
});
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton";

const SidebarMenuSub = React.forwardRef<HTMLUListElement, React.ComponentProps<"ul">>(
  ({ className, ...props }, ref) => (
    <ul
      ref={ref}
      data-sidebar="menu-sub"
      className={cn(
        "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  ),
);
SidebarMenuSub.displayName = "SidebarMenuSub";

const SidebarMenuSubItem = React.forwardRef<HTMLLIElement, React.ComponentProps<"li">>(({ ...props }, ref) => (
  <li ref={ref} {...props} />
));
SidebarMenuSubItem.displayName = "SidebarMenuSubItem";

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean;
    size?: "sm" | "md";
    isActive?: boolean;
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring aria-disabled:pointer-events-none aria-disabled:opacity-50 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  );
});
SidebarMenuSubButton.displayName = "SidebarMenuSubButton";

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};

================
File: src/components/ui/skeleton.tsx
================
import { cn } from "@/lib/utils";

function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return <div className={cn("animate-pulse rounded-md bg-muted", className)} {...props} />;
}

export { Skeleton };

================
File: src/components/ui/slider.tsx
================
import * as React from "react";
import * as SliderPrimitive from "@radix-ui/react-slider";

import { cn } from "@/lib/utils";

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn("relative flex w-full touch-none select-none items-center", className)}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };

================
File: src/components/ui/sonner.tsx
================
import { useTheme } from "next-themes";
import { Toaster as Sonner, toast } from "sonner";

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  );
};

export { Toaster, toast };

================
File: src/components/ui/switch.tsx
================
import * as React from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";

import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50",
      className,
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0",
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };

================
File: src/components/ui/table.tsx
================
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<HTMLTableElement, React.HTMLAttributes<HTMLTableElement>>(
  ({ className, ...props }, ref) => (
    <div className="relative w-full overflow-auto">
      <table ref={ref} className={cn("w-full caption-bottom text-sm", className)} {...props} />
    </div>
  ),
);
Table.displayName = "Table";

const TableHeader = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />,
);
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tbody ref={ref} className={cn("[&_tr:last-child]:border-0", className)} {...props} />
  ),
);
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tfoot ref={ref} className={cn("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", className)} {...props} />
  ),
);
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<HTMLTableRowElement, React.HTMLAttributes<HTMLTableRowElement>>(
  ({ className, ...props }, ref) => (
    <tr
      ref={ref}
      className={cn("border-b transition-colors data-[state=selected]:bg-muted hover:bg-muted/50", className)}
      {...props}
    />
  ),
);
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<HTMLTableCellElement, React.ThHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <th
      ref={ref}
      className={cn(
        "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
        className,
      )}
      {...props}
    />
  ),
);
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<HTMLTableCellElement, React.TdHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <td ref={ref} className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)} {...props} />
  ),
);
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<HTMLTableCaptionElement, React.HTMLAttributes<HTMLTableCaptionElement>>(
  ({ className, ...props }, ref) => (
    <caption ref={ref} className={cn("mt-4 text-sm text-muted-foreground", className)} {...props} />
  ),
);
TableCaption.displayName = "TableCaption";

export { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption };

================
File: src/components/ui/tabs.tsx
================
import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";

import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className,
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };

================
File: src/components/ui/textarea.tsx
================
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = "Textarea";

export { Textarea };

================
File: src/components/ui/toast.tsx
================
import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> & VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return <ToastPrimitives.Root ref={ref} className={cn(toastVariants({ variant }), className)} {...props} />;
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50",
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:outline-none focus:ring-2 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title ref={ref} className={cn("text-sm font-semibold", className)} {...props} />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description ref={ref} className={cn("text-sm opacity-90", className)} {...props} />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

================
File: src/components/ui/toaster.tsx
================
import { useToast } from "@/hooks/use-toast";
import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from "@/components/ui/toast";

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && <ToastDescription>{description}</ToastDescription>}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}

================
File: src/components/ui/toggle-group.tsx
================
import * as React from "react";
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group";
import { type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";
import { toggleVariants } from "@/components/ui/toggle";

const ToggleGroupContext = React.createContext<VariantProps<typeof toggleVariants>>({
  size: "default",
  variant: "default",
});

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> & VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root ref={ref} className={cn("flex items-center justify-center gap-1", className)} {...props}>
    <ToggleGroupContext.Provider value={{ variant, size }}>{children}</ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
));

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName;

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> & VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext);

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className,
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  );
});

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName;

export { ToggleGroup, ToggleGroupItem };

================
File: src/components/ui/toggle.tsx
================
import * as React from "react";
import * as TogglePrimitive from "@radix-ui/react-toggle";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> & VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root ref={ref} className={cn(toggleVariants({ variant, size, className }))} {...props} />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };

================
File: src/components/ui/tooltip.tsx
================
import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

================
File: src/components/ui/use-toast.ts
================
import { useToast, toast } from "@/hooks/use-toast";

export { useToast, toast };

================
File: src/components/UsernameSelection.tsx
================
import React, { useState } from "react";
import { toast } from "@/hooks/use-toast";
import { setUsername } from "@/services/userService";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

export const UsernameSelection: React.FC<{ onComplete: () => void }> = ({ onComplete }) => {
  const [username, setUsernameInput] = useState("");
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    const res = await setUsername(username);
    setLoading(false);
    if (res.success) {
      toast({
        title: "Success",
        description: "Username set successfully!"
      });
      onComplete();
    } else {
      toast({
        title: "Error",
        description: res.error || "Failed to set username",
        variant: "destructive"
      });
    }
  };

  return (
    <div className="max-w-md mx-auto min-h-screen bg-background flex items-center justify-center p-4">
      <Card className="w-full">
        <CardHeader>
          <CardTitle>Choose Your Username</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div>
              <label htmlFor="username" className="block text-sm font-medium mb-2">
                Username
              </label>
              <Input
                id="username"
                value={username}
                onChange={e => setUsernameInput(e.target.value)}
                placeholder="Enter your username"
                required
                minLength={3}
                maxLength={20}
                pattern="^[a-zA-Z0-9_]+$"
                disabled={loading}
              />
              <p className="text-xs text-muted-foreground mt-1">
                3-20 characters, letters, numbers, and underscores only
              </p>
            </div>
            <Button 
              type="submit" 
              className="w-full" 
              disabled={loading || !username}
            >
              {loading ? "Saving..." : "Save Username"}
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
};

================
File: src/data/schema.md
================
# Bean Scene Database Schema

## Overview
Bean Scene uses Supabase PostgreSQL for data storage with the following core tables and relationships.

## Tables

### cafes
Stores cafe information fetched from Google Places API

```sql
CREATE TABLE cafes (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  place_id VARCHAR(255) UNIQUE NOT NULL, -- Google Places ID
  name VARCHAR(255) NOT NULL,
  address TEXT NOT NULL,
  neighborhood VARCHAR(100),
  lat DECIMAL(10, 8) NOT NULL,
  lng DECIMAL(11, 8) NOT NULL,
  google_rating DECIMAL(2, 1),
  hours TEXT, -- JSON string of operating hours
  phone VARCHAR(20),
  price_level INTEGER CHECK (price_level >= 1 AND price_level <= 4),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_cafes_place_id ON cafes(place_id);
CREATE INDEX idx_cafes_neighborhood ON cafes(neighborhood);
CREATE INDEX idx_cafes_location ON cafes(lat, lng);
```

### posts
User check-ins with photos and reviews

```sql
CREATE TABLE posts (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  place_id VARCHAR(255) REFERENCES cafes(place_id) ON DELETE CASCADE,
  image_url TEXT NOT NULL, -- Cloudinary URL
  tags TEXT[] DEFAULT '{}', -- Array of tag strings
  rating INTEGER CHECK (rating >= 1 AND rating <= 5),
  text_review TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_posts_user_id ON posts(user_id);
CREATE INDEX idx_posts_place_id ON posts(place_id);
CREATE INDEX idx_posts_created_at ON posts(created_at DESC);
CREATE INDEX idx_posts_tags ON posts USING GIN(tags);
```

### post_likes
Track user likes on posts

```sql
CREATE TABLE post_likes (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  post_id UUID REFERENCES posts(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, post_id)
);

-- Indexes
CREATE INDEX idx_post_likes_user_id ON post_likes(user_id);
CREATE INDEX idx_post_likes_post_id ON post_likes(post_id);
```

### post_comments
Comments on posts

```sql
CREATE TABLE post_comments (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  post_id UUID REFERENCES posts(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_post_comments_post_id ON post_comments(post_id);
CREATE INDEX idx_post_comments_created_at ON post_comments(created_at);
```

### favorite_cafes
User's favorite cafes

```sql
CREATE TABLE favorite_cafes (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  place_id VARCHAR(255) REFERENCES cafes(place_id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, place_id)
);

-- Indexes
CREATE INDEX idx_favorite_cafes_user_id ON favorite_cafes(user_id);
```

### user_profiles
Extended user information

```sql
CREATE TABLE user_profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  username VARCHAR(50) UNIQUE,
  full_name VARCHAR(100),
  avatar_url TEXT,
  bio TEXT,
  location VARCHAR(100),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

## Row Level Security (RLS) Policies

### cafes
- Public read access
- Admin write access only

### posts
- Public read access
- Users can create/update/delete their own posts

### post_likes
- Public read access for counts
- Users can like/unlike posts

### post_comments
- Public read access
- Users can create/update/delete their own comments

### favorite_cafes
- Users can only see/modify their own favorites

### user_profiles
- Public read access for basic info
- Users can update their own profile

## Environment Variables

```bash
# Google Places API (server-side only)
GOOGLE_PLACES_API_KEY=your_google_places_api_key

# Cloudinary for image storage
CLOUDINARY_CLOUD_NAME=your_cloud_name
CLOUDINARY_API_KEY=your_api_key
CLOUDINARY_API_SECRET=your_api_secret

# Supabase (auto-provided by Lovable integration)
SUPABASE_URL=your_supabase_url
SUPABASE_ANON_KEY=your_supabase_anon_key
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key
```

## API Endpoints (Placeholder Structure)

### Cafe Endpoints
- `GET /api/cafes/nearby?lat={lat}&lng={lng}&radius={radius}` - Get nearby cafes
- `GET /api/cafes/search?q={query}&neighborhood={neighborhood}` - Search cafes
- `GET /api/cafes/{placeId}` - Get cafe details
- `POST /api/cafes` - Add new cafe (from Google Places)

### Post Endpoints
- `GET /api/posts?cafe={placeId}&limit={limit}&offset={offset}` - Get posts
- `POST /api/posts` - Create new post
- `PUT /api/posts/{id}` - Update post
- `DELETE /api/posts/{id}` - Delete post

### User Endpoints  
- `GET /api/users/{id}/posts` - Get user's posts
- `GET /api/users/{id}/favorites` - Get user's favorite cafes
- `POST /api/users/{id}/favorites` - Add cafe to favorites
- `DELETE /api/users/{id}/favorites/{placeId}` - Remove from favorites

## Future Enhancements
- Cafe busy status tracking
- Popular times integration
- User leaderboards and badges
- Real-time notifications
- Advanced search filters
- Cafe owner verification

================
File: src/hooks/use-google-analytics.ts
================
import { useEffect } from 'react';
import { useLocation } from 'react-router-dom';
import { googleAnalytics } from '@/services/googleAnalyticsService';

/**
 * Hook to automatically track page views and provide analytics utilities
 */
export function useGoogleAnalytics() {
  const location = useLocation();

  // Track page views automatically
  useEffect(() => {
    googleAnalytics.trackPageView(location.pathname + location.search);
  }, [location]);

  return {
    trackEvent: googleAnalytics.trackEvent.bind(googleAnalytics),
    trackCafeEvent: googleAnalytics.trackCafeEvent.bind(googleAnalytics),
    trackCheckIn: googleAnalytics.trackCheckIn.bind(googleAnalytics),
    trackQuickPost: googleAnalytics.trackQuickPost.bind(googleAnalytics),
    trackSearch: googleAnalytics.trackSearch.bind(googleAnalytics),
    trackCafeDetailView: googleAnalytics.trackCafeDetailView.bind(googleAnalytics),
    trackFeedInteraction: googleAnalytics.trackFeedInteraction.bind(googleAnalytics),
    trackEngagement: googleAnalytics.trackEngagement.bind(googleAnalytics),
    trackError: googleAnalytics.trackError.bind(googleAnalytics),
    trackAdminAction: googleAnalytics.trackAdminAction.bind(googleAnalytics),
  };
}

================
File: src/hooks/use-mobile.tsx
================
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined);

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}

================
File: src/hooks/use-toast.ts
================
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t)),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast };

================
File: src/index.css
================
/* Import Coffee Theme */
@import './styles/coffee-theme.css';

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Bean Scene Design System - Warm Coffee Aesthetics */

@layer base {
  :root {
    /* Coffee-inspired warm palette */
    --background: 45 15% 97%;
    --foreground: 25 15% 15%;

    --card: 45 20% 98%;
    --card-foreground: 25 15% 15%;

    --popover: 45 20% 98%;
    --popover-foreground: 25 15% 15%;

    /* Rich coffee brown primary */
    --primary: 25 45% 25%;
    --primary-foreground: 45 25% 98%;
    --primary-glow: 25 45% 35%;

    /* Warm cream secondary */
    --secondary: 40 35% 92%;
    --secondary-foreground: 25 45% 25%;

    /* Soft muted tones */
    --muted: 40 20% 94%;
    --muted-foreground: 25 15% 45%;

    /* Warm accent */
    --accent: 35 55% 85%;
    --accent-foreground: 25 45% 25%;

    /* Coffee red destructive */
    --destructive: 5 65% 55%;
    --destructive-foreground: 45 25% 98%;

    --border: 40 20% 88%;
    --input: 40 20% 88%;
    --ring: 25 45% 25%;

    --radius: 0.75rem;

    /* Coffee gradients */
    --gradient-coffee: linear-gradient(135deg, hsl(25, 45%, 25%), hsl(25, 45%, 35%));
    --gradient-cream: linear-gradient(180deg, hsl(45, 35%, 97%), hsl(40, 25%, 94%));
    --gradient-warm: linear-gradient(135deg, hsl(35, 55%, 85%), hsl(40, 35%, 92%));

    /* Elegant shadows */
    --shadow-coffee: 0 4px 20px -4px hsl(25 45% 25% / 0.15);
    --shadow-warm: 0 8px 30px -8px hsl(25 45% 25% / 0.12);
    --shadow-glow: 0 0 30px hsl(25 45% 35% / 0.2);

    /* Smooth transitions */
    --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    --transition-bounce: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);

    /* Sidebar colors */
    --sidebar-background: 45 20% 98%;
    --sidebar-foreground: 25 15% 15%;
    --sidebar-primary: 25 45% 25%;
    --sidebar-primary-foreground: 45 25% 98%;
    --sidebar-accent: 40 35% 92%;
    --sidebar-accent-foreground: 25 45% 25%;
    --sidebar-border: 40 20% 88%;
    --sidebar-ring: 25 45% 25%;
  }

  .dark {
    /* Dark coffee theme */
    --background: 25 25% 8%;
    --foreground: 45 15% 92%;

    --card: 25 25% 10%;
    --card-foreground: 45 15% 92%;

    --popover: 25 25% 10%;
    --popover-foreground: 45 15% 92%;

    --primary: 40 35% 85%;
    --primary-foreground: 25 25% 8%;
    --primary-glow: 40 35% 75%;

    --secondary: 25 15% 15%;
    --secondary-foreground: 45 15% 92%;

    --muted: 25 15% 12%;
    --muted-foreground: 45 10% 65%;

    --accent: 25 15% 15%;
    --accent-foreground: 45 15% 92%;

    --destructive: 5 65% 60%;
    --destructive-foreground: 45 15% 92%;

    --border: 25 15% 15%;
    --input: 25 15% 15%;
    --ring: 40 35% 75%;

    --gradient-coffee: linear-gradient(135deg, hsl(25, 25%, 8%), hsl(25, 15%, 15%));
    --gradient-cream: linear-gradient(180deg, hsl(25, 25%, 10%), hsl(25, 15%, 12%));
    --gradient-warm: linear-gradient(135deg, hsl(25, 15%, 15%), hsl(25, 15%, 12%));

    --shadow-coffee: 0 4px 20px -4px hsl(0 0% 0% / 0.3);
    --shadow-warm: 0 8px 30px -8px hsl(0 0% 0% / 0.25);
    --shadow-glow: 0 0 30px hsl(40 35% 85% / 0.15);

    --sidebar-background: 25 25% 10%;
    --sidebar-foreground: 45 15% 92%;
    --sidebar-primary: 40 35% 85%;
    --sidebar-primary-foreground: 25 25% 8%;
    --sidebar-accent: 25 15% 15%;
    --sidebar-accent-foreground: 45 15% 92%;
    --sidebar-border: 25 15% 15%;
    --sidebar-ring: 40 35% 75%;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground font-sans;
    font-feature-settings: "rlig" 1, "calt" 1;
  }

  /* Custom scrollbar */
  ::-webkit-scrollbar {
    width: 6px;
  }

  ::-webkit-scrollbar-track {
    @apply bg-muted;
  }

  ::-webkit-scrollbar-thumb {
    @apply bg-muted-foreground/30 rounded-full;
  }

  ::-webkit-scrollbar-thumb:hover {
    @apply bg-muted-foreground/50;
  }
}

/* Utility classes */
@layer utilities {
  .coffee-gradient {
    background: var(--gradient-coffee);
  }

  .cream-gradient {
    background: var(--gradient-cream);
  }

  .warm-gradient {
    background: var(--gradient-warm);
  }

  .shadow-coffee {
    box-shadow: var(--shadow-coffee);
  }

  .shadow-warm {
    box-shadow: var(--shadow-warm);
  }

  .shadow-glow {
    box-shadow: var(--shadow-glow);
  }

  .transition-smooth {
    transition: var(--transition-smooth);
  }

  .transition-bounce {
    transition: var(--transition-bounce);
  }

  .glass-effect {
    @apply bg-white/10 backdrop-blur-md border border-white/20;
  }
}

================
File: src/integrations/supabase/client.ts
================
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Use import.meta.env for Vite/browser builds
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "https://hhdcequsdmosxzjebdyj.supabase.co";
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoZGNlcXVzZG1vc3h6amViZHlqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNjQwODMsImV4cCI6MjA3MzY0MDA4M30.BJ8tbA2zBC_IgC3Li_uE5P1-cPHA1Gi6mESaJVToPqA";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: {
    storage: typeof window !== 'undefined' ? localStorage : undefined,
    persistSession: true,
    autoRefreshToken: true,
  }
});

================
File: src/integrations/supabase/types.ts
================
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: "13.0.5"
  }
  public: {
    Tables: {
      api_usage_logs: {
        Row: {
          api_service: string
          created_at: string
          date: string
          endpoint: string
          error_message: string | null
          id: string
          request_count: number
          response_status: number | null
        }
        Insert: {
          api_service: string
          created_at?: string
          date?: string
          endpoint: string
          error_message?: string | null
          id?: string
          request_count?: number
          response_status?: number | null
        }
        Update: {
          api_service?: string
          created_at?: string
          date?: string
          endpoint?: string
          error_message?: string | null
          id?: string
          request_count?: number
          response_status?: number | null
        }
        Relationships: []
      }
      cafe_photos: {
        Row: {
          cafe_id: string | null
          id: string
          is_approved: boolean | null
          is_hero: boolean | null
          photo_url: string
          uploaded_at: string | null
          uploaded_by: string | null
        }
        Insert: {
          cafe_id?: string | null
          id?: string
          is_approved?: boolean | null
          is_hero?: boolean | null
          photo_url: string
          uploaded_at?: string | null
          uploaded_by?: string | null
        }
        Update: {
          cafe_id?: string | null
          id?: string
          is_approved?: boolean | null
          is_hero?: boolean | null
          photo_url?: string
          uploaded_at?: string | null
          uploaded_by?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "cafe_photos_cafe_id_fkey"
            columns: ["cafe_id"]
            isOneToOne: false
            referencedRelation: "cafes"
            referencedColumns: ["id"]
          },
        ]
      }
      cafe_reviews: {
        Row: {
          cafe_id: string
          created_at: string | null
          id: string
          profile_photo_url: string | null
          rating: number
          review_text: string
          reviewer_name: string
          time: string
          updated_at: string | null
        }
        Insert: {
          cafe_id: string
          created_at?: string | null
          id?: string
          profile_photo_url?: string | null
          rating: number
          review_text: string
          reviewer_name: string
          time: string
          updated_at?: string | null
        }
        Update: {
          cafe_id?: string
          created_at?: string | null
          id?: string
          profile_photo_url?: string | null
          rating?: number
          review_text?: string
          reviewer_name?: string
          time?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "cafe_reviews_cafe_id_fkey"
            columns: ["cafe_id"]
            isOneToOne: false
            referencedRelation: "cafes"
            referencedColumns: ["id"]
          },
        ]
      }
      cafes: {
        Row: {
          address: string
          cached_weather_data: Json | null
          created_at: string
          google_photo_reference: string | null
          google_rating: number | null
          hero_photo_url: string | null
          hero_updated_at: string | null
          id: string
          is_active: boolean
          latitude: number
          longitude: number
          name: string
          neighborhood: string | null
          opening_hours: string[] | null
          parking_info: string | null
          phone_number: string | null
          photos: string[] | null
          place_id: string
          price_level: number | null
          rating: number | null
          tags: string[]
          updated_at: string
          user_rating: number | null
          weather_cached_at: string | null
          website: string | null
        }
        Insert: {
          address: string
          cached_weather_data?: Json | null
          created_at?: string
          google_photo_reference?: string | null
          google_rating?: number | null
          hero_photo_url?: string | null
          hero_updated_at?: string | null
          id?: string
          is_active?: boolean
          latitude: number
          longitude: number
          name: string
          neighborhood?: string | null
          opening_hours?: string[] | null
          parking_info?: string | null
          phone_number?: string | null
          photos?: string[] | null
          place_id: string
          price_level?: number | null
          rating?: number | null
          tags?: string[]
          updated_at?: string
          user_rating?: number | null
          weather_cached_at?: string | null
          website?: string | null
        }
        Update: {
          address?: string
          cached_weather_data?: Json | null
          created_at?: string
          google_photo_reference?: string | null
          google_rating?: number | null
          hero_photo_url?: string | null
          hero_updated_at?: string | null
          id?: string
          is_active?: boolean
          latitude?: number
          longitude?: number
          name?: string
          neighborhood?: string | null
          opening_hours?: string[] | null
          parking_info?: string | null
          phone_number?: string | null
          photos?: string[] | null
          place_id?: string
          price_level?: number | null
          rating?: number | null
          tags?: string[]
          updated_at?: string
          user_rating?: number | null
          weather_cached_at?: string | null
          website?: string | null
        }
        Relationships: []
      }
      posts: {
        Row: {
          cafe_id: string
          comments: number
          created_at: string
          device_id: string | null
          id: string
          image_url: string
          likes: number
          place_id: string
          rating: number
          tags: string[]
          text_review: string
          updated_at: string
          user_id: string
          username: string | null
        }
        Insert: {
          cafe_id: string
          comments?: number
          created_at?: string
          device_id?: string | null
          id?: string
          image_url: string
          likes?: number
          place_id: string
          rating: number
          tags?: string[]
          text_review: string
          updated_at?: string
          user_id: string
          username?: string | null
        }
        Update: {
          cafe_id?: string
          comments?: number
          created_at?: string
          device_id?: string | null
          id?: string
          image_url?: string
          likes?: number
          place_id?: string
          rating?: number
          tags?: string[]
          text_review?: string
          updated_at?: string
          user_id?: string
          username?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "posts_cafe_id_fkey"
            columns: ["cafe_id"]
            isOneToOne: false
            referencedRelation: "cafes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "posts_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      sync_history: {
        Row: {
          cafes_processed: number | null
          created_at: string | null
          error_message: string | null
          id: string
          status: string
          sync_date: string
          sync_type: string
        }
        Insert: {
          cafes_processed?: number | null
          created_at?: string | null
          error_message?: string | null
          id?: string
          status: string
          sync_date: string
          sync_type: string
        }
        Update: {
          cafes_processed?: number | null
          created_at?: string | null
          error_message?: string | null
          id?: string
          status?: string
          sync_date?: string
          sync_type?: string
        }
        Relationships: []
      }
      users: {
        Row: {
          auth_user_id: string | null
          avatar: string | null
          created_at: string
          email: string
          id: string
          name: string
          updated_at: string
          username: string | null
        }
        Insert: {
          auth_user_id?: string | null
          avatar?: string | null
          created_at?: string
          email: string
          id?: string
          name: string
          updated_at?: string
          username?: string | null
        }
        Update: {
          auth_user_id?: string | null
          avatar?: string | null
          created_at?: string
          email?: string
          id?: string
          name?: string
          updated_at?: string
          username?: string | null
        }
        Relationships: []
      }
      favorites: {
        Row: {
          cafe_id: string
          created_at: string
          device_id: string | null
          id: string
          user_id: string | null
        }
        Insert: {
          cafe_id: string
          created_at?: string
          device_id?: string | null
          id?: string
          user_id?: string | null
        }
        Update: {
          cafe_id?: string
          created_at?: string
          device_id?: string | null
          id?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "favorites_cafe_id_fkey"
            columns: ["cafe_id"]
            isOneToOne: false
            referencedRelation: "cafes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "favorites_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          }
        ]
      }
      user_activities: {
        Row: {
          activity_type: string
          cafe_id: string | null
          created_at: string
          id: string
          metadata: Json | null
          user_id: string | null
          username: string | null
        }
        Insert: {
          activity_type: string
          cafe_id?: string | null
          created_at?: string
          id?: string
          metadata?: Json | null
          user_id?: string | null
          username?: string | null
        }
        Update: {
          activity_type?: string
          cafe_id?: string | null
          created_at?: string
          id?: string
          metadata?: Json | null
          user_id?: string | null
          username?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "user_activities_cafe_id_fkey"
            columns: ["cafe_id"]
            isOneToOne: false
            referencedRelation: "cafes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "user_activities_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          }
        ]
      }
      validation_logs: {
        Row: {
          action_type: string
          cafe_id: string | null
          created_at: string
          error_reason: string | null
          id: string
          ip_address: unknown | null
          place_id: string | null
          user_agent: string | null
          user_id: string | null
          validation_result: boolean
        }
        Insert: {
          action_type: string
          cafe_id?: string | null
          created_at?: string
          error_reason?: string | null
          id?: string
          ip_address?: unknown | null
          place_id?: string | null
          user_agent?: string | null
          user_id?: string | null
          validation_result: boolean
        }
        Update: {
          action_type?: string
          cafe_id?: string | null
          created_at?: string
          error_reason?: string | null
          id?: string
          ip_address?: unknown | null
          place_id?: string | null
          user_agent?: string | null
          user_id?: string | null
          validation_result?: boolean
        }
        Relationships: []
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      calculate_cafe_user_rating: {
        Args: { cafe_uuid: string }
        Returns: number
      }
      update_cafe_hero_image: {
        Args: { cafe_uuid: string }
        Returns: undefined
      }
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  public: {
    Enums: {},
  },
} as const

================
File: src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

================
File: src/main.tsx
================
import { createRoot } from "react-dom/client";
import App from "./App.tsx";
import "./index.css";

createRoot(document.getElementById("root")!).render(<App />);

================
File: src/pages/admin/Dashboard.tsx
================
import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { supabase } from '@/integrations/supabase/client';
import { useGoogleAnalytics } from '@/hooks/use-google-analytics';
import { LogOut, Database, TrendingUp, MapPin, AlertCircle, Users, Activity, BarChart3, MessageSquare, Mail, Calendar, Filter } from 'lucide-react';
import { getEngagementMetrics, getDailyActiveUsers, getMonthlyActiveUsers, getUserGrowth, EngagementMetrics, DailyActiveUsers, UserGrowth } from '@/services/analyticsService';
import { fetchCafes } from '@/services/cafeService';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { Badge } from '@/components/ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';

interface OperationResult {
  success: boolean;
  message: string;
  stats?: {
    processed: number;
    succeeded: number;
    failed: number;
    reviewsAdded?: number;
    apiCalls: number;
    estimatedCost: number;
  };
  errors?: Array<{ cafe: string; error: string }>;
}

interface FeedbackStats {
  total: number;
  by_type: {
    bug: number;
    feature: number;
    general: number;
    support: number;
  };
  with_followup: number;
  recent_count: number;
}

interface AdminFeedback {
  id: string;
  feedback_type: 'bug' | 'feature' | 'general' | 'support';
  subject: string;
  details: string;
  allow_followup: boolean;
  contact_email?: string;
  user_id?: string;
  device_id?: string;
  created_at: string;
  updated_at: string;
  user_name?: string;
  user_email?: string;
}

export default function AdminDashboard() {
  const navigate = useNavigate();
  const { toast } = useToast();
  const { trackAdminAction } = useGoogleAnalytics();
  const [stats, setStats] = useState({
    totalCafes: 0,
    cafesWithHours: 0,
    cafesWithParking: 0,
    cafesWithPhone: 0,
    cafesWithWebsite: 0,
    totalReviews: 0,
    cafesNeedingEnrichment: 0,
  });
  const [isLoadingStats, setIsLoadingStats] = useState(true);
  const [engagementMetrics, setEngagementMetrics] = useState<EngagementMetrics | null>(null);
  const [dailyActiveUsers, setDailyActiveUsers] = useState<DailyActiveUsers[]>([]);
  const [userGrowth, setUserGrowth] = useState<UserGrowth[]>([]);
  const [isLoadingAnalytics, setIsLoadingAnalytics] = useState(true);
  const [operations, setOperations] = useState({
    addReviews: false,
    refreshAmenities: false,
    enrichCafes: false,
    fullEnrichment: false,
  });
  const [confirmDialog, setConfirmDialog] = useState<{
    open: boolean;
    operation: string;
    message: string;
    onConfirm: () => void;
  }>({
    open: false,
    operation: '',
    message: '',
    onConfirm: () => {},
  });
  const [lastResult, setLastResult] = useState<OperationResult | null>(null);
  
  // Feedback state
  const [feedbackStats, setFeedbackStats] = useState<FeedbackStats | null>(null);
  const [feedback, setFeedback] = useState<AdminFeedback[]>([]);
  const [isLoadingFeedback, setIsLoadingFeedback] = useState(true);
  const [feedbackFilter, setFeedbackFilter] = useState<string>('all');

  useEffect(() => {
    // Check authentication
    if (sessionStorage.getItem('admin_authenticated') !== 'true') {
      navigate('/admin/login');
      return;
    }

    fetchStats();
    fetchAnalytics();
    fetchFeedback();
  }, [navigate, feedbackFilter]);

  const fetchStats = async () => {
    setIsLoadingStats(true);
    try {
      const [cafesResult, reviewsResult] = await Promise.all([
        fetchCafes(), // Use fetchCafes to get all cafes
        supabase.from('cafe_reviews').select('id', { count: 'exact' }),
      ]);

      if (cafesResult.success && cafesResult.data) {
        console.log(`Admin Dashboard: Fetched ${cafesResult.data.length} cafes`);
        const cafesNeedingEnrichment = cafesResult.data.filter(
          c => !c.openingHours || !c.openingHours.length
        ).length;

        setStats({
          totalCafes: cafesResult.data.length,
          cafesWithHours: cafesResult.data.filter(c => c.openingHours?.length).length,
          cafesWithParking: cafesResult.data.filter(c => c.parkingInfo).length,
          cafesWithPhone: cafesResult.data.filter(c => c.phoneNumber).length,
          cafesWithWebsite: cafesResult.data.filter(c => c.website).length,
          totalReviews: reviewsResult.count || 0,
          cafesNeedingEnrichment,
        });
      }
    } catch (error) {
      console.error('Error fetching stats:', error);
    }
    setIsLoadingStats(false);
  };

  const fetchAnalytics = async () => {
    setIsLoadingAnalytics(true);
    try {
      const [engagementResult, dauResult, growthResult] = await Promise.all([
        getEngagementMetrics(),
        getDailyActiveUsers(30),
        getUserGrowth(30)
      ]);

      if (engagementResult.success) {
        setEngagementMetrics(engagementResult.data);
      }

      if (dauResult.success) {
        setDailyActiveUsers(dauResult.data);
      }

      if (growthResult.success) {
        setUserGrowth(growthResult.data);
      }
    } catch (error) {
      console.error('Error fetching analytics:', error);
    }
    setIsLoadingAnalytics(false);
  };

  const fetchFeedback = async () => {
    setIsLoadingFeedback(true);
    try {
      // Fetch feedback stats using direct table access
      try {
        // Fallback: try direct table access with any type
        const { count: totalCount } = await (supabase as any)
          .from('feedback')
          .select('*', { count: 'exact', head: true });

        const { count: followupCount } = await (supabase as any)
          .from('feedback')
          .select('*', { count: 'exact', head: true })
          .eq('allow_followup', true);

        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

        const { count: recentCount } = await (supabase as any)
          .from('feedback')
          .select('*', { count: 'exact', head: true })
          .gte('created_at', sevenDaysAgo.toISOString());

        const { data: typeData } = await (supabase as any)
          .from('feedback')
          .select('feedback_type');

        const stats: FeedbackStats = {
          total: totalCount || 0,
          by_type: {
            bug: typeData?.filter((t: any) => t.feedback_type === 'bug').length || 0,
            feature: typeData?.filter((t: any) => t.feedback_type === 'feature').length || 0,
            general: typeData?.filter((t: any) => t.feedback_type === 'general').length || 0,
            support: typeData?.filter((t: any) => t.feedback_type === 'support').length || 0
          },
          with_followup: followupCount || 0,
          recent_count: recentCount || 0
        };

        setFeedbackStats(stats);
      } catch (statsError) {
        // If feedback table doesn't exist yet, set empty stats
        setFeedbackStats({
          total: 0,
          by_type: { bug: 0, feature: 0, general: 0, support: 0 },
          with_followup: 0,
          recent_count: 0
        });
      }

      // Fetch feedback list
      let query = (supabase as any)
        .from('feedback')
        .select(`
          *,
          users!feedback_user_id_fkey (
            name,
            email
          )
        `)
        .order('created_at', { ascending: false })
        .limit(20);

      if (feedbackFilter !== 'all') {
        query = query.eq('feedback_type', feedbackFilter);
      }

      const { data: feedbackData, error } = await query;

      if (error) throw new Error(error.message);

      const transformedData = feedbackData?.map((item: any) => ({
        ...item,
        user_name: item.users?.name || 'Anonymous',
        user_email: item.users?.email || null
      })) || [];

      setFeedback(transformedData);
    } catch (error) {
      console.error('Error fetching feedback:', error);
      // Set empty stats on error
      setFeedbackStats({
        total: 0,
        by_type: { bug: 0, feature: 0, general: 0, support: 0 },
        with_followup: 0,
        recent_count: 0
      });
      setFeedback([]);
    }
    setIsLoadingFeedback(false);
  };

  const handleLogout = () => {
    sessionStorage.removeItem('admin_authenticated');
    navigate('/admin/login');
  };

  const showConfirmation = (operation: string, message: string, onConfirm: () => void) => {
    setConfirmDialog({
      open: true,
      operation,
      message,
      onConfirm,
    });
  };

  const runOperation = async (operation: 'add-reviews' | 'refresh-amenities' | 'enrich-cafes') => {
    const opKey = operation === 'add-reviews' ? 'addReviews' : 
                   operation === 'refresh-amenities' ? 'refreshAmenities' : 'enrichCafes';
    
    // Track admin action
    trackAdminAction(operation, { 
      total_cafes: stats.totalCafes,
      estimated_cost: (stats.totalCafes * 0.017).toFixed(2)
    });
    
    setOperations(prev => ({ ...prev, [opKey]: true }));
    setLastResult(null);

    try {
      const { data, error } = await supabase.functions.invoke(operation, {
        body: { action: 'start' }
      });

      if (error) throw error;

      setLastResult(data as OperationResult);

      if (data.success) {
        const stats = data.stats;
        const details = stats 
          ? `Processed: ${stats.processed} | Success: ${stats.succeeded} | Failed: ${stats.failed}${stats.reviewsAdded ? ` | Reviews: ${stats.reviewsAdded}` : ''} | API Calls: ${stats.apiCalls} | Cost: $${stats.estimatedCost.toFixed(2)}`
          : data.message;

        toast({
          title: 'Operation completed',
          description: details,
        });
      } else {
        toast({
          title: 'Operation failed',
          description: data.message || data.error || 'An error occurred',
          variant: 'destructive',
        });
      }

      await fetchStats();
    } catch (error: any) {
      console.error('Operation error:', error);
      toast({
        title: 'Operation failed',
        description: error.message || error.error || 'Edge Function not found. Please create the required Edge Functions.',
        variant: 'destructive',
      });
    } finally {
      setOperations(prev => ({ ...prev, [opKey]: false }));
    }
  };

  const runFullEnrichment = async () => {
    setOperations(prev => ({ ...prev, fullEnrichment: true }));
    setLastResult(null);
    
    try {
      toast({ title: 'Starting reviews...', description: 'Fetching reviews from Google Places' });
      const reviewsResult = await supabase.functions.invoke('add-reviews', {
        body: { action: 'start' }
      });
      
      if (reviewsResult.error) throw new Error('Reviews failed: ' + reviewsResult.error.message);
      
      toast({ title: 'Starting amenities...', description: 'Refreshing amenities data' });
      const amenitiesResult = await supabase.functions.invoke('refresh-amenities', {
        body: { action: 'start' }
      });
      
      if (amenitiesResult.error) throw new Error('Amenities failed: ' + amenitiesResult.error.message);
      
      const reviewStats = reviewsResult.data?.stats;
      const amenitiesStats = amenitiesResult.data?.stats;
      
      toast({
        title: 'Full enrichment completed',
        description: `Reviews: ${reviewStats?.processed || 0} caf√©s | Amenities: ${amenitiesStats?.processed || 0} caf√©s`,
      });
      
      await fetchStats();
    } catch (error: any) {
      toast({
        title: 'Full enrichment failed',
        description: error.message,
        variant: 'destructive',
      });
    } finally {
      setOperations(prev => ({ ...prev, fullEnrichment: false }));
    }
  };

  const estimatedCost = (stats.totalCafes * 0.017).toFixed(2);
  const apiKeyConfigured = true; // Simplified - assuming configured

  return (
    <div className="min-h-screen bg-background">
      <header className="border-b">
        <div className="container mx-auto px-4 py-4 flex justify-between items-center">
          <h1 className="text-2xl font-bold">BeanScene Admin Dashboard</h1>
          <Button onClick={handleLogout} variant="outline">
            <LogOut className="mr-2 h-4 w-4" />
            Logout
          </Button>
        </div>
      </header>

      <main className="container mx-auto px-4 py-8 space-y-6">
        {/* Analytics Dashboard */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <BarChart3 className="h-5 w-5" />
              Analytics Dashboard
            </CardTitle>
            <CardDescription>
              User engagement and activity metrics
            </CardDescription>
          </CardHeader>
          <CardContent>
            {isLoadingAnalytics ? (
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                {[...Array(8)].map((_, i) => (
                  <div key={i} className="animate-pulse">
                    <div className="h-4 bg-muted rounded w-24 mb-2"></div>
                    <div className="h-8 bg-muted rounded w-16"></div>
                  </div>
                ))}
              </div>
            ) : engagementMetrics ? (
              <div className="space-y-6">
                {/* Key Metrics */}
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <Users className="h-6 w-6 mx-auto mb-2 text-primary" />
                    <p className="text-sm text-muted-foreground">Total Users</p>
                    <p className="text-2xl font-bold">{engagementMetrics.totalUsers}</p>
                  </div>
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <Activity className="h-6 w-6 mx-auto mb-2 text-primary" />
                    <p className="text-sm text-muted-foreground">Daily Active</p>
                    <p className="text-2xl font-bold">{engagementMetrics.dau}</p>
                  </div>
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <TrendingUp className="h-6 w-6 mx-auto mb-2 text-primary" />
                    <p className="text-sm text-muted-foreground">Monthly Active</p>
                    <p className="text-2xl font-bold">{engagementMetrics.mau}</p>
                  </div>
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <Database className="h-6 w-6 mx-auto mb-2 text-primary" />
                    <p className="text-sm text-muted-foreground">Total Posts</p>
                    <p className="text-2xl font-bold">{engagementMetrics.totalPosts}</p>
                  </div>
                </div>

                {/* Engagement Stats */}
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <p className="text-sm text-muted-foreground">Check-ins</p>
                    <p className="text-2xl font-bold">{engagementMetrics.totalCheckins}</p>
                  </div>
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <p className="text-sm text-muted-foreground">Reviews</p>
                    <p className="text-2xl font-bold">{engagementMetrics.totalReviews}</p>
                  </div>
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <p className="text-sm text-muted-foreground">Avg Rating</p>
                    <p className="text-2xl font-bold">{engagementMetrics.averageRating}</p>
                  </div>
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <p className="text-sm text-muted-foreground">Engagement Rate</p>
                    <p className="text-2xl font-bold">
                      {engagementMetrics.totalUsers > 0 
                        ? Math.round((engagementMetrics.mau / engagementMetrics.totalUsers) * 100)
                        : 0}%
                    </p>
                  </div>
                </div>

                {/* Daily Active Users Chart */}
                {dailyActiveUsers.length > 0 && (
                  <div className="space-y-4">
                    <h3 className="text-lg font-semibold">Daily Active Users (Last 30 Days)</h3>
                    <div className="h-64">
                      <ResponsiveContainer width="100%" height="100%">
                        <LineChart data={dailyActiveUsers}>
                          <CartesianGrid strokeDasharray="3 3" />
                          <XAxis 
                            dataKey="date" 
                            tickFormatter={(value) => new Date(value).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
                          />
                          <YAxis />
                          <Tooltip 
                            labelFormatter={(value) => new Date(value).toLocaleDateString()}
                            formatter={(value) => [value, 'Active Users']}
                          />
                          <Line 
                            type="monotone" 
                            dataKey="count" 
                            stroke="#8B5CF6" 
                            strokeWidth={2}
                            dot={{ fill: '#8B5CF6', strokeWidth: 2, r: 4 }}
                          />
                        </LineChart>
                      </ResponsiveContainer>
                    </div>
                  </div>
                )}

                {/* User Growth Chart */}
                {userGrowth.length > 0 && (
                  <div className="space-y-4">
                    <h3 className="text-lg font-semibold">User Growth (Last 30 Days)</h3>
                    <div className="h-64">
                      <ResponsiveContainer width="100%" height="100%">
                        <LineChart data={userGrowth}>
                          <CartesianGrid strokeDasharray="3 3" />
                          <XAxis 
                            dataKey="date" 
                            tickFormatter={(value) => new Date(value).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
                          />
                          <YAxis />
                          <Tooltip 
                            labelFormatter={(value) => new Date(value).toLocaleDateString()}
                            formatter={(value, name) => [
                              value, 
                              name === 'totalUsers' ? 'Total Users' : 'New Users'
                            ]}
                          />
                          <Line 
                            type="monotone" 
                            dataKey="totalUsers" 
                            stroke="#8B5CF6" 
                            strokeWidth={2}
                            dot={{ fill: '#8B5CF6', strokeWidth: 2, r: 4 }}
                          />
                          <Line 
                            type="monotone" 
                            dataKey="newUsers" 
                            stroke="#10B981" 
                            strokeWidth={2}
                            dot={{ fill: '#10B981', strokeWidth: 2, r: 4 }}
                          />
                        </LineChart>
                      </ResponsiveContainer>
                    </div>
                  </div>
                )}
              </div>
            ) : (
              <div className="text-center py-8">
                <p className="text-muted-foreground">No analytics data available</p>
              </div>
            )}
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <TrendingUp className="h-5 w-5" />
              Google Places Data Enrichment
            </CardTitle>
            <CardDescription>
              Fetch and update caf√© data from Google Places API
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center gap-2 mb-4">
              <span className="text-sm text-muted-foreground">Est. cost: ~${estimatedCost} for all caf√©s</span>
            </div>

            <div className="grid gap-3">
              <Button
                onClick={() => showConfirmation(
                  'Add Reviews',
                  `This will fetch reviews from Google Places for ${stats.totalCafes} caf√©s. Estimated cost: $${estimatedCost}. Continue?`,
                  () => runOperation('add-reviews')
                )}
                disabled={operations.addReviews}
                className="w-full justify-start"
              >
                {operations.addReviews ? 'Adding Reviews...' : 'Add Reviews from Google Places'}
              </Button>

              <Button
                onClick={() => showConfirmation(
                  'Refresh Amenities',
                  `This will refresh amenities for ${stats.totalCafes} caf√©s. Estimated cost: $${estimatedCost}. Continue?`,
                  () => runOperation('refresh-amenities')
                )}
                disabled={operations.refreshAmenities}
                className="w-full justify-start"
              >
                {operations.refreshAmenities ? 'Refreshing Amenities...' : 'Refresh Amenities & Hours'}
              </Button>

              <Button
                onClick={() => showConfirmation(
                  'Full Enrichment',
                  `This will run both reviews and amenities operations. Estimated cost: $${(parseFloat(estimatedCost) * 2).toFixed(2)}. Continue?`,
                  runFullEnrichment
                )}
                disabled={operations.fullEnrichment}
                variant="secondary"
                className="w-full justify-start"
              >
                {operations.fullEnrichment ? 'Running Full Enrichment...' : 'Full Enrichment (Reviews + Amenities)'}
              </Button>
            </div>

            {lastResult && lastResult.errors && lastResult.errors.length > 0 && (
              <div className="mt-4 p-4 border border-destructive/50 rounded-lg bg-destructive/10">
                <div className="flex items-start gap-2 mb-2">
                  <AlertCircle className="h-5 w-5 text-destructive mt-0.5" />
                  <div>
                    <p className="font-medium text-destructive">Failed Caf√©s ({lastResult.errors.length})</p>
                    <div className="mt-2 space-y-1 text-sm">
                      {lastResult.errors.slice(0, 5).map((err, i) => (
                        <p key={i} className="text-muted-foreground">
                          ‚Ä¢ {err.cafe}: {err.error}
                        </p>
                      ))}
                      {lastResult.errors.length > 5 && (
                        <p className="text-muted-foreground">...and {lastResult.errors.length - 5} more</p>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            )}
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <MapPin className="h-5 w-5" />
              Enrich Missing Caf√© Data
            </CardTitle>
            <CardDescription>
              Update caf√©s missing opening hours, phone numbers, and other details
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground mb-3">
              {stats.cafesNeedingEnrichment} caf√©s need enrichment
            </p>
            <Button
              onClick={() => showConfirmation(
                'Enrich Missing Data',
                `This will enrich ${stats.cafesNeedingEnrichment} caf√©s missing data. Estimated cost: $${(stats.cafesNeedingEnrichment * 0.017).toFixed(2)}. Continue?`,
                () => runOperation('enrich-cafes')
              )}
              disabled={operations.enrichCafes || stats.cafesNeedingEnrichment === 0}
              className="w-full"
            >
              {operations.enrichCafes ? 'Enriching Caf√©s...' : 'Run Enrichment Script'}
            </Button>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Database className="h-5 w-5" />
              Database Statistics
            </CardTitle>
            <CardDescription>Current state of caf√© data</CardDescription>
          </CardHeader>
          <CardContent>
            {isLoadingStats ? (
              <div className="grid grid-cols-2 gap-4">
                {[...Array(6)].map((_, i) => (
                  <div key={i} className="animate-pulse">
                    <div className="h-4 bg-muted rounded w-24 mb-2"></div>
                    <div className="h-8 bg-muted rounded w-16"></div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <p className="text-sm text-muted-foreground">Total Caf√©s</p>
                  <p className="text-2xl font-bold">{stats.totalCafes}</p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">With Opening Hours</p>
                  <p className="text-2xl font-bold">{stats.cafesWithHours} / {stats.totalCafes}</p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">With Parking Info</p>
                  <p className="text-2xl font-bold">{stats.cafesWithParking} / {stats.totalCafes}</p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">With Phone Numbers</p>
                  <p className="text-2xl font-bold">{stats.cafesWithPhone} / {stats.totalCafes}</p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">With Websites</p>
                  <p className="text-2xl font-bold">{stats.cafesWithWebsite} / {stats.totalCafes}</p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Total Reviews</p>
                  <p className="text-2xl font-bold">{stats.totalReviews}</p>
                </div>
              </div>
            )}
          </CardContent>
        </Card>

        {/* User Feedback Management */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <MessageSquare className="h-5 w-5" />
              User Feedback
            </CardTitle>
            <CardDescription>
              Manage user feedback and support requests
            </CardDescription>
          </CardHeader>
          <CardContent>
            {isLoadingFeedback ? (
              <div className="space-y-4">
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                  {[...Array(4)].map((_, i) => (
                    <div key={i} className="animate-pulse">
                      <div className="h-4 bg-muted rounded w-20 mb-2"></div>
                      <div className="h-8 bg-muted rounded w-12"></div>
                    </div>
                  ))}
                </div>
              </div>
            ) : feedbackStats ? (
              <div className="space-y-6">
                {/* Feedback Stats */}
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <MessageSquare className="h-6 w-6 mx-auto mb-2 text-primary" />
                    <p className="text-sm text-muted-foreground">Total Feedback</p>
                    <p className="text-2xl font-bold">{feedbackStats.total}</p>
                  </div>
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <Mail className="h-6 w-6 mx-auto mb-2 text-primary" />
                    <p className="text-sm text-muted-foreground">Follow-up Requests</p>
                    <p className="text-2xl font-bold">{feedbackStats.with_followup}</p>
                  </div>
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <Calendar className="h-6 w-6 mx-auto mb-2 text-primary" />
                    <p className="text-sm text-muted-foreground">This Week</p>
                    <p className="text-2xl font-bold">{feedbackStats.recent_count}</p>
                  </div>
                  <div className="text-center p-4 bg-muted/50 rounded-lg">
                    <AlertCircle className="h-6 w-6 mx-auto mb-2 text-primary" />
                    <p className="text-sm text-muted-foreground">Bug Reports</p>
                    <p className="text-2xl font-bold">{feedbackStats.by_type.bug}</p>
                  </div>
                </div>

                {/* Feedback Type Breakdown */}
                <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
                  <div className="text-center p-3 bg-red-50 rounded-lg">
                    <p className="text-sm text-red-600 font-medium">Bug Reports</p>
                    <p className="text-lg font-bold text-red-700">{feedbackStats.by_type.bug}</p>
                  </div>
                  <div className="text-center p-3 bg-blue-50 rounded-lg">
                    <p className="text-sm text-blue-600 font-medium">Feature Requests</p>
                    <p className="text-lg font-bold text-blue-700">{feedbackStats.by_type.feature}</p>
                  </div>
                  <div className="text-center p-3 bg-green-50 rounded-lg">
                    <p className="text-sm text-green-600 font-medium">General</p>
                    <p className="text-lg font-bold text-green-700">{feedbackStats.by_type.general}</p>
                  </div>
                  <div className="text-center p-3 bg-purple-50 rounded-lg">
                    <p className="text-sm text-purple-600 font-medium">Support</p>
                    <p className="text-lg font-bold text-purple-700">{feedbackStats.by_type.support}</p>
                  </div>
                </div>

                {/* Feedback Filter and List */}
                <div className="space-y-4">
                  <div className="flex items-center gap-4">
                    <Select value={feedbackFilter} onValueChange={setFeedbackFilter}>
                      <SelectTrigger className="w-48">
                        <SelectValue placeholder="Filter by type" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="all">All Types</SelectItem>
                        <SelectItem value="bug">Bug Reports</SelectItem>
                        <SelectItem value="feature">Feature Requests</SelectItem>
                        <SelectItem value="general">General Feedback</SelectItem>
                        <SelectItem value="support">Support</SelectItem>
                      </SelectContent>
                    </Select>
                    <Button onClick={fetchFeedback} variant="outline" size="sm">
                      <Filter className="h-4 w-4 mr-2" />
                      Refresh
                    </Button>
                  </div>

                  {/* Feedback List */}
                  <div className="space-y-3 max-h-96 overflow-y-auto">
                    {feedback.length === 0 ? (
                      <p className="text-center text-muted-foreground py-8">No feedback found</p>
                    ) : (
                      feedback.map((item) => (
                        <div key={item.id} className="border rounded-lg p-4 space-y-2">
                          <div className="flex items-start justify-between">
                            <div className="flex-1">
                              <div className="flex items-center gap-2 mb-1">
                                <Badge variant={
                                  item.feedback_type === 'bug' ? 'destructive' :
                                  item.feedback_type === 'feature' ? 'default' :
                                  item.feedback_type === 'support' ? 'secondary' : 'outline'
                                }>
                                  {item.feedback_type}
                                </Badge>
                                <span className="text-sm text-muted-foreground">
                                  {new Date(item.created_at).toLocaleDateString()}
                                </span>
                              </div>
                              <h4 className="font-medium">{item.subject}</h4>
                              <p className="text-sm text-muted-foreground line-clamp-2">
                                {item.details}
                              </p>
                            </div>
                            {item.allow_followup && item.contact_email && (
                              <div className="text-right">
                                <Badge variant="outline" className="text-xs">
                                  <Mail className="h-3 w-3 mr-1" />
                                  Follow-up
                                </Badge>
                                <p className="text-xs text-muted-foreground mt-1">
                                  {item.contact_email}
                                </p>
                              </div>
                            )}
                          </div>
                          <div className="flex items-center justify-between text-xs text-muted-foreground">
                            <span>From: {item.user_name || 'Anonymous'}</span>
                            <span>ID: {item.id.slice(0, 8)}...</span>
                          </div>
                        </div>
                      ))
                    )}
                  </div>
                </div>
              </div>
            ) : (
              <p className="text-center text-muted-foreground py-8">Failed to load feedback</p>
            )}
          </CardContent>
        </Card>
      </main>

      <AlertDialog open={confirmDialog.open} onOpenChange={(open) => setConfirmDialog(prev => ({ ...prev, open }))}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirm {confirmDialog.operation}</AlertDialogTitle>
            <AlertDialogDescription>
              {confirmDialog.message}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={() => {
              confirmDialog.onConfirm();
              setConfirmDialog(prev => ({ ...prev, open: false }));
            }}>
              Continue
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

================
File: src/pages/admin/Login.tsx
================
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { useToast } from '@/hooks/use-toast';

export default function AdminLogin() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const navigate = useNavigate();
  const { toast } = useToast();

  const handleLogin = (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);

    // Hardcoded credentials - replace with your preferred credentials
    if (username === 'admin' && password === 'beanscene2024') {
      sessionStorage.setItem('admin_authenticated', 'true');
      toast({
        title: 'Login successful',
        description: 'Welcome to the admin dashboard',
      });
      navigate('/admin/dashboard');
    } else {
      toast({
        title: 'Login failed',
        description: 'Invalid username or password',
        variant: 'destructive',
      });
    }
    
    setIsLoading(false);
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-background p-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>BeanScene Admin Login</CardTitle>
          <CardDescription>Enter your credentials to access the admin dashboard</CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleLogin} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="username">Username</Label>
              <Input
                id="username"
                type="text"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                required
                autoComplete="username"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                autoComplete="current-password"
              />
            </div>
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? 'Logging in...' : 'Login'}
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

================
File: src/pages/CafeDetail.tsx
================
import { CafePhotoUpload } from "@/components/Cafe/CafePhotoUpload";
import { CafeReviews } from "@/components/Cafe/CafeReviews";
import { useState, useEffect, useCallback } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { ArrowLeft, Share2, Heart, Camera } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { AppLayout } from "@/components/Layout/AppLayout";
import { CafeHeader } from "@/components/Cafe/CafeHeader";
import { PostCard } from "@/components/Feed/PostCard";
import { fetchCafeDetails } from "@/services/cafeService";
import { fetchCafePostsById } from "@/services/postService";
import { addToRecentlyViewed } from "@/pages/RecentlyViewed";
import { addFavorite, removeFavorite, isFavorited } from "@/services/favoritesService";
import { logActivity } from "@/services/activityService";
import { toast } from "@/hooks/use-toast";
import type { Cafe, Post } from "@/services/types";

export default function CafeDetail() {
  const navigate = useNavigate();
  const { id: placeId } = useParams<{ id: string }>();
  const [activeTab, setActiveTab] = useState("posts");
  const [cafe, setCafe] = useState<Cafe | null>(null);
  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isFavoritedState, setIsFavoritedState] = useState(false);
  const [favoriteLoading, setFavoriteLoading] = useState(false);

  // Load cafe details and posts
  const loadCafeData = useCallback(async () => {
    if (!placeId) {
      setError("Cafe not found");
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      setError(null);

      const [cafeResult, postsResult] = await Promise.all([
        fetchCafeDetails(placeId),
        fetchCafePostsById(placeId),
      ]);

      if (cafeResult.success && cafeResult.data) {
        setCafe(cafeResult.data);
        // Check if cafe is favorited
        const favoriteResult = await isFavorited(cafeResult.data.id);
        if (favoriteResult.success) {
          setIsFavoritedState(favoriteResult.data);
        }
      } else {
        setError(cafeResult.error || "Cafe not found");
        return;
      }

      if (postsResult.success) {
        setPosts(postsResult.data);
      } else {
        console.error("Failed to load posts:", postsResult.error);
        // Don't show error for posts, just log it
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to load cafe";
      setError(errorMessage);
      toast({
        title: "Error",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  }, [placeId]);

  useEffect(() => {
    loadCafeData();
  }, [loadCafeData]);

  // Add to recently viewed when cafe data loads
  useEffect(() => {
    if (cafe) {
      addToRecentlyViewed({
        id: cafe.id,
        placeId: cafe.placeId,
        name: cafe.name,
        neighborhood: cafe.neighborhood,
        rating: cafe.googleRating || cafe.rating,
        tags: cafe.tags,
        image: cafe.heroPhotoUrl || cafe.photos?.[0] || "/placeholder.svg",
        priceLevel: cafe.priceLevel,
      });
    }
  }, [cafe]);

  // Handle favorite toggle
  const handleFavoriteToggle = async () => {
    if (!cafe || favoriteLoading) return;
    
    setFavoriteLoading(true);
    try {
      if (isFavoritedState) {
        const result = await removeFavorite(cafe.id);
        if (result.success) {
          setIsFavoritedState(false);
          toast({
            title: "Removed from favorites",
            description: `${cafe.name} has been removed from your favorites`
          });
        } else {
          toast({
            title: "Error",
            description: result.error || "Failed to remove favorite",
            variant: "destructive"
          });
        }
      } else {
        const result = await addFavorite(cafe.id);
        if (result.success) {
          setIsFavoritedState(true);
          toast({
            title: "Added to favorites",
            description: `${cafe.name} has been added to your favorites`
          });
          // Log activity
          await logActivity('favorite', cafe.id, { cafeName: cafe.name });
        } else {
          toast({
            title: "Error",
            description: result.error || "Failed to add favorite",
            variant: "destructive"
          });
        }
      }
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to update favorite",
        variant: "destructive"
      });
    } finally {
      setFavoriteLoading(false);
    }
  };

  if (loading) {
    return (
      <AppLayout>
        <div className="max-w-md mx-auto min-h-screen bg-background flex items-center justify-center">
          <div className="text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
            <p className="text-muted-foreground">Loading cafe details...</p>
          </div>
        </div>
      </AppLayout>
    );
  }

  if (error || !cafe) {
    return (
      <AppLayout>
        <div className="max-w-md mx-auto min-h-screen bg-background flex items-center justify-center">
          <div className="text-center p-6">
            <h2 className="text-xl font-semibold mb-2">Cafe Not Found</h2>
            <p className="text-muted-foreground mb-4">{error || "This cafe could not be found."}</p>
            <Button onClick={() => navigate("/explore")}>Back to Explore</Button>
          </div>
        </div>
      </AppLayout>
    );
  }

  return (
    <AppLayout showBottomNav={false}>
      <div className="max-w-md mx-auto min-h-screen bg-background">
        {/* Sticky Header */}
        <div className="sticky top-0 z-50 bg-background/95 backdrop-blur-md border-b border-border p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <Button
                variant="ghost"
                size="icon"
                onClick={() => navigate(-1)}
                className="rounded-full"
              >
                <ArrowLeft className="w-5 h-5" />
              </Button>
              <div className="min-w-0 flex-1">
                <h1 className="text-lg font-semibold truncate">{cafe.name}</h1>
                <p className="text-sm text-muted-foreground">{cafe.neighborhood}</p>
              </div>
            </div>

            <div className="flex items-center gap-2">
              <Button 
                variant="ghost" 
                size="icon" 
                className="rounded-full"
                onClick={handleFavoriteToggle}
                disabled={favoriteLoading}
              >
                <Heart className={`w-5 h-5 ${isFavoritedState ? 'fill-red-500 text-red-500' : ''}`} />
              </Button>
              <Button variant="ghost" size="icon" className="rounded-full">
                <Share2 className="w-5 h-5" />
              </Button>
            </div>
          </div>
        </div>

        {/* Cafe Header */}
        <div className="p-6">
          <CafeHeader
            cafe={{
              id: cafe.id,
              placeId: cafe.placeId,
              name: cafe.name,
              address: cafe.address,
              neighborhood: cafe.neighborhood,
              rating: cafe.googleRating || 0,
              userRating: cafe.rating || 0,
              hours: cafe.openingHours?.[0] || "Hours not available",
              phone: cafe.phoneNumber,
              website: cafe.website,
              priceLevel: cafe.priceLevel || 2,
              topTags: cafe.tags?.slice(0, 3) || [],
              reviewSnippet: "",
              heroImage: cafe.heroPhotoUrl || cafe.photos?.[0],
            }}
            loading={false}
            onPhotoAdded={(photoUrl) => {
              // Update the cafe state so the image appears immediately
              setCafe(prev => prev ? { ...prev, heroPhotoUrl: photoUrl } : prev);
            }}
          />
        </div>

        {/* Content Tabs */}
        <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
          <TabsList className="grid w-full grid-cols-4 bg-muted/50 mx-4 mt-4">
            <TabsTrigger value="posts">Posts ({posts.length})</TabsTrigger>
            <TabsTrigger value="reviews">Reviews</TabsTrigger>
            <TabsTrigger value="photos">Photos</TabsTrigger>
            <TabsTrigger value="info">Info</TabsTrigger>
          </TabsList>

          <TabsContent value="posts" className="p-4 space-y-6">
            {posts.length > 0 ? (
              posts.map((post) => (
                <PostCard 
                  key={post.id} 
                  post={{
                    id: post.id,
                    cafeName: cafe.name, // Use cafe name from current cafe
                    neighborhood: cafe.neighborhood, // Use neighborhood from current cafe
                    imageUrl: post.imageUrl,
                    tags: post.tags || [],
                    rating: post.rating || 0,
                    textReview: post.textReview || "",
                    createdAt: new Date(post.createdAt).toLocaleString(),
                    likes: post.likes || 0,
                    comments: post.comments || 0,
                    username: post.username
                  }} 
                />
              ))
            ) : (
              <div className="text-center py-12">
                <Camera className="w-12 h-12 mx-auto text-muted-foreground mb-4" />
                <h3 className="text-lg font-semibold mb-2">No posts yet</h3>
                <p className="text-muted-foreground mb-4">
                  Be the first to check in at {cafe.name}!
                </p>
                <Button 
                  onClick={() => navigate('/checkin')}
                  className="coffee-gradient text-white"
                >
                  Check In
                </Button>
              </div>
            )}
          </TabsContent>

          <TabsContent value="reviews" className="p-4">
            <CafeReviews cafeId={cafe.id} maxReviews={10} />
          </TabsContent>

          <TabsContent value="photos" className="p-4">
            <div className="grid grid-cols-2 gap-2">
              {cafe.photos && cafe.photos.length > 0 ? (
                cafe.photos.map((photo, i) => (
                  <div
                    key={i}
                    className="aspect-square bg-muted rounded-lg overflow-hidden"
                  >
                    <img 
                      src={photo} 
                      alt={`${cafe.name} photo ${i + 1}`}
                      className="w-full h-full object-cover"
                    />
                  </div>
                ))
              ) : (
                <div className="col-span-2 text-center py-12">
                  <Camera className="w-12 h-12 mx-auto text-muted-foreground mb-4" />
                  <h3 className="text-lg font-semibold mb-2">No photos yet</h3>
                  <p className="text-muted-foreground mb-4">
                    Be the first to add photos of {cafe.name}!
                  </p>
                </div>
              )}
            </div>
          </TabsContent>

          <TabsContent value="info" className="p-4 space-y-4">
            
            <div className="bg-card rounded-lg p-4 shadow-coffee border border-border">
              <h3 className="font-semibold mb-2">Hours</h3>
              <div className="space-y-1 text-sm">
                {cafe.openingHours && cafe.openingHours.length > 0 ? (
                  cafe.openingHours.slice(0, 7).map((hour, i) => (
                    <div key={i} className="flex justify-between">
                      <span className="text-muted-foreground">
                        {['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'][i]}
                      </span>
                      <span>{hour}</span>
                    </div>
                  ))
                ) : (
                  <p className="text-muted-foreground">Hours not available</p>
                )}
              </div>
            </div>

            {cafe.tags && cafe.tags.length > 0 && (
              <div className="bg-card rounded-lg p-4 shadow-coffee border border-border">
                <h3 className="font-semibold mb-2">Popular Tags</h3>
                <div className="flex flex-wrap gap-2">
                  {cafe.tags.map((tag) => (
                    <span
                      key={tag}
                      className="px-2 py-1 bg-primary/10 text-primary text-xs rounded-full"
                    >
                      #{tag}
                    </span>
                  ))}
                </div>
              </div>
            )}
          </TabsContent>
        </Tabs>

        {/* Floating Check-in Button */}
        <div className="fixed bottom-6 right-6 z-50">
          <Button
            size="lg"
            className="coffee-gradient text-white shadow-glow rounded-full w-14 h-14"
            onClick={() => navigate('/checkin')}
          >
            <Camera className="w-6 h-6" />
          </Button>
        </div>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/CheckIn.tsx
================
import { useState, useEffect } from "react";
import { Camera, MapPin, Star, Plus, X, Loader2, RefreshCw } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { AppLayout } from "@/components/Layout/AppLayout";
import { useNavigate, useLocation } from "react-router-dom";
import { useToast } from "@/hooks/use-toast";
import { fetchCafes } from "@/services/cafeService";
import { submitCheckin } from "@/services/postService";
import { getCurrentLocation } from "@/services/utils";
import { getNearbyCafes, formatDistance } from "@/utils/distanceUtils";
import { useGoogleAnalytics } from "@/hooks/use-google-analytics";
import type { Cafe } from "@/services/types";

const predefinedTags = [
  "latte-art", "cozy-vibes", "laptop-friendly", "third-wave", "cold-brew",
  "pastries", "rooftop", "instagram-worthy", "busy", "quiet", "date-spot",
  "pet-friendly", "outdoor-seating", "wifi", "study-spot"
];

export default function CheckIn() {
  const navigate = useNavigate();
  const location = useLocation();
  const { toast } = useToast();
  const { trackCheckIn, trackEngagement, trackError } = useGoogleAnalytics();
  const [selectedCafe, setSelectedCafe] = useState<string>("");
  const [rating, setRating] = useState<number>(0);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [customTag, setCustomTag] = useState("");
  const [review, setReview] = useState("");
  const [imageFile, setImageFile] = useState<File | null>(null);
  const [nearbyCafes, setNearbyCafes] = useState<(Cafe & { distance: number })[]>([]);
  const [isLoadingLocation, setIsLoadingLocation] = useState(false);
  const [isLoadingCafes, setIsLoadingCafes] = useState(false);
  const [locationError, setLocationError] = useState<string | null>(null);
  const [userLocation, setUserLocation] = useState<{ lat: number; lng: number } | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [allCafes, setAllCafes] = useState<Cafe[]>([]);

  const handleTagToggle = (tag: string) => {
    const isAdding = !selectedTags.includes(tag);
    setSelectedTags(prev => 
      prev.includes(tag) 
        ? prev.filter(t => t !== tag)
        : [...prev, tag]
    );
    
    // Track tag interaction
    trackEngagement('tag_interaction', {
      action: isAdding ? 'add_tag' : 'remove_tag',
      tag,
      total_tags: isAdding ? selectedTags.length + 1 : selectedTags.length - 1,
    });
  };

  const handleCustomTag = () => {
    if (customTag && !selectedTags.includes(customTag)) {
      setSelectedTags(prev => [...prev, customTag]);
      trackEngagement('custom_tag_created', {
        tag: customTag,
        total_tags: selectedTags.length + 1,
      });
      setCustomTag("");
    }
  };

  const handleImageUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      setImageFile(file);
      trackEngagement('image_uploaded', {
        file_size: file.size,
        file_type: file.type,
      });
    }
  };

  // Helper: get query param
  function getQueryParam(param: string): string | null {
    const params = new URLSearchParams(location.search);
    return params.get(param);
  }

  // Load all cafes for distance calculation
  const loadAllCafes = async () => {
    const result = await fetchCafes({});
    if (result.success && result.data) {
      setAllCafes(result.data);
    }
  };

  // Strict geo-only location request
  const requestLocation = async () => {
    setIsLoadingLocation(true);
    setLocationError(null);
    setNearbyCafes([]);
    
    try {
      const position = await getCurrentLocation();
      const { latitude, longitude } = position.coords;
      setUserLocation({ lat: latitude, lng: longitude });
      
      // Calculate distances and get 10 closest cafes
      setIsLoadingCafes(true);
      const nearby = getNearbyCafes(latitude, longitude, allCafes, 50, 10);
      
      if (nearby.length > 0) {
        setNearbyCafes(nearby);
        setLocationError(null);
      } else {
        setLocationError("No nearby cafes found.");
        setNearbyCafes([]);
      }
    } catch (error: any) {
      setLocationError("No nearby cafes found.");
      setNearbyCafes([]);
      setUserLocation(null);
    } finally {
      setIsLoadingLocation(false);
      setIsLoadingCafes(false);
    }
  };

  // On mount: load cafes first, then request location
  useEffect(() => {
    const initializeCheckIn = async () => {
      await loadAllCafes();
      // Don't auto-request location - user must click "Select Cafe" button
    };
    initializeCheckIn();
  }, []);

  // Auto-select cafe if coming from detail page
  useEffect(() => {
    const cafeId = getQueryParam('cafeId');
    const placeId = getQueryParam('placeId');
    if (cafeId && placeId && nearbyCafes.length > 0) {
      setSelectedCafe(cafeId);
    }
  }, [nearbyCafes]);


  const handleSubmit = async () => {
    if (!selectedCafe || !rating) return;
    setIsSubmitting(true);
    let coords: { latitude: number; longitude: number } | null = null;
    try {
      // Always get fresh coordinates at submission
      const position = await getCurrentLocation();
      coords = {
        latitude: position.coords.latitude,
        longitude: position.coords.longitude,
      };
    } catch (error: any) {
      toast({
        title: "Error",
        description: "Location permission denied or unavailable. Please enable location and try again.",
        variant: "destructive"
      });
      setIsSubmitting(false);
      return;
    }
    try {
      const selectedCafeData = nearbyCafes.find(cafe => cafe.id === selectedCafe);
      if (!selectedCafeData) {
        toast({
          title: "Error",
          description: "Selected cafe not found",
          variant: "destructive"
        });
        setIsSubmitting(false);
        return;
      }
      const result = await submitCheckin({
        cafeId: selectedCafe,
        placeId: selectedCafeData.placeId,
        rating,
        tags: selectedTags,
        review: review,
        imageFile,
        location: coords ? { latitude: coords.latitude, longitude: coords.longitude } : undefined,
      });
      if (result.success) {
        // Track successful check-in
        trackCheckIn(selectedCafeData.name, selectedCafe, rating, !!imageFile, selectedTags.length);
        
        toast({
          title: "Check-in shared!",
          description: "Your cafe experience has been posted"
        });
        navigate('/explore');
      } else {
        trackError('checkin_submission_failed', result.error || 'Failed to share check-in', {
          cafe_id: selectedCafe,
          rating,
          has_image: !!imageFile,
          tag_count: selectedTags.length,
        });
        
        toast({
          title: "Error",
          description: result.error || "Failed to share check-in",
          variant: "destructive"
        });
      }
    } catch (error) {
      trackError('checkin_exception', 'Failed to share check-in', {
        cafe_id: selectedCafe,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      
      toast({
        title: "Error",
        description: "Failed to share check-in",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <AppLayout>
      <div className="max-w-md mx-auto min-h-screen bg-background pb-20">
        {/* Header */}
        <div className="sticky top-0 z-40 bg-background/95 backdrop-blur-md border-b border-border p-4">
          <h1 className="text-2xl font-bold">Check In</h1>
          <p className="text-sm text-muted-foreground">Share your cafe experience</p>
        </div>

        <div className="p-4 space-y-6">
          {/* Select Cafe */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <MapPin className="w-5 h-5 text-primary" />
                Select Cafe
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              {!userLocation && !isLoadingLocation && !locationError ? (
                <div className="text-center py-8">
                  <MapPin className="w-12 h-12 mx-auto mb-3 coffee-location-pin" />
                  <p className="text-sm text-muted-foreground mb-4">Find cafes near your location</p>
                  <Button 
                    onClick={requestLocation}
                    className="coffee-button"
                  >
                    <MapPin className="w-4 h-4 mr-2" />
                    Select Cafe
                  </Button>
                </div>
              ) : isLoadingLocation ? (
                <div className="flex items-center justify-center py-8">
                  <Loader2 className="w-6 h-6 animate-spin text-primary" />
                  <span className="ml-2 text-sm text-muted-foreground">Getting your location...</span>
                </div>
              ) : locationError ? (
                <div className="text-center py-8">
                  <MapPin className="w-12 h-12 mx-auto mb-3 coffee-location-pin" />
                  <p className="text-sm text-muted-foreground mb-4">{locationError}</p>
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={requestLocation}
                    className="coffee-interactive"
                  >
                    <RefreshCw className="w-4 h-4 mr-2" />
                    Try Again
                  </Button>
                </div>
              ) : isLoadingCafes ? (
                <div className="flex items-center justify-center py-8">
                  <Loader2 className="w-6 h-6 animate-spin text-primary" />
                  <span className="ml-2 text-sm text-muted-foreground">Finding nearby cafes...</span>
                </div>
              ) : (nearbyCafes.length > 0 ? (
                nearbyCafes.map((cafe) => (
                  <div
                    key={cafe.id}
                    onClick={() => setSelectedCafe(cafe.id)}
                    className={`p-3 rounded-lg border cursor-pointer transition-smooth ${
                      selectedCafe === cafe.id
                        ? "border-primary bg-primary/10"
                        : "border-border hover:bg-muted/50"
                    }`}
                  >
                    <div className="flex justify-between items-center">
                      <div>
                        <h3 className="font-medium">{cafe.name}</h3>
                        <p className="text-sm text-muted-foreground">{cafe.neighborhood}</p>
                      </div>
                      <span className="text-xs text-muted-foreground">{formatDistance(cafe.distance)}</span>
                    </div>
                    <Button onClick={() => navigate(`/checkin?cafeId=${cafe.id}&placeId=${cafe.placeId}`)} className="flex-1 coffee-gradient text-white mt-2">
                      Check In Here
                    </Button>
                  </div>
                ))
              ) : (
                <div className="text-center py-8">
                  <MapPin className="w-12 h-12 mx-auto mb-3 coffee-location-pin" />
                  <p className="text-sm text-muted-foreground">No nearby cafes found</p>
                </div>
              ))}
            </CardContent>
          </Card>

          {/* Photo Upload - Always visible */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Camera className="w-5 h-5 text-primary" />
                Add Photo (Optional)
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="border-2 border-dashed border-border rounded-lg p-8 text-center relative hover:border-primary/50 transition-colors">
                {imageFile ? (
                  <div className="space-y-3">
                    <div className="w-full h-32 bg-muted rounded-lg overflow-hidden">
                      <img 
                        src={URL.createObjectURL(imageFile)} 
                        alt="Preview" 
                        className="w-full h-full object-cover"
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <p className="text-sm text-foreground truncate flex-1 mr-2">{imageFile.name}</p>
                      <Button 
                        variant="ghost" 
                        size="sm"
                        onClick={() => setImageFile(null)}
                        className="text-destructive hover:text-destructive"
                      >
                        <X className="w-4 h-4" />
                      </Button>
                    </div>
                  </div>
                ) : (
                  <>
                    <Camera className="w-8 h-8 mx-auto text-muted-foreground mb-2" />
                    <p className="text-sm text-muted-foreground mb-1">Tap to add a photo</p>
                    <p className="text-xs text-muted-foreground">Share your cafe experience visually</p>
                    <input
                      type="file"
                      accept="image/*"
                      onChange={handleImageUpload}
                      className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                    />
                  </>
                )}
              </div>
            </CardContent>
          </Card>

          {/* Rating - Always visible */}
          <Card>
            <CardHeader>
              <CardTitle>Rate Your Experience</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="flex gap-2">
                {[1, 2, 3, 4, 5].map((star) => (
                  <button
                    key={star}
                    onClick={() => setRating(star)}
                    className="transition-smooth hover:scale-110"
                  >
                    <Star
                      className={`w-8 h-8 ${
                        star <= rating
                          ? "fill-yellow-400 text-yellow-400"
                          : "text-muted"
                      }`}
                    />
                  </button>
                ))}
              </div>
            </CardContent>
          </Card>

          {/* Tags */}
          <Card>
            <CardHeader>
              <CardTitle>Add Tags</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              {/* Selected Tags */}
              {selectedTags.length > 0 && (
                <div className="flex flex-wrap gap-2">
                  {selectedTags.map((tag) => (
                    <Badge
                      key={tag}
                      variant="secondary"
                      className="bg-primary/20 text-primary border-0 cursor-pointer"
                      onClick={() => handleTagToggle(tag)}
                    >
                      #{tag}
                      <X className="w-3 h-3 ml-1" />
                    </Badge>
                  ))}
                </div>
              )}

              {/* Predefined Tags */}
              <div className="flex flex-wrap gap-2">
                {predefinedTags.filter(tag => !selectedTags.includes(tag)).slice(0, 10).map((tag) => (
                  <Badge
                    key={tag}
                    variant="outline"
                    className="cursor-pointer hover:bg-accent transition-smooth"
                    onClick={() => handleTagToggle(tag)}
                  >
                    #{tag}
                  </Badge>
                ))}
              </div>

              {/* Custom Tag Input */}
              <div className="flex gap-2">
                <Input
                  placeholder="Create custom tag..."
                  value={customTag}
                  onChange={(e) => setCustomTag(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && handleCustomTag()}
                  className="flex-1"
                />
                <Button variant="outline" size="icon" onClick={handleCustomTag}>
                  <Plus className="w-4 h-4" />
                </Button>
              </div>
            </CardContent>
          </Card>

          {/* Review */}
          <Card>
            <CardHeader>
              <CardTitle>Write a Review</CardTitle>
            </CardHeader>
            <CardContent>
              <Textarea
                placeholder="Share your thoughts about this cafe..."
                value={review}
                onChange={(e) => setReview(e.target.value)}
                rows={4}
                className="resize-none"
              />
            </CardContent>
          </Card>

          {/* Submit Button */}
          <Button
            onClick={handleSubmit}
            disabled={!selectedCafe || !rating || isSubmitting}
            className="w-full coffee-gradient text-white shadow-coffee hover:shadow-glow transition-smooth"
            size="lg"
          >
            {isSubmitting ? (
              <>
                <Loader2 className="w-4 h-4 animate-spin mr-2" />
                Sharing...
              </>
            ) : (
              "Share Check-In"
            )}
          </Button>
        </div>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/CreatePost.tsx
================
import { useState, useRef } from "react";
import { Camera, X, Loader2, ArrowLeft } from "lucide-react";
import { AppLayout } from "@/components/Layout/AppLayout";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { useNavigate } from "react-router-dom";
import { fetchCafes } from "@/services/cafeService";
import { submitCheckin } from "@/services/postService";
import { getCurrentLocation } from "@/services/utils";
import { useToast } from "@/hooks/use-toast";
import { useGoogleAnalytics } from "@/hooks/use-google-analytics";

function getAnonId() {
  let id = localStorage.getItem("anonId");
  if (!id) {
    id = Math.random().toString(36).slice(2);
    localStorage.setItem("anonId", id);
  }
  return id;
}

export default function CreatePost() {
  const navigate = useNavigate();
  const { toast } = useToast();
  const { trackQuickPost, trackError, trackEngagement } = useGoogleAnalytics();
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [imageFile, setImageFile] = useState<File | null>(null);
  const [caption, setCaption] = useState("");
  const [cafeQuery, setCafeQuery] = useState("");
  const [cafeResults, setCafeResults] = useState<any[]>([]);
  const [selectedCafe, setSelectedCafe] = useState<any | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleCafeSearch() {
    setLoading(true);
    const result = await fetchCafes({ query: cafeQuery });
    setCafeResults(result.data || []);
    setLoading(false);
  }

  const handleImageUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      setImageFile(file);
      trackEngagement('quick_post_image_uploaded', {
        file_size: file.size,
        file_type: file.type,
      });
    }
  };

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError(null);
    
    if (!imageFile) {
      setError("Please add a photo to share");
      return;
    }
    
    if (!selectedCafe) {
      setError("Please select a cafe");
      return;
    }
    
    setLoading(true);
    
    try {
      // Get location
      const position = await getCurrentLocation();
      
      // Submit the quick post
      const result = await submitCheckin({
        cafeId: selectedCafe.id,
        placeId: selectedCafe.placeId,
        rating: 5, // Default rating for quick posts
        tags: [],
        review: caption,
        imageFile,
        location: {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude
        }
      });
      
      if (result.success) {
        // Track successful quick post
        trackQuickPost(selectedCafe?.name, selectedCafe?.id, !!imageFile);
        
        toast({
          title: "Quick post shared!",
          description: "Your photo has been posted successfully"
        });
        navigate("/explore");
      } else {
        setError(result.error || "Failed to share photo");
        toast({
          title: "Error",
          description: result.error || "Failed to share photo",
          variant: "destructive"
        });
      }
    } catch (error) {
      console.error("Error sharing photo:", error);
      setError("Failed to share photo. Please try again.");
      toast({
        title: "Error",
        description: "Failed to share photo. Please try again.",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  }

  return (
    <AppLayout>
      <div className="max-w-md mx-auto min-h-screen bg-background pb-20">
        {/* Header */}
        <div className="sticky top-0 z-40 bg-background/95 backdrop-blur-md border-b border-border p-4">
          <div className="flex items-center gap-3">
            <Button 
              variant="ghost" 
              size="sm" 
              onClick={() => navigate('/share')}
              className="p-2"
            >
              <ArrowLeft className="w-4 h-4" />
            </Button>
            <h1 className="text-xl font-bold">Quick Post</h1>
          </div>
          <p className="text-sm text-muted-foreground mt-1">Share a photo with a caption</p>
        </div>

        <div className="p-4 space-y-6">
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Photo Upload */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Camera className="w-5 h-5 text-primary" />
                  Add Photo
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="border-2 border-dashed border-border rounded-lg p-8 text-center relative hover:border-primary/50 transition-colors">
                  {imageFile ? (
                    <div className="space-y-3">
                      <div className="w-full h-48 bg-muted rounded-lg overflow-hidden">
                        <img 
                          src={URL.createObjectURL(imageFile)} 
                          alt="Preview" 
                          className="w-full h-full object-cover"
                        />
                      </div>
                      <div className="flex items-center justify-between">
                        <p className="text-sm text-foreground truncate flex-1 mr-2">{imageFile.name}</p>
                        <Button 
                          variant="ghost" 
                          size="sm"
                          onClick={() => setImageFile(null)}
                          className="text-destructive hover:text-destructive"
                        >
                          <X className="w-4 h-4" />
                        </Button>
                      </div>
                    </div>
                  ) : (
                    <>
                      <Camera className="w-12 h-12 mx-auto text-muted-foreground mb-3" />
                      <p className="text-sm text-muted-foreground mb-1">Tap to add a photo</p>
                      <p className="text-xs text-muted-foreground">Share your coffee moment</p>
                      <input
                        ref={fileInputRef}
                        type="file"
                        accept="image/*"
                        onChange={handleImageUpload}
                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                      />
                    </>
                  )}
                </div>
              </CardContent>
            </Card>

            {/* Caption */}
            <Card>
              <CardHeader>
                <CardTitle>Caption</CardTitle>
              </CardHeader>
              <CardContent>
                <Textarea 
                  value={caption} 
                  onChange={e => setCaption(e.target.value)} 
                  rows={4} 
                  placeholder="Say something about this photo..."
                  className="resize-none"
                />
              </CardContent>
            </Card>

            {/* Tag a Cafe */}
            <Card>
              <CardHeader>
                <CardTitle>Tag a Cafe (Optional)</CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="flex gap-2">
                  <Input 
                    value={cafeQuery} 
                    onChange={e => setCafeQuery(e.target.value)} 
                    placeholder="Search for a cafe..."
                    className="flex-1"
                  />
                  <Button 
                    type="button" 
                    onClick={handleCafeSearch} 
                    disabled={loading || !cafeQuery.trim()}
                    variant="outline"
                  >
                    Search
                  </Button>
                </div>
                
                {cafeResults.length > 0 && (
                  <div className="border rounded-lg bg-muted/50 divide-y max-h-40 overflow-y-auto">
                    {cafeResults.map(cafe => (
                      <div 
                        key={cafe.id} 
                        className={`p-3 cursor-pointer hover:bg-muted transition-colors ${
                          selectedCafe?.id === cafe.id ? 'bg-primary/10 border-l-4 border-l-primary' : ''
                        }`} 
                        onClick={() => setSelectedCafe(cafe)}
                      >
                        <div className="font-medium">{cafe.name}</div>
                        <div className="text-xs text-muted-foreground">{cafe.neighborhood}</div>
                      </div>
                    ))}
                  </div>
                )}
                
                {selectedCafe && (
                  <div className="p-3 bg-primary/10 rounded-lg border border-primary/20">
                    <div className="flex items-center justify-between">
                      <div>
                        <div className="font-medium text-primary">Selected: {selectedCafe.name}</div>
                        <div className="text-xs text-muted-foreground">{selectedCafe.neighborhood}</div>
                      </div>
                      <Button 
                        variant="ghost" 
                        size="sm"
                        onClick={() => setSelectedCafe(null)}
                        className="text-destructive hover:text-destructive"
                      >
                        <X className="w-4 h-4" />
                      </Button>
                    </div>
                  </div>
                )}
              </CardContent>
            </Card>

            {error && (
              <div className="p-3 bg-destructive/10 border border-destructive/20 rounded-lg">
                <p className="text-sm text-destructive">{error}</p>
              </div>
            )}

            {/* Submit Button */}
            <Button 
              type="submit" 
              className="w-full coffee-gradient text-white shadow-coffee hover:shadow-glow transition-smooth" 
              size="lg"
              disabled={!imageFile || loading}
            >
              {loading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin mr-2" />
                  Sharing...
                </>
              ) : (
                "Share Quick Post"
              )}
            </Button>
          </form>
        </div>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/DataValidation.tsx
================
import { useState } from 'react';
import { CheckCircle, XCircle, AlertTriangle, RefreshCw, Database } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { AppLayout } from '@/components/Layout/AppLayout';
import { validateAllCafes } from '@/services/validationService';

export default function DataValidation() {
  const [validationResults, setValidationResults] = useState<{
    total: number;
    valid: number;
    invalid: number;
    warnings: number;
    duplicates: number;
  } | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const runValidation = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await validateAllCafes();
      
      if (result.success && result.data) {
        setValidationResults(result.data);
      } else {
        setError(result.error || 'Failed to validate data');
      }
    } catch (err) {
      setError('Failed to run validation');
    } finally {
      setLoading(false);
    }
  };

  const getValidationScore = () => {
    if (!validationResults) return 0;
    return Math.round((validationResults.valid / validationResults.total) * 100);
  };

  const getScoreColor = (score: number) => {
    if (score >= 90) return 'text-green-500';
    if (score >= 70) return 'text-yellow-500';
    return 'text-red-500';
  };

  return (
    <AppLayout showBottomNav={false}>
      <div className="max-w-4xl mx-auto min-h-screen bg-background pb-20">
        <div className="p-4 space-y-6">
          {/* Header */}
          <div className="flex items-center gap-3">
            <Database className="w-6 h-6 text-primary" />
            <h1 className="text-2xl font-bold">Data Validation</h1>
          </div>

          {/* Validation Controls */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <RefreshCw className="w-5 h-5" />
                Run Validation
              </CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-muted-foreground mb-4">
                Validate all cafe data for completeness, accuracy, and duplicates.
              </p>
              <Button 
                onClick={runValidation} 
                disabled={loading}
                className="coffee-gradient text-white shadow-coffee hover:shadow-glow transition-smooth"
              >
                {loading ? (
                  <>
                    <RefreshCw className="w-4 h-4 animate-spin mr-2" />
                    Validating...
                  </>
                ) : (
                  'Run Validation'
                )}
              </Button>
            </CardContent>
          </Card>

          {/* Error Display */}
          {error && (
            <Card className="border-red-200 bg-red-50">
              <CardContent className="pt-6">
                <div className="flex items-center gap-2 text-red-600">
                  <XCircle className="w-5 h-5" />
                  <span className="font-medium">Validation Error</span>
                </div>
                <p className="text-sm text-red-600 mt-1">{error}</p>
              </CardContent>
            </Card>
          )}

          {/* Validation Results */}
          {validationResults && (
            <div className="space-y-4">
              {/* Overall Score */}
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <CheckCircle className="w-5 h-5" />
                    Validation Summary
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="flex items-center gap-4">
                    <div className="text-3xl font-bold">
                      <span className={getScoreColor(getValidationScore())}>
                        {getValidationScore()}%
                      </span>
                    </div>
                    <div className="text-sm text-muted-foreground">
                      <p>Data Quality Score</p>
                      <p>{validationResults.valid} of {validationResults.total} cafes valid</p>
                    </div>
                  </div>
                </CardContent>
              </Card>

              {/* Detailed Results */}
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                <Card>
                  <CardContent className="pt-6">
                    <div className="flex items-center gap-2">
                      <Database className="w-4 h-4 text-blue-500" />
                      <span className="text-sm font-medium">Total Cafes</span>
                    </div>
                    <div className="text-2xl font-bold mt-2">{validationResults.total}</div>
                  </CardContent>
                </Card>

                <Card>
                  <CardContent className="pt-6">
                    <div className="flex items-center gap-2">
                      <CheckCircle className="w-4 h-4 text-green-500" />
                      <span className="text-sm font-medium">Valid</span>
                    </div>
                    <div className="text-2xl font-bold mt-2 text-green-500">
                      {validationResults.valid}
                    </div>
                  </CardContent>
                </Card>

                <Card>
                  <CardContent className="pt-6">
                    <div className="flex items-center gap-2">
                      <XCircle className="w-4 h-4 text-red-500" />
                      <span className="text-sm font-medium">Invalid</span>
                    </div>
                    <div className="text-2xl font-bold mt-2 text-red-500">
                      {validationResults.invalid}
                    </div>
                  </CardContent>
                </Card>

                <Card>
                  <CardContent className="pt-6">
                    <div className="flex items-center gap-2">
                      <AlertTriangle className="w-4 h-4 text-yellow-500" />
                      <span className="text-sm font-medium">Warnings</span>
                    </div>
                    <div className="text-2xl font-bold mt-2 text-yellow-500">
                      {validationResults.warnings}
                    </div>
                  </CardContent>
                </Card>
              </div>

              {/* Issues Summary */}
              <Card>
                <CardHeader>
                  <CardTitle>Issues Found</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="space-y-3">
                    {validationResults.invalid > 0 && (
                      <div className="flex items-center gap-2">
                        <Badge variant="destructive">
                          {validationResults.invalid} Invalid Records
                        </Badge>
                        <span className="text-sm text-muted-foreground">
                          Cafes with missing required data
                        </span>
                      </div>
                    )}
                    
                    {validationResults.warnings > 0 && (
                      <div className="flex items-center gap-2">
                        <Badge variant="secondary" className="bg-yellow-100 text-yellow-800">
                          {validationResults.warnings} Warnings
                        </Badge>
                        <span className="text-sm text-muted-foreground">
                          Cafes with potential data issues
                        </span>
                      </div>
                    )}
                    
                    {validationResults.duplicates > 0 && (
                      <div className="flex items-center gap-2">
                        <Badge variant="outline" className="border-orange-200 text-orange-800">
                          {validationResults.duplicates} Potential Duplicates
                        </Badge>
                        <span className="text-sm text-muted-foreground">
                          Cafes that may be duplicates
                        </span>
                      </div>
                    )}
                    
                    {validationResults.invalid === 0 && validationResults.warnings === 0 && validationResults.duplicates === 0 && (
                      <div className="flex items-center gap-2">
                        <CheckCircle className="w-4 h-4 text-green-500" />
                        <span className="text-sm text-green-600 font-medium">
                          No issues found! All data looks good.
                        </span>
                      </div>
                    )}
                  </div>
                </CardContent>
              </Card>
            </div>
          )}
        </div>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/Feed.tsx
================
import { useState, useEffect } from "react";
import { useSearchParams, useNavigate } from "react-router-dom";
import { Search, X, MapPin, Grid } from "lucide-react";
import { Post, Cafe } from "@/services/types";
import { fetchPosts, filterFeedByTag } from "@/services/postService";
import { fetchCafes, fetchNearbyCafes } from "@/services/cafeService";
import { debounce, getCurrentLocation } from "@/services/utils";
import { toast } from "@/hooks/use-toast";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { AppLayout } from "@/components/Layout/AppLayout";
import { PostCard } from "@/components/Feed/PostCard";
import { ExploreFilters, FilterState } from "@/components/Filters/ExploreFilters";
import { RadiusFilter } from "@/components/Filters/RadiusFilter";
import { getCafeEmoji } from "@/utils/emojiPlaceholders";

export default function Feed() {
  const navigate = useNavigate();
  const [searchParams, setSearchParams] = useSearchParams();
  const [searchQuery, setSearchQuery] = useState("");
  const [posts, setPosts] = useState<Post[]>([]);
  const [cafes, setCafes] = useState<Cafe[]>([]);
  const [filteredCafes, setFilteredCafes] = useState<Cafe[]>([]);
  const [loading, setLoading] = useState(true);
  const [cafesLoading, setCafesLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [selectedTag, setSelectedTag] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState("posts");
  const [userLocation, setUserLocation] = useState<{ lat: number; lng: number } | null>(null);
  const [locationError, setLocationError] = useState<string | null>(null);
  const [filters, setFilters] = useState<FilterState>({
    priceLevel: [],
    rating: 0,
    distance: 5, // Default to 5 miles as requested
    openNow: false,
    neighborhoods: [],
    sortBy: 'newest',
    sortOrder: 'desc'
  });

  // Get tag from URL parameters
  const tagFromUrl = searchParams.get('tag');

  // Load posts based on filters
  const loadPosts = async (tag?: string) => {
    try {
      setLoading(true);
      setError(null);
      
      let result;
      if (tag) {
        result = await filterFeedByTag(tag);
        setSelectedTag(tag);
      } else {
        result = await fetchPosts();
        setSelectedTag(null);
      }
      
      if (result.success) {
        setPosts(result.data);
      } else {
        setError(result.error || 'Failed to load posts');
        toast({
          title: "Error",
          description: result.error || 'Failed to load posts',
          variant: "destructive"
        });
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load posts';
      setError(errorMessage);
      toast({
        title: "Error", 
        description: errorMessage,
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  // Load cafes
  const loadCafes = async () => {
    try {
      setCafesLoading(true);
      const result = await fetchCafes();
      if (result.success) {
        setCafes(result.data);
        setFilteredCafes(result.data);
      } else {
        toast({
          title: "Error",
          description: result.error || 'Failed to load cafes',
          variant: "destructive"
        });
      }
    } catch (err) {
      console.error('Failed to load cafes:', err);
    } finally {
      setCafesLoading(false);
    }
  };

  // Request location permission
  const requestLocation = async () => {
    try {
      setLocationError(null);
      const position = await getCurrentLocation();
      const { latitude, longitude } = position.coords;
      setUserLocation({ lat: latitude, lng: longitude });
    } catch (error) {
      setLocationError("Enable location to find cafes near you");
    }
  };

  // Apply filters to cafes
  const applyFilters = (searchTerm = searchQuery) => {
    let filtered = [...cafes];

    // Location-based filtering
    if (userLocation && filters.distance < 25) {
      filtered = filtered.filter(cafe => {
        const distance = calculateDistance(
          userLocation.lat,
          userLocation.lng,
          cafe.latitude,
          cafe.longitude
        );
        return distance <= filters.distance;
      });
    }

    // Search by name or neighborhood
    if (searchTerm.trim()) {
      const query = searchTerm.toLowerCase();
      filtered = filtered.filter(cafe => 
        cafe.name.toLowerCase().includes(query) ||
        cafe.neighborhood.toLowerCase().includes(query) ||
        cafe.tags.some(tag => tag.toLowerCase().includes(query))
      );
    }

    // Price level filter
    if (filters.priceLevel.length > 0) {
      filtered = filtered.filter(cafe => 
        cafe.priceLevel && filters.priceLevel.includes(cafe.priceLevel)
      );
    }

    // Rating filter
    if (filters.rating > 0) {
      filtered = filtered.filter(cafe => 
        (cafe.googleRating || cafe.rating || 0) >= filters.rating
      );
    }

    // Neighborhood filter
    if (filters.neighborhoods.length > 0) {
      filtered = filtered.filter(cafe => 
        filters.neighborhoods.includes(cafe.neighborhood)
      );
    }

    // Open now filter (mock implementation)
    if (filters.openNow) {
      // In real implementation, this would check actual hours
      filtered = filtered.filter(cafe => Math.random() > 0.3); // Mock: 70% are "open"
    }

    // Apply sorting
    filtered.sort((a, b) => {
      let comparison = 0;
      
      switch (filters.sortBy) {
        case 'rating':
          const aRating = a.googleRating || a.rating || 0;
          const bRating = b.googleRating || b.rating || 0;
          comparison = aRating - bRating;
          break;
        case 'price':
          const aPrice = a.priceLevel || 0;
          const bPrice = b.priceLevel || 0;
          comparison = aPrice - bPrice;
          break;
        case 'name':
          comparison = a.name.localeCompare(b.name);
          break;
        case 'distance':
          if (userLocation) {
            const aDistance = calculateDistance(userLocation.lat, userLocation.lng, a.latitude, a.longitude);
            const bDistance = calculateDistance(userLocation.lat, userLocation.lng, b.latitude, b.longitude);
            comparison = aDistance - bDistance;
          } else {
            comparison = Math.random() - 0.5;
          }
          break;
        case 'newest':
        default:
          comparison = new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
          break;
      }
      
      return filters.sortOrder === 'asc' ? comparison : -comparison;
    });

    setFilteredCafes(filtered);
  };

  // Calculate distance between two coordinates
  const calculateDistance = (lat1: number, lon1: number, lat2: number, lon2: number): number => {
    const R = 3959; // Earth's radius in miles
    const dLat = (lat2 - lat1) * (Math.PI / 180);
    const dLon = (lon2 - lon1) * (Math.PI / 180);
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  };

  // Debounced search function
  const debouncedSearch = debounce((query: string) => {
    applyFilters(query);
  }, 300);

  // Handle search input
  const handleSearchChange = (value: string) => {
    setSearchQuery(value);
    debouncedSearch(value);
  };

  // Handle filters change
  const handleFiltersChange = (newFilters: FilterState) => {
    setFilters(newFilters);
  };

  // Clear all filters
  const clearAllFilters = () => {
    setFilters({
      priceLevel: [],
      rating: 0,
      distance: 5, // Reset to 5 miles default
      openNow: false,
      neighborhoods: [],
      sortBy: 'newest',
      sortOrder: 'desc'
    });
    setSearchQuery("");
    setUserLocation(null);
    setLocationError(null);
  };

  // Clear tag filter
  const clearTagFilter = () => {
    setSearchParams({});
    loadPosts();
  };

  // Handle cafe navigation
  const handleCafeClick = (cafe: Cafe) => {
    navigate(`/cafe/${cafe.placeId}`);
  };

  // Apply filters when they change
  useEffect(() => {
    applyFilters();
  }, [filters, cafes]);

  // Load data on component mount
  useEffect(() => {
    loadPosts(tagFromUrl || undefined);
    loadCafes();
  }, [tagFromUrl]);

  if (loading) {
    return (
      <AppLayout>
        <div className="max-w-md mx-auto min-h-screen bg-background flex items-center justify-center">
          <div className="text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
            <p className="text-muted-foreground">Loading Houston cafes...</p>
          </div>
        </div>
      </AppLayout>
    );
  }

  return (
    <AppLayout>
      <div className="max-w-md mx-auto min-h-screen bg-background">
        {/* Header */}
        <div className="sticky top-0 z-40 bg-background/95 backdrop-blur-md border-b border-border p-4 pb-3">
          <div className="flex items-center gap-3 mb-3">
            <h1 className="text-2xl font-bold">Explore</h1>
            <MapPin className="w-5 h-5 text-primary" />
          </div>
          
          {/* Search Bar */}
          <div className="flex gap-2 mb-3">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground" />
              <Input
                placeholder="Search cafes, neighborhoods..."
                value={searchQuery}
                onChange={(e) => handleSearchChange(e.target.value)}
                className="pl-10 bg-muted/30 border-0 shadow-sm"
              />
            </div>
            <ExploreFilters
              filters={filters}
              onFiltersChange={handleFiltersChange}
              onClearFilters={clearAllFilters}
            />
          </div>

          {/* Radius Filter */}
          <RadiusFilter
            radius={filters.distance}
            onRadiusChange={(radius) => handleFiltersChange({ ...filters, distance: radius })}
            userLocation={userLocation}
            onRequestLocation={requestLocation}
            locationError={locationError}
          />

          {/* Active Tag Filter */}
          {selectedTag && (
            <div className="flex items-center gap-2 mt-3">
              <Badge
                variant="default"
                className="flex items-center gap-1"
              >
                #{selectedTag}
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-4 w-4 p-0 hover:bg-transparent"
                  onClick={clearTagFilter}
                >
                  <X className="h-3 w-3" />
                </Button>
              </Badge>
              <span className="text-xs text-muted-foreground">
                {posts.length} posts found
              </span>
            </div>
          )}
        </div>

        {/* Content Tabs */}
        <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1">
          <TabsList className="sticky top-[140px] z-30 w-full bg-background/95 backdrop-blur-md border-b border-border mx-4 mt-2">
            <TabsTrigger value="posts" className="flex-1">Posts</TabsTrigger>
            <TabsTrigger value="cafes" className="flex-1">
              Cafes ({filteredCafes.length})
            </TabsTrigger>
          </TabsList>

          <TabsContent value="posts" className="mt-0">
            <div className="p-4 space-y-4 pb-20">
              {error && (
                <div className="text-center py-8">
                  <p className="text-destructive mb-4">{error}</p>
                  <Button onClick={() => loadPosts(selectedTag || undefined)}>
                    Try Again
                  </Button>
                </div>
              )}
              
              {!error && posts.length === 0 && !loading && (
                <div className="text-center py-12">
                  <MapPin className="w-12 h-12 mx-auto text-muted-foreground mb-4" />
                  <h3 className="text-lg font-semibold mb-2">No posts found</h3>
                  <p className="text-muted-foreground mb-4">
                    {selectedTag 
                      ? `No posts found for #${selectedTag}. Try exploring other tags or check out nearby cafes.`
                      : 'No posts available yet. Be the first to check in at a Houston cafe!'
                    }
                  </p>
                  {selectedTag && (
                    <Button onClick={clearTagFilter} variant="outline">
                      Clear Filter
                    </Button>
                  )}
                </div>
              )}

              {posts.map((post) => (
                <PostCard 
                  key={post.id} 
                  post={{
                    id: post.id,
                    cafeName: post.cafe?.name || 'Unknown Cafe',
                    neighborhood: post.cafe?.neighborhood || 'Houston',
                    imageUrl: post.imageUrl,
                    tags: post.tags,
                    rating: post.rating,
                    textReview: post.textReview,
                    createdAt: new Date(post.createdAt).toLocaleString(),
                    likes: post.likes,
                    comments: post.comments,
                    username: post.username
                  }} 
                />
              ))}
              
              {posts.length > 0 && (
                <div className="text-center py-8">
                  <Button variant="ghost" className="text-muted-foreground">
                    Load more posts...
                  </Button>
                </div>
              )}
            </div>
          </TabsContent>

          <TabsContent value="cafes" className="mt-0">
            <div className="p-4 space-y-3 pb-20">
              {cafesLoading && (
                <div className="text-center py-8">
                  <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
                  <p className="text-muted-foreground">Loading cafes...</p>
                </div>
              )}

              {!cafesLoading && filteredCafes.length === 0 && (
                <div className="text-center py-12">
                  <Grid className="w-12 h-12 mx-auto text-muted-foreground mb-4" />
                  <h3 className="text-lg font-semibold mb-2">No cafes found</h3>
                  <p className="text-muted-foreground mb-4">
                    Try adjusting your filters or search terms.
                  </p>
                  <Button onClick={clearAllFilters} variant="outline">
                    Clear All Filters
                  </Button>
                </div>
              )}

              {filteredCafes.map((cafe) => (
                <Card 
                  key={cafe.id}
                  className="cursor-pointer hover:shadow-coffee transition-smooth shadow-sm border border-border/50"
                  onClick={() => handleCafeClick(cafe)}
                >
                  <CardContent className="p-4">
                    <div className="flex gap-4">
                      {cafe.photos?.[0] ? (
                        <img
                          src={cafe.photos[0]}
                          alt={cafe.name}
                          className="w-20 h-20 rounded-lg object-cover"
                        />
                      ) : (
                        <div className="w-20 h-20 rounded-lg bg-gradient-to-br from-[#8b5a3c] to-[#6b4423] flex items-center justify-center text-white text-2xl shadow-lg">
                          {getCafeEmoji(cafe.id || cafe.placeId)}
                        </div>
                      )}
                      
                      <div className="flex-1 min-w-0">
                        <h3 className="font-semibold text-lg mb-1">{cafe.name}</h3>
                        
                        <div className="flex items-center gap-2 mb-2">
                          <MapPin className="w-4 h-4 text-muted-foreground" />
                          <span className="text-sm text-muted-foreground">{cafe.neighborhood}</span>
                          {cafe.priceLevel && (
                            <div className="flex items-center ml-auto">
                              {Array.from({ length: 4 }, (_, i) => (
                                <span
                                  key={i}
                                  className={`text-xs ${
                                    i < cafe.priceLevel! ? "text-foreground" : "text-muted-foreground"
                                  }`}
                                >
                                  $
                                </span>
                              ))}
                            </div>
                          )}
                        </div>

                        {cafe.rating && (
                          <div className="flex items-center gap-1 mb-3">
                            <span className="coffee-star">‚òÖ</span>
                            <span className="text-sm font-medium">{cafe.rating}</span>
                            <span className="text-xs text-muted-foreground">Google</span>
                          </div>
                        )}

                        <div className="flex flex-wrap gap-1">
                          {cafe.tags.slice(0, 2).map((tag) => (
                            <Badge
                              key={tag}
                              variant="secondary"
                              className="text-xs px-2 py-1 bg-primary/10 text-primary border-0 rounded-full"
                            >
                              #{tag}
                            </Badge>
                          ))}
                          {cafe.tags.length > 2 && (
                            <Badge
                              variant="secondary"
                              className="text-xs px-2 py-1 bg-muted/50 text-muted-foreground border-0 rounded-full"
                            >
                              +{cafe.tags.length - 2}
                            </Badge>
                          )}
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          </TabsContent>
        </Tabs>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/Feedback.tsx
================
import { useState } from 'react';
import { MessageSquare, Send, CheckCircle } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { AppLayout } from '@/components/Layout/AppLayout';
import { useToast } from '@/hooks/use-toast';
import { submitFeedback, type FeedbackData } from '@/services/feedbackService';

const feedbackTypes = [
  { value: 'bug', label: 'Bug Report', description: 'Something isn\'t working' },
  { value: 'feature', label: 'Feature Request', description: 'Suggest a new feature' },
  { value: 'general', label: 'General Feedback', description: 'Share your thoughts' },
  { value: 'support', label: 'Support', description: 'Need help with something' }
] as const;

export default function Feedback() {
  const { toast } = useToast();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isSubmitted, setIsSubmitted] = useState(false);
  
  // Form state
  const [feedbackType, setFeedbackType] = useState<FeedbackData['feedback_type']>('general');
  const [subject, setSubject] = useState('');
  const [details, setDetails] = useState('');
  const [allowFollowup, setAllowFollowup] = useState(false);
  const [contactEmail, setContactEmail] = useState('');
  
  // Validation state
  const [errors, setErrors] = useState<{
    subject?: string;
    details?: string;
    contactEmail?: string;
  }>({});

  const validateForm = (): boolean => {
    const newErrors: typeof errors = {};

    // Required fields
    if (!subject.trim()) {
      newErrors.subject = 'Subject is required';
    }

    if (!details.trim()) {
      newErrors.details = 'Details are required';
    }

    // Email validation if follow-up is requested
    if (allowFollowup) {
      if (!contactEmail.trim()) {
        newErrors.contactEmail = 'Email is required for follow-up';
      } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(contactEmail)) {
        newErrors.contactEmail = 'Please enter a valid email address';
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);

    try {
      const feedbackData: FeedbackData = {
        feedback_type: feedbackType,
        subject: subject.trim(),
        details: details.trim(),
        allow_followup: allowFollowup,
        contact_email: allowFollowup ? contactEmail.trim() : undefined
      };

      const result = await submitFeedback(feedbackData);

      if (result.success) {
        setIsSubmitted(true);
        toast({
          title: "Feedback Submitted",
          description: "Thank you for your feedback! We'll review it soon.",
        });
        
        // Reset form
        setSubject('');
        setDetails('');
        setAllowFollowup(false);
        setContactEmail('');
        setErrors({});
      } else {
        throw new Error(result.error || 'Failed to submit feedback');
      }
    } catch (error) {
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to submit feedback",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleNewFeedback = () => {
    setIsSubmitted(false);
    setFeedbackType('general');
    setSubject('');
    setDetails('');
    setAllowFollowup(false);
    setContactEmail('');
    setErrors({});
  };

  if (isSubmitted) {
    return (
      <AppLayout>
        <div className="max-w-md mx-auto min-h-screen bg-background pb-20">
          {/* Header */}
          <div className="sticky top-0 z-40 coffee-header p-4">
            <h1 className="text-2xl font-bold coffee-heading">Feedback</h1>
            <p className="text-sm text-white/90">Share your thoughts with us</p>
          </div>

          <div className="p-4">
            <Card className="coffee-card">
              <CardContent className="p-8 text-center">
                <CheckCircle className="w-16 h-16 mx-auto mb-4 text-green-500" />
                <h2 className="text-xl font-semibold mb-2 coffee-section-heading">Thank You!</h2>
                <p className="text-muted-foreground mb-6">
                  Your feedback has been submitted successfully. We appreciate you taking the time to help us improve BeanScene.
                </p>
                <Button 
                  onClick={handleNewFeedback}
                  className="coffee-button"
                >
                  Submit Another
                </Button>
              </CardContent>
            </Card>
          </div>
        </div>
      </AppLayout>
    );
  }

  return (
    <AppLayout>
      <div className="max-w-md mx-auto min-h-screen bg-background pb-20">
        {/* Header */}
        <div className="sticky top-0 z-40 coffee-header p-4">
          <h1 className="text-2xl font-bold coffee-heading">Feedback</h1>
          <p className="text-sm text-white/90">Share your thoughts with us</p>
        </div>

        <div className="p-4 space-y-6">
          {/* Feedback Type Selection */}
          <Card className="coffee-card">
            <CardHeader>
              <CardTitle className="flex items-center gap-2 coffee-section-heading">
                <MessageSquare className="w-5 h-5 coffee-location-pin" />
                What's this about?
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              {feedbackTypes.map((type) => (
                <div
                  key={type.value}
                  onClick={() => setFeedbackType(type.value)}
                  className={`p-3 rounded-lg border cursor-pointer transition-all duration-200 ${
                    feedbackType === type.value
                      ? 'border-primary bg-primary/10 coffee-interactive'
                      : 'border-border hover:bg-muted/50'
                  }`}
                >
                  <div className="font-medium">{type.label}</div>
                  <div className="text-sm text-muted-foreground">{type.description}</div>
                </div>
              ))}
            </CardContent>
          </Card>

          {/* Feedback Form */}
          <Card className="coffee-card">
            <CardHeader>
              <CardTitle className="coffee-section-heading">Tell us more</CardTitle>
            </CardHeader>
            <CardContent>
              <form onSubmit={handleSubmit} className="space-y-4">
                {/* Subject */}
                <div className="space-y-2">
                  <label htmlFor="subject" className="text-sm font-medium coffee-cafe-name">
                    Subject *
                  </label>
                  <Input
                    id="subject"
                    value={subject}
                    onChange={(e) => setSubject(e.target.value)}
                    placeholder="Brief description of your feedback"
                    className="coffee-input"
                  />
                  {errors.subject && (
                    <p className="text-sm text-red-500">{errors.subject}</p>
                  )}
                </div>

                {/* Details */}
                <div className="space-y-2">
                  <label htmlFor="details" className="text-sm font-medium coffee-cafe-name">
                    Details *
                  </label>
                  <Textarea
                    id="details"
                    value={details}
                    onChange={(e) => setDetails(e.target.value)}
                    placeholder="Please provide as much detail as possible..."
                    rows={4}
                    className="coffee-input resize-none"
                  />
                  {errors.details && (
                    <p className="text-sm text-red-500">{errors.details}</p>
                  )}
                </div>

                {/* Follow-up Checkbox */}
                <div className="space-y-3">
                  <div className="flex items-center space-x-2">
                    <input
                      type="checkbox"
                      id="allowFollowup"
                      checked={allowFollowup}
                      onChange={(e) => setAllowFollowup(e.target.checked)}
                      className="w-4 h-4 text-primary bg-background border-border rounded focus:ring-primary focus:ring-2"
                    />
                    <label htmlFor="allowFollowup" className="text-sm font-medium coffee-cafe-name">
                      Yes, you can reach out to me about this
                    </label>
                  </div>

                  {/* Conditional Email Field */}
                  {allowFollowup && (
                    <div className="space-y-2 animate-in slide-in-from-top-2 duration-200">
                      <label htmlFor="contactEmail" className="text-sm font-medium coffee-cafe-name">
                        Email Address *
                      </label>
                      <Input
                        id="contactEmail"
                        type="email"
                        value={contactEmail}
                        onChange={(e) => setContactEmail(e.target.value)}
                        placeholder="Enter your email for follow-up"
                        className="coffee-input"
                      />
                      {errors.contactEmail && (
                        <p className="text-sm text-red-500">{errors.contactEmail}</p>
                      )}
                    </div>
                  )}
                </div>

                {/* Submit Button */}
                <Button
                  type="submit"
                  disabled={isSubmitting}
                  className="w-full coffee-button"
                  size="lg"
                >
                  {isSubmitting ? (
                    <>
                      <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin mr-2" />
                      Submitting...
                    </>
                  ) : (
                    <>
                      <Send className="w-4 h-4 mr-2" />
                      Submit Feedback
                    </>
                  )}
                </Button>
              </form>
            </CardContent>
          </Card>
        </div>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/Home.tsx
================
import { Coffee, MapPin, Heart, Users } from "lucide-react";
import { AppLayout } from "@/components/Layout/AppLayout";
import { useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";

export default function Home() {
  const navigate = useNavigate();
  return (
    <AppLayout>
      <div className="max-w-md mx-auto min-h-screen bg-background pb-20">
        {/* Hero Section */}
        <div className="relative h-[40vh] coffee-header flex items-center justify-center p-6">
          <div className="text-center text-white">
            <Coffee className="w-16 h-16 mx-auto mb-4 text-white" />
            <h1 className="text-4xl font-bold mb-3 coffee-heading">BeanScene</h1>
            <p className="text-lg text-white/90 max-w-sm mx-auto">
              Discover caf√©s, vibes, and connections in your city
            </p>
          </div>
        </div>

        {/* Origins / Story Section */}
        <div className="p-6 space-y-6">
          <Card className="shadow-coffee border-0">
            <CardContent className="p-6">
              <h3 className="text-xl font-semibold mb-4 coffee-section-heading">Connected, but Lonely</h3>
              <div className="space-y-4 text-muted-foreground">
                <p>
                  We live in a world more connected than ever,yet most of us feel more isolated than ever. Algorithms keep us scrolling, but rarely help us belong in our own cities.
                </p>

                <h3 className="text-xl font-semibold mt-4 coffee-section-heading">Why Coffee?</h3>
                <p>
                  Coffee is more than caffeine. It‚Äôs ritual, comfort, and the backdrop for so many parts of life, whether you‚Äôre working solo, catching up with a friend, or starting a new conversation.
                </p>

                <h3 className="text-xl font-semibold mt-4 coffee-section-heading">The Idea</h3>
                <p>
                  Bean Scene helps you discover caf√©s that fit your vibe: laptop-friendly, cozy, social, or just a quiet corner to think. And along the way, it makes it easier to turn everyday coffee runs into real connections.
                </p>

                <h3 className="text-xl font-semibold mt-4 coffee-section-heading">The Vision</h3>
                <p>
                  This is just the beginning. Our bigger goal is to help people step away from algorithms and into real life, building a culture where belonging happens naturally, one caf√© at a time.
                </p>

                <p className="mt-4 font-medium text-foreground text-center">
                  ‚ú® More than coffee. More than connections.
                </p>
              </div>
            </CardContent>
          </Card>

          {/* Feature Cards */}
          <div className="grid grid-cols-2 gap-4">
            <Card className="coffee-card coffee-interactive" onClick={() => navigate('/explore')}>
              <CardContent className="p-6 text-center">
                <MapPin className="w-8 h-8 mx-auto mb-3 coffee-location-pin" />
                <h3 className="font-semibold mb-1 coffee-cafe-name">Discover</h3>
                <p className="text-xs coffee-text-light">Find your perfect caf√©</p>
              </CardContent>
            </Card>

            <Card className="coffee-card coffee-interactive" onClick={() => navigate('/share')}>
              <CardContent className="p-6 text-center">
                <Coffee className="w-8 h-8 mx-auto mb-3 coffee-location-pin" />
                <h3 className="font-semibold mb-1 coffee-cafe-name">Share</h3>
                <p className="text-xs coffee-text-light">Post your coffee moments</p>
              </CardContent>
            </Card>

            <Card className="coffee-card coffee-interactive" onClick={() => navigate('/moments')}>
              <CardContent className="p-6 text-center">
                <Heart className="w-8 h-8 mx-auto mb-3 coffee-location-pin" />
                <h3 className="font-semibold mb-1 coffee-cafe-name">Connect</h3>
                <p className="text-xs coffee-text-light">See community moments</p>
              </CardContent>
            </Card>

            <Card className="coffee-card coffee-interactive" onClick={() => navigate('/profile')}>
              <CardContent className="p-6 text-center">
                <Users className="w-8 h-8 mx-auto mb-3 coffee-location-pin" />
                <h3 className="font-semibold mb-1 coffee-cafe-name">Profile</h3>
                <p className="text-xs coffee-text-light">Track your journey</p>
              </CardContent>
            </Card>
          </div>

          {/* CTA */}
          <div className="text-center pt-4">
            <Button 
              size="lg" 
              className="coffee-gradient text-white shadow-glow"
              onClick={() => navigate('/explore')}
            >
              Start Exploring
            </Button>
          </div>
        </div>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/ImageUpload.tsx
================
import { useState, useRef, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Camera, Upload, X, ArrowLeft, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { AppLayout } from '@/components/Layout/AppLayout';
import { useToast } from '@/hooks/use-toast';
import { uploadImage } from '@/services/cloudinaryService';
import { fetchCafeDetails } from '@/services/cafeService';
import type { Cafe } from '@/services/types';

export default function ImageUpload() {
  const navigate = useNavigate();
  const { id: placeId } = useParams<{ id: string }>();
  const { toast } = useToast();
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  const [cafe, setCafe] = useState<Cafe | null>(null);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [loading, setLoading] = useState(true);

  // Load cafe details
  useEffect(() => {
    const loadCafe = async () => {
      if (!placeId) {
        navigate('/explore');
        return;
      }

      try {
        const result = await fetchCafeDetails(placeId);
        if (result.success && result.data) {
          setCafe(result.data);
        } else {
          toast({
            title: "Error",
            description: "Cafe not found",
            variant: "destructive"
          });
          navigate('/explore');
        }
      } catch (error) {
        toast({
          title: "Error",
          description: "Failed to load cafe details",
          variant: "destructive"
        });
        navigate('/explore');
      } finally {
        setLoading(false);
      }
    };

    loadCafe();
  }, [placeId, navigate, toast]);

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    // Validate file type and size
    if (!file.type.startsWith('image/')) {
      toast({
        title: "Invalid file type",
        description: "Please select an image file",
        variant: "destructive"
      });
      return;
    }

    if (file.size > 10 * 1024 * 1024) { // 10MB limit
      toast({
        title: "File too large",
        description: "Please select an image smaller than 10MB",
        variant: "destructive"
      });
      return;
    }

    setSelectedFile(file);
    
    // Create preview
    const preview = URL.createObjectURL(file);
    setPreviewUrl(preview);
  };

  const handleUpload = async () => {
    if (!selectedFile || !cafe) return;

    setIsUploading(true);
    try {
      // Upload to Cloudinary
      const uploadResult = await uploadImage(selectedFile);
      
      if (uploadResult.success && uploadResult.data) {
        const uploadedUrl = uploadResult.data.secure_url;
        
        // Add photo to cafe via API
        const response = await fetch('/api/add-cafe-photo', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            cafeId: cafe.id,
            photoUrl: uploadedUrl,
            uploadedBy: 'current-user' // Note: Will be replaced with actual user ID from auth context
          })
        });

        const result = await response.json();

        if (result.success) {
          toast({
            title: "Photo uploaded!",
            description: "Your photo has been added to the cafe"
          });
          navigate(`/cafe/${cafe.placeId}`);
        } else {
          throw new Error(result.error || 'Failed to add photo to cafe');
        }
      } else {
        throw new Error(uploadResult.error || 'Failed to upload image');
      }
    } catch (error) {
      console.error('Upload failed:', error);
      toast({
        title: "Upload failed",
        description: error instanceof Error ? error.message : "Failed to upload photo",
        variant: "destructive"
      });
    } finally {
      setIsUploading(false);
    }
  };

  const handleRemoveFile = () => {
    if (previewUrl) {
      URL.revokeObjectURL(previewUrl);
    }
    setSelectedFile(null);
    setPreviewUrl(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  if (loading) {
    return (
      <AppLayout>
        <div className="max-w-md mx-auto min-h-screen bg-background flex items-center justify-center">
          <div className="text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
            <p className="text-muted-foreground">Loading cafe details...</p>
          </div>
        </div>
      </AppLayout>
    );
  }

  if (!cafe) {
    return (
      <AppLayout>
        <div className="max-w-md mx-auto min-h-screen bg-background flex items-center justify-center">
          <div className="text-center p-6">
            <h2 className="text-xl font-semibold mb-2">Cafe Not Found</h2>
            <p className="text-muted-foreground mb-4">This cafe could not be found.</p>
            <Button onClick={() => navigate("/explore")}>Back to Explore</Button>
          </div>
        </div>
      </AppLayout>
    );
  }

  return (
    <AppLayout>
      <div className="max-w-md mx-auto min-h-screen bg-background">
        {/* Header */}
        <div className="sticky top-0 z-40 bg-background/95 backdrop-blur-md border-b border-border p-4">
          <div className="flex items-center gap-3">
            <Button
              variant="ghost"
              size="icon"
              onClick={() => navigate(-1)}
              className="rounded-full"
            >
              <ArrowLeft className="w-5 h-5" />
            </Button>
            <div className="min-w-0 flex-1">
              <h1 className="text-lg font-semibold">Add Photo</h1>
              <p className="text-sm text-muted-foreground">{cafe.name}</p>
            </div>
          </div>
        </div>

        <div className="p-4 space-y-6">
          {/* Upload Area */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Camera className="w-5 h-5 text-primary" />
                Select Photo
              </CardTitle>
            </CardHeader>
            <CardContent>
              {previewUrl ? (
                <div className="space-y-4">
                  <div className="relative">
                    <img
                      src={previewUrl}
                      alt="Preview"
                      className="w-full h-64 object-cover rounded-lg"
                    />
                    <Button
                      variant="ghost"
                      size="sm"
                      className="absolute top-2 right-2 h-8 w-8 p-0 bg-black/50 hover:bg-black/70 text-white"
                      onClick={handleRemoveFile}
                    >
                      <X className="w-4 h-4" />
                    </Button>
                  </div>
                  
                  <div className="flex gap-3">
                    <Button
                      variant="outline"
                      onClick={handleRemoveFile}
                      className="flex-1"
                    >
                      Choose Different Photo
                    </Button>
                    <Button
                      onClick={handleUpload}
                      disabled={isUploading}
                      className="flex-1 coffee-gradient text-white"
                    >
                      {isUploading ? (
                        <>
                          <Loader2 className="w-4 h-4 animate-spin mr-2" />
                          Uploading...
                        </>
                      ) : (
                        <>
                          <Upload className="w-4 h-4 mr-2" />
                          Upload Photo
                        </>
                      )}
                    </Button>
                  </div>
                </div>
              ) : (
                <div 
                  className="border-2 border-dashed border-border rounded-lg p-8 text-center cursor-pointer hover:bg-muted/50 transition-colors"
                  onClick={() => fileInputRef.current?.click()}
                >
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept="image/*"
                    onChange={handleFileSelect}
                    className="hidden"
                  />
                  <div className="space-y-3">
                    <div className="w-12 h-12 rounded-full bg-primary/10 flex items-center justify-center mx-auto">
                      <Camera className="w-6 h-6 text-primary" />
                    </div>
                    <div>
                      <h3 className="font-medium text-foreground mb-1">Add a photo</h3>
                      <p className="text-sm text-muted-foreground mb-3">
                        Help others discover {cafe.name}
                      </p>
                      <Button variant="outline" className="gap-2">
                        <Upload className="w-4 h-4" />
                        Choose Photo
                      </Button>
                    </div>
                  </div>
                </div>
              )}
            </CardContent>
          </Card>

          {/* Guidelines */}
          <Card className="bg-muted/30 border-0">
            <CardContent className="p-4">
              <h4 className="font-medium mb-2">Photo Guidelines</h4>
              <ul className="text-sm text-muted-foreground space-y-1">
                <li>‚Ä¢ Show the cafe's atmosphere and interior</li>
                <li>‚Ä¢ Include coffee, food, or drinks if possible</li>
                <li>‚Ä¢ Good lighting and clear focus</li>
                <li>‚Ä¢ Maximum file size: 10MB</li>
              </ul>
            </CardContent>
          </Card>
        </div>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/Moments.tsx
================
import { useState, useEffect } from "react";
import { AppLayout } from "@/components/Layout/AppLayout";
import { PostCard } from "@/components/Feed/PostCard";
import { fetchPosts } from "@/services/postService";
import { Loader2, Coffee } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useNavigate } from "react-router-dom";

export default function Moments() {
  const navigate = useNavigate();
  const [posts, setPosts] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function loadPosts() {
      setLoading(true);
      try {
        const result = await fetchPosts();
        if (result.success) {
          setPosts(result.data);
        } else {
          setError(result.error || 'Failed to load posts');
        }
      } catch (err) {
        setError('Failed to load posts');
      } finally {
        setLoading(false);
      }
    }
    loadPosts();
  }, []);

  return (
    <AppLayout>
      <div className="max-w-md mx-auto min-h-screen bg-background pb-20">
        {/* Header */}
        <div className="sticky top-0 z-40 bg-background/95 backdrop-blur-md border-b border-border p-4">
          <h1 className="text-2xl font-bold">Moments</h1>
          <p className="text-sm text-muted-foreground">Coffee moments from the community</p>
        </div>

        {/* Content */}
        <div className="p-4">
          {loading ? (
            <div className="flex flex-col items-center justify-center py-16">
              <Loader2 className="w-8 h-8 animate-spin text-primary mb-4" />
              <p className="text-muted-foreground">Loading moments...</p>
            </div>
          ) : error ? (
            <div className="flex flex-col items-center justify-center py-16">
              <Coffee className="w-12 h-12 text-muted-foreground mb-4" />
              <p className="text-muted-foreground mb-4">{error}</p>
              <Button onClick={() => window.location.reload()}>Try Again</Button>
            </div>
          ) : posts.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-16">
              <Coffee className="w-12 h-12 text-muted-foreground mb-4" />
              <h3 className="text-lg font-semibold mb-2">No moments yet</h3>
              <p className="text-muted-foreground text-center mb-4">
                Be the first to share your coffee moment!
              </p>
              <Button 
                onClick={() => navigate('/share')}
                className="coffee-gradient text-white"
              >
                Share a Moment
              </Button>
            </div>
          ) : (
            <div className="space-y-6">
              {posts.map((post) => (
                <PostCard 
                  key={post.id}
                  post={{
                    id: post.id,
                    cafeName: post.cafe?.name || 'Unknown Cafe',
                    neighborhood: post.cafe?.neighborhood || '',
                    imageUrl: post.imageUrl,
                    tags: post.tags || [],
                    rating: post.rating || 0,
                    textReview: post.textReview || '',
                    createdAt: new Date(post.createdAt).toLocaleString(),
                    likes: post.likes || 0,
                    comments: post.comments || 0
                  }}
                />
              ))}
            </div>
          )}
        </div>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/NotFound.tsx
================
import { useLocation } from "react-router-dom";
import { useEffect } from "react";

const NotFound = () => {
  const location = useLocation();

  useEffect(() => {
    console.error("404 Error: User attempted to access non-existent route:", location.pathname);
  }, [location.pathname]);

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-100">
      <div className="text-center">
        <h1 className="mb-4 text-4xl font-bold">404</h1>
        <p className="mb-4 text-xl text-gray-600">Oops! Page not found</p>
        <a href="/" className="text-blue-500 underline hover:text-blue-700">
          Return to Home
        </a>
      </div>
    </div>
  );
};

export default NotFound;

================
File: src/pages/Profile.tsx
================
import { Camera, Coffee, Heart, MapPin, Settings, User as UserIcon, MessageSquare } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { AppLayout } from "@/components/Layout/AppLayout";
import { PostCard } from "@/components/Feed/PostCard";
import { UsernameSelection } from "@/components/UsernameSelection";
import { getUsername } from "@/services/userService";
import { getFavorites } from "@/services/favoritesService";
import { getActivityFeed } from "@/services/activityService";
import { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";

// Mock data - will be replaced with real data from Supabase
const userStats = {
  checkins: 0,
  favorites: 0,
  photos: 0,
  badges: []
};

const userPosts: any[] = [];

export default function Profile() {
  const navigate = useNavigate();
  const [username, setUsername] = useState<string | null>(null);
  const [showUsernameSelect, setShowUsernameSelect] = useState(false);
  const [loading, setLoading] = useState(true);
  const [favorites, setFavorites] = useState<any[]>([]);
  const [activities, setActivities] = useState<any[]>([]);
  const [stats, setStats] = useState({
    checkins: 0,
    favorites: 0,
    photos: 0,
    badges: []
  });

  useEffect(() => {
    const loadProfileData = async () => {
      const usernameRes = await getUsername();
      if (usernameRes.success) {
        setUsername(usernameRes.data);
        if (!usernameRes.data) setShowUsernameSelect(true);
      }
      
      // Load favorites and activities
      const [favoritesRes, activitiesRes] = await Promise.all([
        getFavorites(),
        getActivityFeed()
      ]);
      
      if (favoritesRes.success) {
        setFavorites(favoritesRes.data);
        setStats(prev => ({ ...prev, favorites: favoritesRes.data.length }));
      }
      
      if (activitiesRes.success) {
        setActivities(activitiesRes.data);
        const checkins = activitiesRes.data.filter(a => a.activityType === 'check-in').length;
        const photos = activitiesRes.data.filter(a => a.activityType === 'photo-upload').length;
        setStats(prev => ({ ...prev, checkins, photos }));
      }
      
      setLoading(false);
    };
    
    loadProfileData();
  }, []);

  if (loading) {
    return (
      <AppLayout>
        <div className="max-w-md mx-auto min-h-screen bg-background flex items-center justify-center">
          <div className="text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
            <p className="text-muted-foreground">Loading profile...</p>
          </div>
        </div>
      </AppLayout>
    );
  }

  if (showUsernameSelect) {
    return <UsernameSelection onComplete={() => setShowUsernameSelect(false)} />;
  }

  return (
    <AppLayout>
      <div className="max-w-md mx-auto min-h-screen bg-background">
        {/* Header */}
        <div className="sticky top-0 z-40 bg-background/95 backdrop-blur-md border-b border-border p-4">
          <div className="flex items-center justify-between">
            <h1 className="text-2xl font-bold">Profile</h1>
            <Button variant="ghost" size="icon">
              <Settings className="w-5 h-5" />
            </Button>
          </div>
        </div>

        <div className="p-4 space-y-6">
          {/* Profile Header */}
          <Card className="shadow-coffee border-0">
            <CardContent className="p-6 text-center">
              <div className="w-20 h-20 bg-primary/20 rounded-full flex items-center justify-center mx-auto mb-4">
                <UserIcon className="w-10 h-10 text-primary" />
              </div>
              <h2 className="text-xl font-bold mb-1">@{username || "Coffee Lover"}</h2>
              <p className="text-sm text-muted-foreground mb-4">Houston, TX</p>
              
              {/* Stats */}
              <div className="grid grid-cols-3 gap-4 mb-6">
                <div className="text-center">
                  <div className="text-2xl font-bold text-primary">{stats.checkins}</div>
                  <div className="text-xs text-muted-foreground">Check-ins</div>
                </div>
                <div className="text-center">
                  <div className="text-2xl font-bold text-primary">{stats.favorites}</div>
                  <div className="text-xs text-muted-foreground">Favorites</div>
                </div>
                <div className="text-center">
                  <div className="text-2xl font-bold text-primary">{stats.photos}</div>
                  <div className="text-xs text-muted-foreground">Photos</div>
                </div>
              </div>

              {/* Badges */}
              <div className="space-y-2">
                <h3 className="text-sm font-semibold">Badges</h3>
                <div className="flex flex-wrap justify-center gap-2">
                  {stats.badges.map((badge) => (
                    <Badge
                      key={badge}
                      variant="secondary"
                      className="bg-primary/10 text-primary border-0"
                    >
                      {badge}
                    </Badge>
                  ))}
                  {stats.badges.length === 0 && (
                    <p className="text-xs text-muted-foreground">No badges yet</p>
                  )}
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Quick Actions */}
          <div className="grid grid-cols-2 gap-4">
            <Card 
              className="coffee-card coffee-interactive"
              onClick={() => navigate('/share')}
            >
              <CardContent className="p-4 text-center">
                <MapPin className="w-8 h-8 mx-auto mb-2 coffee-location-pin" />
                <p className="text-sm font-medium coffee-cafe-name">Check In</p>
              </CardContent>
            </Card>
            <Card 
              className="coffee-card coffee-interactive"
              onClick={() => navigate('/explore')}
            >
              <CardContent className="p-4 text-center">
                <Heart className="w-8 h-8 mx-auto mb-2 coffee-location-pin" />
                <p className="text-sm font-medium coffee-cafe-name">Favorites</p>
              </CardContent>
            </Card>
            <Card 
              className="coffee-card coffee-interactive"
              onClick={() => navigate('/feedback')}
            >
              <CardContent className="p-4 text-center">
                <MessageSquare className="w-8 h-8 mx-auto mb-2 coffee-location-pin" />
                <p className="text-sm font-medium coffee-cafe-name">Feedback</p>
              </CardContent>
            </Card>
          </div>

          {/* Content Tabs */}
          <Tabs defaultValue="posts" className="w-full">
            <TabsList className="grid w-full grid-cols-3 bg-muted/50">
              <TabsTrigger value="posts">Posts</TabsTrigger>
              <TabsTrigger value="photos">Photos</TabsTrigger>
              <TabsTrigger value="activity">Activity</TabsTrigger>
            </TabsList>

            <TabsContent value="posts" className="space-y-4 mt-4">
              {userPosts.map((post) => (
                <PostCard key={post.id} post={post} />
              ))}
            </TabsContent>

            <TabsContent value="photos" className="mt-4">
              <div className="grid grid-cols-3 gap-2">
                {Array.from({ length: 9 }, (_, i) => (
                  <div
                    key={i}
                    className="aspect-square bg-muted rounded-lg overflow-hidden"
                  >
                    <img 
                      src="/placeholder.svg" 
                      alt={`Photo ${i + 1}`}
                      className="w-full h-full object-cover"
                    />
                  </div>
                ))}
              </div>
            </TabsContent>

            <TabsContent value="activity" className="mt-4 space-y-4">
              <div className="space-y-3">
                {activities.length > 0 ? (
                  activities.map((activity) => (
                    <div key={activity.id} className="flex items-center gap-3 p-3 bg-card rounded-lg">
                      {activity.activityType === 'check-in' && <Coffee className="w-5 h-5 text-primary" />}
                      {activity.activityType === 'favorite' && <Heart className="w-5 h-5 text-primary" />}
                      {activity.activityType === 'photo-upload' && <Camera className="w-5 h-5 text-primary" />}
                      {activity.activityType === 'review' && <Coffee className="w-5 h-5 text-primary" />}
                      <div className="flex-1">
                        <p className="text-sm">
                          {activity.activityType === 'check-in' && `Checked in at ${activity.metadata?.cafeName || 'a cafe'}`}
                          {activity.activityType === 'favorite' && `Added ${activity.metadata?.cafeName || 'a cafe'} to favorites`}
                          {activity.activityType === 'photo-upload' && `Posted a photo at ${activity.metadata?.cafeName || 'a cafe'}`}
                          {activity.activityType === 'review' && `Reviewed ${activity.metadata?.cafeName || 'a cafe'}`}
                        </p>
                        <p className="text-xs text-muted-foreground">
                          {new Date(activity.createdAt).toLocaleDateString()}
                        </p>
                      </div>
                    </div>
                  ))
                ) : (
                  <div className="text-center py-8">
                    <p className="text-muted-foreground">No activity yet</p>
                  </div>
                )}
              </div>
            </TabsContent>
          </Tabs>
        </div>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/RecentlyViewed.tsx
================
import { useState, useEffect } from "react";
import { Clock, MapPin, Star, Eye } from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { AppLayout } from "@/components/Layout/AppLayout";
import { useNavigate } from "react-router-dom";

interface RecentCafe {
  id: string;
  placeId: string;
  name: string;
  neighborhood: string;
  rating?: number;
  userRating?: number;
  tags: string[];
  image: string;
  visitedAt: string;
  priceLevel?: number;
}

const STORAGE_KEY = "bean-scene-recently-viewed";
const MAX_RECENT_CAFES = 20;


// Utility functions for local storage
export function addToRecentlyViewed(cafe: Omit<RecentCafe, 'visitedAt'>) {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    const recent: RecentCafe[] = stored ? JSON.parse(stored) : [];
    
    // Remove if already exists
    const filtered = recent.filter(item => item.placeId !== cafe.placeId);
    
    // Add to beginning with current timestamp
    const updated = [
      { ...cafe, visitedAt: new Date().toISOString() },
      ...filtered
    ].slice(0, MAX_RECENT_CAFES);
    
    localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
  } catch (error) {
    console.error('Failed to save to recently viewed:', error);
  }
}

export function getRecentlyViewed(): RecentCafe[] {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    return stored ? JSON.parse(stored) : [];
  } catch (error) {
    console.error('Failed to load recently viewed:', error);
    return [];
  }
}

export function clearRecentlyViewed() {
  try {
    localStorage.removeItem(STORAGE_KEY);
  } catch (error) {
    console.error('Failed to clear recently viewed:', error);
  }
}

function getTimeAgo(dateString: string): string {
  const now = new Date();
  const date = new Date(dateString);
  const diffInMinutes = Math.floor((now.getTime() - date.getTime()) / (1000 * 60));
  
  if (diffInMinutes < 60) {
    return `${diffInMinutes}m ago`;
  } else if (diffInMinutes < 1440) {
    return `${Math.floor(diffInMinutes / 60)}h ago`;
  } else {
    return `${Math.floor(diffInMinutes / 1440)}d ago`;
  }
}

export default function RecentlyViewed() {
  const navigate = useNavigate();
  const [recentCafes, setRecentCafes] = useState<RecentCafe[]>([]);

  useEffect(() => {
    setRecentCafes(getRecentlyViewed());
  }, []);

  const handleClearAll = () => {
    clearRecentlyViewed();
    setRecentCafes([]);
  };

  const renderPriceLevel = (level?: number) => {
    if (!level) return null;
    return Array.from({ length: 4 }, (_, i) => (
      <span
        key={i}
        className={`text-xs ${
          i < level ? "text-foreground" : "text-muted-foreground"
        }`}
      >
        $
      </span>
    ));
  };

  return (
    <AppLayout>
      <div className="max-w-md mx-auto min-h-screen bg-background">
        {/* Header */}
        <div className="sticky top-0 z-40 bg-background/95 backdrop-blur-md border-b border-border p-4">
          <div className="flex items-center justify-between mb-2">
            <div className="flex items-center gap-2">
              <Eye className="w-6 h-6 text-primary" />
              <h1 className="text-2xl font-bold">Recently Viewed</h1>
            </div>
            {recentCafes.length > 0 && (
              <Button 
                variant="ghost" 
                size="sm" 
                onClick={handleClearAll}
                className="text-muted-foreground hover:text-foreground"
              >
                Clear All
              </Button>
            )}
          </div>
          <p className="text-sm text-muted-foreground">Cafes you've visited recently</p>
        </div>

        <div className="p-4">
          {recentCafes.length > 0 ? (
            <div className="space-y-4">
              {recentCafes.map((cafe) => (
                <Card 
                  key={cafe.placeId}
                  className="cursor-pointer hover:shadow-coffee transition-smooth shadow-warm border-0"
                  onClick={() => navigate(`/cafe/${cafe.placeId}`)}
                >
                  <CardContent className="p-4">
                    <div className="flex gap-4">
                      <img
                        src={cafe.image}
                        alt={cafe.name}
                        className="w-20 h-20 rounded-lg object-cover"
                      />
                      <div className="flex-1 min-w-0">
                        <div className="flex items-start justify-between mb-2">
                          <h3 className="font-semibold text-lg">{cafe.name}</h3>
                          <div className="flex items-center gap-1 text-xs text-muted-foreground">
                            <Clock className="w-3 h-3" />
                            {getTimeAgo(cafe.visitedAt)}
                          </div>
                        </div>
                        
                        <div className="flex items-center gap-2 mb-2">
                          <MapPin className="w-4 h-4 text-muted-foreground" />
                          <span className="text-sm text-muted-foreground">{cafe.neighborhood}</span>
                          {cafe.priceLevel && (
                            <div className="flex items-center ml-auto">
                              {renderPriceLevel(cafe.priceLevel)}
                            </div>
                          )}
                        </div>

                        {(cafe.rating || cafe.userRating) && (
                          <div className="flex items-center gap-4 mb-3">
                            {cafe.rating && (
                              <div className="flex items-center gap-1">
                                <Star className="w-4 h-4 fill-yellow-400 text-yellow-400" />
                                <span className="text-sm font-medium">{cafe.rating}</span>
                                <span className="text-xs text-muted-foreground">Google</span>
                              </div>
                            )}
                            {cafe.userRating && (
                              <div className="flex items-center gap-1">
                                <Star className="w-4 h-4 fill-primary text-primary" />
                                <span className="text-sm font-medium">{cafe.userRating}</span>
                                <span className="text-xs text-muted-foreground">You</span>
                              </div>
                            )}
                          </div>
                        )}

                        <div className="flex flex-wrap gap-1">
                          {cafe.tags.slice(0, 2).map((tag) => (
                            <Badge
                              key={tag}
                              variant="secondary"
                              className="text-xs px-2 py-0 bg-accent/30 text-accent-foreground border-0"
                            >
                              #{tag}
                            </Badge>
                          ))}
                          {cafe.tags.length > 2 && (
                            <Badge
                              variant="secondary"
                              className="text-xs px-2 py-0 bg-muted/50 text-muted-foreground border-0"
                            >
                              +{cafe.tags.length - 2}
                            </Badge>
                          )}
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          ) : (
            <div className="text-center py-20">
              <Eye className="w-16 h-16 mx-auto mb-4 text-muted-foreground" />
              <h3 className="text-lg font-semibold mb-2">No recent visits</h3>
              <p className="text-muted-foreground mb-6">
                Find the perfect cozy coffee spot
              </p>
              <Button 
                onClick={() => navigate('/explore')}
                className="coffee-gradient text-white shadow-coffee hover:shadow-glow transition-smooth"
              >
                Explore Cafes
              </Button>
            </div>
          )}
        </div>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/Search.tsx
================
import { useState, useEffect, useCallback } from "react";
import { Search as SearchIcon, MapPin, Star, Navigation, Cloud, Sun, Filter, ChevronDown, X } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { AppLayout } from "@/components/Layout/AppLayout";
import { ExploreFilters, FilterState } from "@/components/Filters/ExploreFilters";
import { useNavigate } from "react-router-dom";
import { fetchCafes } from "@/services/cafeService";
import { Cafe, Post } from "@/services/types";
import { debounce, getCurrentLocation } from "@/services/utils";
import { calculateDistance } from "@/utils/distanceUtils";
import { toast } from "@/hooks/use-toast";
import { getCafeEmoji } from "@/utils/emojiPlaceholders";


const popularTags = [
  "latte-art", "cozy-vibes", "laptop-friendly", "third-wave",
  "cold-brew", "pastries", "rooftop", "instagram-worthy"
];

interface UserLocation {
  latitude: number;
  longitude: number;
}

export default function Search() {
  const navigate = useNavigate();

  const [searchQuery, setSearchQuery] = useState(() => {
    return localStorage.getItem('explore-search-query') || '';
  });
  const [selectedTags, setSelectedTags] = useState<string[]>(() => {
    const saved = localStorage.getItem('explore-selected-tags');
    return saved ? JSON.parse(saved) : [];
  });
  const [activeTab, setActiveTab] = useState("cafes");
  const [showFilters, setShowFilters] = useState(false);

  const [allCafes, setAllCafes] = useState<Cafe[]>([]);
  const [searchResults, setSearchResults] = useState<Cafe[]>([]);
  const [postResults, setPostResults] = useState<Post[]>([]);

  const [loading, setLoading] = useState(false);
  const [initialLoading, setInitialLoading] = useState(true);

  // Location
  const [userLocation, setUserLocation] = useState<UserLocation | null>(null);
  const [locationError, setLocationError] = useState("");
  const [isRequestingLocation, setIsRequestingLocation] = useState(false);

  // Filters - with persistence
  const [filters, setFilters] = useState<FilterState>(() => {
    // Try to load filters from localStorage
    const savedFilters = localStorage.getItem('explore-filters');
    if (savedFilters) {
      try {
        return JSON.parse(savedFilters);
      } catch (error) {
        console.error('Error parsing saved filters:', error);
      }
    }
    // Default filters
    return {
      priceLevel: [],
      rating: 0,
      distance: 25,
      openNow: false,
      neighborhoods: []
    };
  });

  /** Load cafes on mount */
  useEffect(() => {
    const loadAllCafes = async () => {
      try {
        setInitialLoading(true);
        const result = await fetchCafes();
        if (result.success) {
          setAllCafes(result.data);
          // Don't set searchResults directly - let updateResults handle it
        } else {
          toast({
            title: "Error loading cafes",
            description: result.error || "Failed to load cafes",
            variant: "destructive",
          });
        }
      } catch (err) {
        console.error("Error loading cafes:", err);
      } finally {
        setInitialLoading(false);
      }
    };

    loadAllCafes();
  }, []);

  /** Update results when allCafes changes */
  useEffect(() => {
    if (allCafes.length > 0) {
      // Inline the updateResults logic to avoid circular dependencies
      try {
        let results = allCafes;

        if (searchQuery.trim()) {
          const query = searchQuery.toLowerCase();
          results = results.filter(
            (cafe) =>
              cafe.name.toLowerCase().includes(query) ||
              (cafe.neighborhood &&
                cafe.neighborhood.toLowerCase().includes(query)) ||
              cafe.tags.some((tag) => tag.toLowerCase().includes(query))
          );
        }

        results = applyFilters(results);
        results = sortCafes(results);
        setSearchResults(results);
      } catch (error) {
        console.error("Error updating results:", error);
      }
    }
  }, [allCafes, filters, searchQuery, selectedTags, userLocation]);

  /** Save filters to localStorage whenever they change */
  useEffect(() => {
    localStorage.setItem('explore-filters', JSON.stringify(filters));
  }, [filters]);

  /** Save search query to localStorage */
  useEffect(() => {
    localStorage.setItem('explore-search-query', searchQuery);
  }, [searchQuery]);

  /** Save selected tags to localStorage */
  useEffect(() => {
    localStorage.setItem('explore-selected-tags', JSON.stringify(selectedTags));
  }, [selectedTags]);

  /** Sort logic - default to rating */
  const sortCafes = (cafes: Cafe[]): Cafe[] => {
    const sorted = [...cafes];
    
    // Default sort by rating (highest first)
    return sorted.sort(
      (a, b) =>
        (b.googleRating || b.rating || 0) - (a.googleRating || a.rating || 0)
    );
  };

  /** Filter logic */
  const applyFilters = (cafes: Cafe[]): Cafe[] => {
    let filtered = [...cafes];

    if (filters.priceLevel.length > 0) {
      filtered = filtered.filter(
        (cafe) =>
          cafe.priceLevel && filters.priceLevel.includes(cafe.priceLevel)
      );
    }

    if (filters.rating > 0) {
      filtered = filtered.filter(
        (cafe) =>
          (cafe.googleRating || cafe.rating || 0) >= filters.rating
      );
    }

    if (userLocation && filters.distance < 25) {
      filtered = filtered.filter((cafe) => {
        if (!cafe.latitude || !cafe.longitude) {
          return false; // Skip cafes without coordinates
        }
        const distance = calculateDistance(
          userLocation.latitude,
          userLocation.longitude,
          cafe.latitude,
          cafe.longitude
        );
        return distance <= filters.distance;
      });
    }

    if (filters.neighborhoods.length > 0) {
      filtered = filtered.filter((cafe) =>
        cafe.neighborhood && filters.neighborhoods.includes(cafe.neighborhood)
      );
    }

    if (filters.openNow) {
      // For now, we'll skip the openNow filter since we don't have real-time hours data
      // This could be implemented later with actual opening hours data
      console.log('Open now filter is active but not implemented yet');
    }

    if (selectedTags.length > 0) {
      filtered = filtered.filter((cafe) =>
        cafe.tags.some((tag) => selectedTags.includes(tag))
      );
    }

    return filtered;
  };


  /** Debounced search */
  const handleSearchChange = (value: string) => {
    setSearchQuery(value);
    // Results will be updated automatically by useEffect when searchQuery changes
  };

  /** Location request handler */
  const handleRequestLocation = async () => {
    setIsRequestingLocation(true);
    setLocationError("");
    
    try {
      console.log("Requesting location...");
      const position = await getCurrentLocation();
      console.log("Location received:", position.coords);
      
      const { latitude, longitude } = position.coords;
      setUserLocation({ latitude, longitude });
      
      // Update distance filter to a reasonable default when location is enabled
      setFilters(prev => ({
        ...prev,
        distance: prev.distance === 25 ? 10 : prev.distance
      }));
      
      toast({
        title: "Location Enabled",
        description: "You can now filter cafes by distance from your location.",
      });
    } catch (error: any) {
      console.error("Location error:", error);
      setLocationError(error.message);
      
      let errorMessage = "Please enable location access to filter by distance.";
      if (error.code === 1) {
        errorMessage = "Location access denied. Please allow location access in your browser settings.";
      } else if (error.code === 2) {
        errorMessage = "Location unavailable. Please check your internet connection.";
      } else if (error.code === 3) {
        errorMessage = "Location request timed out. Please try again.";
      }
      
      toast({
        title: "Location Access Failed",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsRequestingLocation(false);
    }
  };

  /** Filters + sort handlers */
  const handleFiltersChange = (newFilters: FilterState) => {
    try {
      console.log("Filter change:", newFilters);
      setFilters(newFilters);
      // updateResults() will be called automatically by useEffect
    } catch (error) {
      console.error("Error in handleFiltersChange:", error);
      toast({
        title: "Filter Error",
        description: "There was an error applying the filter. Please try again.",
        variant: "destructive",
      });
    }
  };

  const clearFilters = () => {
    setSelectedTags([]);
    setSearchQuery("");
    setFilters({
      priceLevel: [],
      rating: 0,
      distance: userLocation ? 10 : 25,
      openNow: false,
      neighborhoods: []
    });
    // updateResults() will be called automatically by useEffect
  };


  // Calculate active filter count
  const activeFilterCount = selectedTags.length + 
    (filters.priceLevel.length > 0 ? 1 : 0) + 
    (filters.neighborhoods.length > 0 ? 1 : 0);

  return (
    <AppLayout>
      <div className="max-w-md mx-auto min-h-screen bg-background">

        {/* Main Header */}
        <div className="sticky top-0 z-40 coffee-header p-4">
          <div className="flex items-center justify-between mb-4">
            <h1 className="text-2xl font-bold coffee-heading">Explore</h1>
            <div className="flex items-center gap-3">
              {/* Filter Icon with Badge */}
              <div className="relative">
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={() => setShowFilters(!showFilters)}
                  className="relative"
                >
                  <Filter className="w-5 h-5" />
                  {activeFilterCount > 0 && (
                    <div className="absolute -top-1 -right-1 w-5 h-5 bg-primary text-primary-foreground text-xs rounded-full flex items-center justify-center">
                      {activeFilterCount}
                    </div>
                  )}
                </Button>
              </div>
            </div>
          </div>

          {/* Search bar */}
          <div className="relative mb-3">
            <SearchIcon className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-white/80" />
            <Input
              placeholder="Search cafes..."
              value={searchQuery}
              onChange={(e) => handleSearchChange(e.target.value)}
              className="pl-10 coffee-search-bar bg-white/90 border-white/20 text-foreground"
            />
          </div>
        </div>

        {/* Filters Panel */}
        <ExploreFilters
          filters={filters}
          onFiltersChange={handleFiltersChange}
          onClearFilters={clearFilters}
          isOpen={showFilters}
          onOpenChange={setShowFilters}
          userLocation={userLocation}
          onRequestLocation={handleRequestLocation}
          isRequestingLocation={isRequestingLocation}
        />

        <div className="p-4">
          {/* Popular tags */}
          <div className="mb-6">
            <h3 className="font-semibold mb-3">Popular Tags</h3>
            <div className="flex flex-wrap gap-2">
              {popularTags.map((tag) => (
                <Badge
                  key={tag}
                  variant={selectedTags.includes(tag) ? "default" : "secondary"}
                  className="coffee-tag"
                  onClick={() =>
                    setSelectedTags((prev) =>
                      prev.includes(tag)
                        ? prev.filter((t) => t !== tag)
                        : [...prev, tag]
                    )
                  }
                >
                  #{tag}
                </Badge>
              ))}
            </div>
          </div>

          {/* Tabs */}
          <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
            <TabsList className="grid w-full grid-cols-2 bg-muted/50">
              <TabsTrigger value="cafes" className="text-sm">
                Cafes
              </TabsTrigger>
              <TabsTrigger value="posts" className="text-sm">
                Posts
              </TabsTrigger>
            </TabsList>

            {/* Cafes tab */}
            <TabsContent value="cafes" className="space-y-4 mt-4">
              {initialLoading ? (
                <div className="text-center py-8">
                  <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary mx-auto mb-2"></div>
                  <p className="text-muted-foreground">Loading cafes...</p>
                </div>
              ) : searchResults.length === 0 ? (
                <div className="text-center py-12">
                  <SearchIcon className="w-12 h-12 mx-auto text-muted-foreground mb-4" />
                  <h3 className="text-lg font-semibold mb-2">No Cafes Found</h3>
                  <p className="text-muted-foreground mb-4">
                    {searchQuery || selectedTags.length > 0
                      ? "Try adjusting your search terms or filters"
                      : "No cafes match your current filters"}
                  </p>
                  <Button onClick={clearFilters} variant="outline">
                    Clear All Filters
                  </Button>
                </div>
              ) : (
                searchResults.map((cafe) => (
                  <div
                    key={cafe.id}
                    className="coffee-card p-3 cursor-pointer coffee-interactive"
                    onClick={() => navigate(`/cafe/${cafe.placeId}`)}
                  >
                    <div className="flex items-center gap-3">
                      {/* Emoji placeholder */}
                      <div className="w-12 h-12 bg-gradient-to-br from-[#8b5a3c] to-[#6b4423] rounded-lg flex-shrink-0 flex items-center justify-center text-white text-xl shadow-lg">
                        {getCafeEmoji(cafe.id || cafe.placeId)}
                      </div>
                    
                    {/* Cafe info */}
                    <div className="flex-1 min-w-0">
                      <h3 className="font-medium truncate text-sm">
                        {cafe.name.length > 30 ? `${cafe.name.substring(0, 30)}...` : cafe.name}
                      </h3>
                      <div className="flex items-center gap-1 mt-1">
                        <MapPin className="w-3 h-3 text-muted-foreground" />
                        <span className="text-xs text-muted-foreground">
                          {cafe.neighborhood || "Unknown"}
                        </span>
                      </div>
                    </div>
                    
                    {/* Rating */}
                    <div className="flex items-center gap-1">
                      <Star className="w-4 h-4 coffee-star" />
                      <span className="text-sm font-medium">
                        {(cafe.googleRating || cafe.rating || 0).toFixed(1)}
                      </span>
                    </div>
                    </div>
                  </div>
                ))
              )}
            </TabsContent>

            {/* Posts tab */}
            <TabsContent value="posts" className="space-y-4 mt-4">
              {loading ? (
                <div className="text-center py-8">
                  <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary mx-auto mb-2"></div>
                  <p className="text-muted-foreground">Searching posts...</p>
                </div>
              ) : postResults.length === 0 ? (
                <div className="text-center py-12">
                  <SearchIcon className="w-12 h-12 mx-auto text-muted-foreground mb-4" />
                  <h3 className="text-lg font-semibold mb-2">No Posts Found</h3>
                  <p className="text-muted-foreground">
                    {searchQuery
                      ? "No posts match your search"
                      : "Search for posts to see results"}
                  </p>
                </div>
              ) : (
                postResults.map((post) => (
                  <Card key={post.id} className="shadow-sm border-0">
                    <CardContent className="p-4">
                      <div className="flex gap-4">
                        <img
                          src={post.imageUrl}
                          alt="Post"
                          className="w-16 h-16 rounded-lg object-cover"
                        />
                        <div className="flex-1 min-w-0">
                          <div className="flex items-start justify-between mb-1">
                            <h3 className="font-semibold truncate">
                              {post.cafe?.name || "Unknown Cafe"}
                            </h3>
                            <div className="flex items-center gap-1 ml-2">
                              <Star className="w-4 h-4 coffee-star" />
                              <span className="text-sm font-medium">{post.rating}</span>
                            </div>
                          </div>
                          <div className="flex items-center gap-2 mb-2">
                            <MapPin className="w-3 h-3 text-muted-foreground" />
                            <span className="text-sm text-muted-foreground">
                              {post.cafe?.neighborhood || "Unknown"}
                            </span>
                            <span className="text-xs text-muted-foreground">
                              ‚Ä¢ {new Date(post.createdAt).toLocaleDateString()}
                            </span>
                          </div>
                          <p className="text-sm text-muted-foreground mb-2 line-clamp-2">
                            {post.textReview}
                          </p>
                          <div className="flex flex-wrap gap-1">
                            {post.tags.slice(0, 3).map((tag) => (
                              <Badge
                                key={tag}
                                variant="secondary"
                                className="text-xs px-2 py-0 bg-accent/30 text-accent-foreground border-0"
                              >
                                #{tag}
                              </Badge>
                            ))}
                          </div>
                        </div>
                      </div>
                    </CardContent>
                  </Card>
                ))
              )}
            </TabsContent>
          </Tabs>
        </div>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/Share.tsx
================
import { Camera, MapPin } from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";
import { AppLayout } from "@/components/Layout/AppLayout";
import { useNavigate } from "react-router-dom";
import { useGoogleAnalytics } from "@/hooks/use-google-analytics";

export default function Share() {
  const navigate = useNavigate();
  const { trackEngagement } = useGoogleAnalytics();

  const handleCheckInClick = () => {
    trackEngagement('share_option_selected', { option: 'check_in' });
    navigate('/checkin');
  };

  const handleQuickPostClick = () => {
    trackEngagement('share_option_selected', { option: 'quick_post' });
    navigate('/post');
  };

  return (
    <AppLayout showBottomNav={false}>
      <div className="max-w-md mx-auto min-h-screen bg-background flex flex-col items-center justify-center p-6">
        <div className="mb-8 text-center">
          <h1 className="text-3xl font-bold mb-2">Share Your Coffee Moment</h1>
          <p className="text-muted-foreground">Choose how you'd like to share your experience</p>
        </div>

        <div className="w-full space-y-4 max-w-sm">
          {/* Check In Option */}
          <Card 
            className="cursor-pointer hover:shadow-warm transition-smooth border-2 hover:border-primary"
            onClick={handleCheckInClick}
          >
            <CardContent className="p-8 text-center">
              <div className="w-16 h-16 bg-primary/20 rounded-full flex items-center justify-center mx-auto mb-4">
                <MapPin className="w-8 h-8 text-primary" />
              </div>
              <h2 className="text-xl font-bold mb-2">Check In</h2>
              <p className="text-sm text-muted-foreground">
                Rate a cafe, add photos, tags, and share your complete experience
              </p>
            </CardContent>
          </Card>

          {/* Quick Post Option */}
          <Card 
            className="cursor-pointer hover:shadow-warm transition-smooth border-2 hover:border-primary"
            onClick={handleQuickPostClick}
          >
            <CardContent className="p-8 text-center">
              <div className="w-16 h-16 bg-primary/20 rounded-full flex items-center justify-center mx-auto mb-4">
                <Camera className="w-8 h-8 text-primary" />
              </div>
              <h2 className="text-xl font-bold mb-2">Quick Post</h2>
              <p className="text-sm text-muted-foreground">
                Share a photo with a caption - no rating or detailed review needed
              </p>
            </CardContent>
          </Card>
        </div>
      </div>
    </AppLayout>
  );
}

================
File: src/pages/TestMigration.tsx
================
import React, { useState } from 'react';

export default function TestMigration() {
  const [isRunning, setIsRunning] = useState(false);
  const [progress, setProgress] = useState({ current: 0, total: 0 });
  const [results, setResults] = useState({ success: 0, errors: 0 });
  const [logs, setLogs] = useState<string[]>([]);

  const addLog = (message: string) => {
    setLogs(prev => [...prev.slice(-20), `${new Date().toLocaleTimeString()}: ${message}`]);
  };

  const uploadToCloudinary = async (imageBlob: Blob, cafeId: string, placeid: string) => {
    const formData = new FormData();
    formData.append('file', imageBlob, `cafe-${placeid}.jpg`);
    formData.append('upload_preset', 'unsigned_hero_upload'); // Your preset name
    formData.append('folder', 'cafe-heroes');
    formData.append('public_id', `cafe-${placeid}`);

    const response = await fetch('https://api.cloudinary.com/v1_1/BeanSceneCloud/image/upload', {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      throw new Error(`Cloudinary upload failed: ${response.status}`);
    }

    return await response.json();
  };

  const updateCafePhoto = async (cafeId: string, photoUrl: string) => {
    const response = await fetch('/api/update-cafe-photo', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ cafeId, photoUrl }),
    });

    if (!response.ok) {
      throw new Error(`Database update failed: ${response.status}`);
    }

    return await response.json();
  };

  const runClientMigration = async () => {
    setIsRunning(true);
    setProgress({ current: 0, total: 0 });
    setResults({ success: 0, errors: 0 });
    setLogs([]);
    
    try {
      // Get cafes needing migration
      addLog('Fetching cafes needing photo migration...');
      const cafesResponse = await fetch('/api/get-cafes-for-migration');
      const { cafes } = await cafesResponse.json();
      
      setProgress({ current: 0, total: cafes.length });
      addLog(`Found ${cafes.length} cafes to process`);

      let successCount = 0;
      let errorCount = 0;

      for (let i = 0; i < cafes.length; i++) {
        const cafe = cafes[i];
        setProgress({ current: i + 1, total: cafes.length });
        
        try {
          addLog(`Processing ${cafe.name}...`);
          
          // Create Google Photos URL - API key handled server-side
          const googlePhotoUrl = `/api/place/photo?maxwidth=800&maxheight=600&photoreference=${cafe.google_photo_reference}`;
          
          // Download image (works in browser)
          const imageResponse = await fetch(googlePhotoUrl);
          if (!imageResponse.ok) {
            throw new Error(`Failed to fetch image: ${imageResponse.status}`);
          }
          
          const imageBlob = await imageResponse.blob();
          addLog(`Downloaded ${cafe.name} (${Math.round(imageBlob.size / 1024)}KB)`);
          
          // Upload to Cloudinary
          const uploadResult = await uploadToCloudinary(imageBlob, cafe.id, cafe.place_id);
          addLog(`Uploaded ${cafe.name} to Cloudinary`);
          
          // Update database
          await updateCafePhoto(cafe.id, uploadResult.secure_url);
          addLog(`‚úÖ Updated ${cafe.name} in database`);
          
          successCount++;
          setResults({ success: successCount, errors: errorCount });
          
        } catch (error) {
          errorCount++;
          addLog(`‚ùå Error processing ${cafe.name}: ${error instanceof Error ? error.message : 'Unknown error'}`);
          setResults({ success: successCount, errors: errorCount });
        }
        
        // Rate limiting
        if (i < cafes.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
      
      addLog(`Migration completed! Success: ${successCount}, Errors: ${errorCount}`);
      
    } catch (error) {
      addLog(`Migration failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsRunning(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 py-12">
      <div className="max-w-4xl mx-auto px-4">
        <div className="bg-white rounded-lg shadow-lg p-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-8">
            Photo Migration (Client-Side)
          </h1>
          
          <div className="space-y-6">
            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
              <h3 className="font-semibold text-blue-900 mb-2">How This Works</h3>
              <p className="text-blue-800 text-sm">
                This runs in your browser where Google Photos API works properly. 
                It downloads images from Google, uploads them to Cloudinary, and updates your database.
              </p>
            </div>

            <button
              onClick={runClientMigration}
              disabled={isRunning}
              className="bg-green-600 hover:bg-green-700 disabled:bg-green-300 text-white px-8 py-4 rounded-lg font-medium text-lg transition-colors"
            >
              {isRunning ? 'Running Migration...' : 'Start Client-Side Migration'}
            </button>

            {progress.total > 0 && (
              <div className="space-y-2">
                <div className="flex justify-between text-sm text-gray-600">
                  <span>Progress: {progress.current} / {progress.total}</span>
                  <span>Success: {results.success} | Errors: {results.errors}</span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div 
                    className="bg-green-600 h-2 rounded-full transition-all duration-300" 
                    style={{ width: `${(progress.current / progress.total) * 100}%` }}
                  />
                </div>
              </div>
            )}

            {logs.length > 0 && (
              <div className="bg-gray-100 rounded-lg p-4">
                <h3 className="font-semibold mb-2">Migration Log</h3>
                <div className="space-y-1 max-h-64 overflow-y-auto">
                  {logs.map((log, i) => (
                    <div key={i} className="text-sm font-mono text-gray-700">
                      {log}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: src/services/activityService.ts
================
import { supabase } from "@/integrations/supabase/client";
import { ApiResponse, UserActivity, ActivityType } from "./types";
import { getDeviceId, getUsername } from "./userService";

export async function logActivity(
  type: ActivityType,
  cafeId: string,
  metadata: any = {}
): Promise<ApiResponse<UserActivity>> {
  const { data: { user } } = await supabase.auth.getUser();
  const usernameRes = await getUsername();
  const username = usernameRes.success ? usernameRes.data : null;
  const { data, error } = await supabase
    .from("user_activities")
    .insert([
      {
        user_id: user?.id || null,
        username: username || null,
        activity_type: type,
        cafe_id: cafeId,
        metadata,
      }
    ])
    .select()
    .single();
  if (error) return { success: false, error: error.message, data: null };
  return { success: true, data };
}

export async function getUserActivities(userId: string): Promise<ApiResponse<UserActivity[]>> {
  const { data, error } = await supabase
    .from("user_activities")
    .select("*")
    .eq("user_id", userId)
    .order("created_at", { ascending: false });
  if (error) return { success: false, error: error.message, data: [] };
  return { success: true, data };
}

export async function getActivityFeed(): Promise<ApiResponse<UserActivity[]>> {
  const { data, error } = await supabase
    .from("user_activities")
    .select("*")
    .order("created_at", { ascending: false })
    .limit(50);
  if (error) return { success: false, error: error.message, data: [] };
  return { success: true, data };
}

================
File: src/services/adminFeedbackService.ts
================
import { supabase } from '@/integrations/supabase/client';
import { ApiResponse } from './types';

export interface AdminFeedback {
  id: string;
  feedback_type: 'bug' | 'feature' | 'general' | 'support';
  subject: string;
  details: string;
  allow_followup: boolean;
  contact_email?: string;
  user_id?: string;
  device_id?: string;
  created_at: string;
  updated_at: string;
  user_name?: string;
  user_email?: string;
}

export interface FeedbackStats {
  total: number;
  by_type: {
    bug: number;
    feature: number;
    general: number;
    support: number;
  };
  with_followup: number;
  recent_count: number;
}

export async function getAllFeedback(
  limit: number = 50,
  offset: number = 0,
  type?: string
): Promise<ApiResponse<AdminFeedback[]>> {
  try {
    let query = supabase
      .from('feedback')
      .select(`
        *,
        users!feedback_user_id_fkey (
          name,
          email
        )
      `)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (type && type !== 'all') {
      query = query.eq('feedback_type', type);
    }

    const { data, error } = await query;

    if (error) {
      throw new Error(error.message);
    }

    const transformedData = data?.map(item => ({
      ...item,
      user_name: item.users?.name || 'Anonymous',
      user_email: item.users?.email || null
    })) || [];

    return {
      data: transformedData,
      success: true
    };
  } catch (error) {
    return {
      data: [],
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch feedback'
    };
  }
}

export async function getFeedbackStats(): Promise<ApiResponse<FeedbackStats>> {
  try {
    const { count: totalCount, error: totalError } = await supabase
      .from('feedback')
      .select('*', { count: 'exact', head: true });

    if (totalError) throw new Error(totalError.message);

    const { count: followupCount } = await supabase
      .from('feedback')
      .select('*', { count: 'exact', head: true })
      .eq('allow_followup', true);

    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const { count: recentCount } = await supabase
      .from('feedback')
      .select('*', { count: 'exact', head: true })
      .gte('created_at', sevenDaysAgo.toISOString());

    const { data: typeData } = await supabase
      .from('feedback')
      .select('feedback_type');

    const stats: FeedbackStats = {
      total: totalCount || 0,
      by_type: {
        bug: typeData?.filter(t => t.feedback_type === 'bug').length || 0,
        feature: typeData?.filter(t => t.feedback_type === 'feature').length || 0,
        general: typeData?.filter(t => t.feedback_type === 'general').length || 0,
        support: typeData?.filter(t => t.feedback_type === 'support').length || 0
      },
      with_followup: followupCount || 0,
      recent_count: recentCount || 0
    };

    return {
      data: stats,
      success: true
    };
  } catch (error) {
    return {
      data: {
        total: 0,
        by_type: { bug: 0, feature: 0, general: 0, support: 0 },
        with_followup: 0,
        recent_count: 0
      },
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch feedback stats'
    };
  }
}

export async function updateFeedbackStatus(
  feedbackId: string,
  status: 'new' | 'in_progress' | 'resolved' | 'closed'
): Promise<ApiResponse<null>> {
  try {
    // Note: This would require adding a status column to the feedback table
    // For now, we'll just return success as the table doesn't have status tracking
    return {
      data: null,
      success: true
    };
  } catch (error) {
    return {
      data: null,
      success: false,
      error: error instanceof Error ? error.message : 'Failed to update feedback status'
    };
  }
}

export async function deleteFeedback(feedbackId: string): Promise<ApiResponse<null>> {
  try {
    const { error } = await supabase
      .from('feedback')
      .delete()
      .eq('id', feedbackId);

    if (error) {
      throw new Error(error.message);
    }

    return {
      data: null,
      success: true
    };
  } catch (error) {
    return {
      data: null,
      success: false,
      error: error instanceof Error ? error.message : 'Failed to delete feedback'
    };
  }
}

================
File: src/services/analyticsService.ts
================
import { supabase } from "@/integrations/supabase/client";
import { ApiResponse } from "./types";

export interface DailyActiveUsers {
  date: string;
  count: number;
}

export interface UserGrowth {
  date: string;
  totalUsers: number;
  newUsers: number;
}

export interface EngagementMetrics {
  totalUsers: number;
  totalPosts: number;
  totalCheckins: number;
  totalReviews: number;
  averageRating: number;
  dau: number;
  mau: number;
}

export async function getDailyActiveUsers(days: number = 30): Promise<ApiResponse<DailyActiveUsers[]>> {
  try {
    const { data, error } = await supabase
      .from('user_activities')
      .select('created_at, user_id, device_id')
      .gte('created_at', new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString())
      .order('created_at', { ascending: true });

    if (error) throw error;

    // Group by date and count unique users
    const dailyCounts: { [key: string]: Set<string> } = {};
    
    data?.forEach(activity => {
      const date = new Date(activity.created_at).toISOString().split('T')[0];
      if (!dailyCounts[date]) {
        dailyCounts[date] = new Set();
      }
      // Use user_id if available, otherwise device_id
      const identifier = activity.user_id || activity.device_id;
      if (identifier) {
        dailyCounts[date].add(identifier);
      }
    });

    const result = Object.entries(dailyCounts).map(([date, users]) => ({
      date,
      count: users.size
    }));

    return { success: true, data: result };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Failed to get daily active users',
      data: []
    };
  }
}

export async function getMonthlyActiveUsers(): Promise<ApiResponse<number>> {
  try {
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
    
    const { data, error } = await supabase
      .from('user_activities')
      .select('user_id, device_id')
      .gte('created_at', thirtyDaysAgo);

    if (error) throw error;

    // Count unique users
    const uniqueUsers = new Set<string>();
    data?.forEach(activity => {
      const identifier = activity.user_id || activity.device_id;
      if (identifier) {
        uniqueUsers.add(identifier);
      }
    });

    return { success: true, data: uniqueUsers.size };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Failed to get monthly active users',
      data: 0
    };
  }
}

export async function getUserGrowth(days: number = 30): Promise<ApiResponse<UserGrowth[]>> {
  try {
    const { data, error } = await supabase
      .from('users')
      .select('created_at')
      .gte('created_at', new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString())
      .order('created_at', { ascending: true });

    if (error) throw error;

    // Group by date
    const dailyGrowth: { [key: string]: number } = {};
    let cumulative = 0;
    
    data?.forEach(user => {
      const date = new Date(user.created_at).toISOString().split('T')[0];
      dailyGrowth[date] = (dailyGrowth[date] || 0) + 1;
    });

    const result = Object.entries(dailyGrowth).map(([date, newUsers]) => {
      cumulative += newUsers;
      return {
        date,
        totalUsers: cumulative,
        newUsers
      };
    });

    return { success: true, data: result };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Failed to get user growth',
      data: []
    };
  }
}

export async function getEngagementMetrics(): Promise<ApiResponse<EngagementMetrics>> {
  try {
    const [
      usersResult,
      postsResult,
      activitiesResult,
      reviewsResult
    ] = await Promise.all([
      supabase.from('users').select('id', { count: 'exact' }),
      supabase.from('posts').select('id, rating', { count: 'exact' }),
      supabase.from('user_activities').select('id, activity_type', { count: 'exact' }),
      supabase.from('cafe_reviews').select('id, rating', { count: 'exact' })
    ]);

    if (usersResult.error) throw usersResult.error;
    if (postsResult.error) throw postsResult.error;
    if (activitiesResult.error) throw activitiesResult.error;
    if (reviewsResult.error) throw reviewsResult.error;

    const totalUsers = usersResult.count || 0;
    const totalPosts = postsResult.count || 0;
    const totalReviews = reviewsResult.count || 0;
    
    // Count check-ins from activities
    const checkins = activitiesResult.data?.filter(a => a.activity_type === 'check-in').length || 0;
    
    // Calculate average rating
    const allRatings = [
      ...(postsResult.data?.map(p => p.rating) || []),
      ...(reviewsResult.data?.map(r => r.rating) || [])
    ];
    const averageRating = allRatings.length > 0 
      ? allRatings.reduce((sum, rating) => sum + rating, 0) / allRatings.length 
      : 0;

    // Get DAU and MAU
    const dauResult = await getDailyActiveUsers(1);
    const mauResult = await getMonthlyActiveUsers();
    
    const dau = dauResult.success ? (dauResult.data[0]?.count || 0) : 0;
    const mau = mauResult.success ? mauResult.data : 0;

    return {
      success: true,
      data: {
        totalUsers,
        totalPosts,
        totalCheckins: checkins,
        totalReviews,
        averageRating: Math.round(averageRating * 10) / 10,
        dau,
        mau
      }
    };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Failed to get engagement metrics',
      data: {
        totalUsers: 0,
        totalPosts: 0,
        totalCheckins: 0,
        totalReviews: 0,
        averageRating: 0,
        dau: 0,
        mau: 0
      }
    };
  }
}

================
File: src/services/API_INTEGRATION_GUIDE.md
================
# API Integration Guide

This guide explains where to update API endpoints in the Houston Coffee Connect service layer to connect to real backend services.

## Service Layer Architecture

The app uses a service layer pattern with the following files:
- `src/services/types.ts` - TypeScript interfaces and types
- `src/services/utils.ts` - Utility functions for API calls
- `src/services/cafeService.ts` - Cafe-related API calls
- `src/services/postService.ts` - Post/review-related API calls
- `src/services/cloudinaryService.ts` - Image upload and management
- `src/services/scheduledService.ts` - Background sync operations

## Where to Update APIs

### 1. Cafe Service (`src/services/cafeService.ts`)

#### Get Nearby Cafes
**Location:** Lines 15-45 in `fetchNearbyCafes()`
**Current:** Returns mock data
**Update:** Replace with Google Places Nearby Search API call
```typescript
// TODO: Replace this mock implementation
const url = `https://maps.googleapis.com/maps/api/place/nearbysearch/json?location=${lat},${lng}&radius=${radius}&type=cafe&key=${GOOGLE_PLACES_API_KEY}`;
```

#### Search Cafes
**Location:** Lines 67-85 in `searchCafes()`
**Current:** Filters mock data
**Update:** Replace with Google Places Text Search API call
```typescript
// TODO: Replace with real API call
const url = `https://maps.googleapis.com/maps/api/place/textsearch/json?query=${encodeURIComponent(query)} coffee houston&key=${GOOGLE_PLACES_API_KEY}`;
```

#### Get Cafe Details
**Location:** Lines 107-125 in `getCafeDetails()`
**Current:** Returns mock data by ID
**Update:** Replace with Google Places Details API call
```typescript
// TODO: Replace with real API call
const url = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${cafeId}&key=${GOOGLE_PLACES_API_KEY}`;
```

#### Sync Cafes (Background)
**Location:** Lines 200-250 in `syncCafesFromGooglePlaces()`
**Current:** Console logs only
**Update:** Implement full Google Places integration with database storage

### 2. Post Service (`src/services/postService.ts`)

#### Fetch Posts
**Location:** Lines 15-35 in `fetchPosts()`  
**Current:** Returns mock data
**Update:** Replace with your backend API call
```typescript
// TODO: Replace with real API endpoint
const response = await fetch(`${API_BASE_URL}/api/posts`);
```

#### Create Post
**Location:** Lines 57-75 in `createPost()`
**Current:** Simulates creation with mock data
**Update:** Replace with POST request to your backend
```typescript
// TODO: Replace with real API endpoint
const response = await fetch(`${API_BASE_URL}/api/posts`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(postData)
});
```

#### Filter by Tag
**Location:** Lines 97-110 in `filterFeedByTag()`
**Current:** Filters mock data
**Update:** Replace with backend query
```typescript
// TODO: Replace with real API endpoint
const response = await fetch(`${API_BASE_URL}/api/posts?tag=${tag}`);
```

### 3. Cloudinary Service (`src/services/cloudinaryService.ts`)

#### Upload Image
**Location:** Lines 26-87 in `uploadImage()`
**Current:** Fully implemented for Cloudinary
**Update:** Add your Cloudinary credentials
```typescript
// TODO: Replace with your Cloudinary cloud name
const CLOUDINARY_CLOUD_NAME = 'your-cloud-name';
const CLOUDINARY_UPLOAD_PRESET = 'your-upload-preset';
```

#### Delete Image
**Location:** Lines 151-176 in `deleteImage()`
**Current:** Placeholder implementation
**Update:** Implement server-side deletion
```typescript
// TODO: Implement server-side image deletion
// This requires your backend API with Cloudinary admin credentials
```

### 4. Scheduled Service (`src/services/scheduledService.ts`)

#### All Functions
**Location:** All functions in the file
**Current:** Console logs and mock implementations
**Update:** Replace with real background job implementations

## Required Environment Variables

Create these environment variables in your deployment environment:

```bash
# Google Places API (server-side only)
GOOGLE_PLACES_API_KEY=your_google_places_api_key

# Cloudinary (already configured)
VITE_CLOUDINARY_CLOUD_NAME=your_cloud_name
VITE_CLOUDINARY_UPLOAD_PRESET=your_upload_preset

# Your Backend API
VITE_API_BASE_URL=https://your-backend-api.com

# Optional: Analytics
VITE_ANALYTICS_ID=your_analytics_id
```

## API Response Format

All services follow a consistent response format defined in `src/services/types.ts`:

```typescript
interface ApiResponse<T> {
  success: boolean;
  data: T;
  error?: string;
  message?: string;
}
```

Your backend APIs should return responses in this format for consistency.

## Error Handling

All services use the `handleApiError()` utility function from `src/services/utils.ts`. This provides:
- Consistent error logging
- User-friendly error messages
- Proper error response formatting

## Testing Your Integration

1. **Check Browser Console:** All API calls are logged for debugging
2. **Mock Data:** Services gracefully fall back to mock data on API errors
3. **Error Toasts:** Failed API calls show user-friendly error messages
4. **Loading States:** All services include loading state management

## Next Steps

1. Set up your backend API or choose a Backend-as-a-Service (BaaS)
2. Configure Google Places API credentials
3. Replace mock implementations with real API calls
4. Test each service individually
5. Update error messages and loading states as needed

## Common Integration Patterns

### Supabase Integration
If using Supabase, replace API calls with Supabase client calls:
```typescript
import { supabase } from '@/lib/supabase';

// Example: Fetch posts
const { data, error } = await supabase
  .from('posts')
  .select('*, cafe(*)')
  .order('created_at', { ascending: false });
```

### Firebase Integration  
If using Firebase, replace with Firestore calls:
```typescript
import { collection, getDocs } from 'firebase/firestore';

// Example: Fetch posts
const querySnapshot = await getDocs(collection(db, 'posts'));
```

### Custom REST API
If using your own REST API, ensure CORS is configured and endpoints match the expected data structure.

================
File: src/services/cafeService.ts
================
import { 
  Cafe, 
  GooglePlacesResult, 
  SearchFilters, 
  ApiResponse, 
  HOUSTON_BOUNDS 
} from './types';
import { calculateDistance, isWithinHoustonMetro, detectNeighborhood } from './utils';
import { GooglePlacesService } from './googlePlacesService';
import { ImageOptimizationService } from './imageOptimizationService';
import { MonitoringService } from './monitoringService';
import { supabase } from '@/integrations/supabase/client';

// Note: Google Places API calls should only be made server-side
// Client-side code should call API routes instead of directly accessing Google Places API

function apiErrorResponse<T>(defaultValue: T): ApiResponse<T> {
  return {
    data: defaultValue,
    success: false,
    error: 'Failed to call API'
  };
}

/**
 * Transform database format to app format
 */
function transformCafeData(cafe: any): Cafe {
  return {
    id: cafe.id,
    placeId: cafe.place_id,
    name: cafe.name,
    address: cafe.address,
    neighborhood: cafe.neighborhood,
    latitude: typeof cafe.latitude === 'number' ? cafe.latitude : parseFloat(cafe.latitude),
    longitude: typeof cafe.longitude === 'number' ? cafe.longitude : parseFloat(cafe.longitude),
    rating: cafe.rating ? (typeof cafe.rating === 'number' ? cafe.rating : parseFloat(cafe.rating)) : undefined,
    googleRating: cafe.google_rating ? (typeof cafe.google_rating === 'number' ? cafe.google_rating : parseFloat(cafe.google_rating)) : undefined,
    priceLevel: cafe.price_level,
    phoneNumber: cafe.phone_number,
    website: cafe.website,
    openingHours: cafe.opening_hours,
    parkingInfo: cafe.parking_info,
    // Use hero_photo_url as the primary photo, fallback to photos array
    photos: cafe.hero_photo_url ? [cafe.hero_photo_url, ...(cafe.photos || [])] : (cafe.photos || []),
    heroPhotoUrl: cafe.hero_photo_url,
    tags: cafe.tags || [],
    createdAt: cafe.created_at,
    updatedAt: cafe.updated_at,
    isActive: cafe.is_active
  };
}

/**
 * Fetch cafes from database with optional filters
 */
export async function fetchCafes(filters: SearchFilters = {}): Promise<ApiResponse<Cafe[]>> {
  try {
    let query = supabase
      .from('cafes')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(5000); // Set a very high limit to ensure we get all cafes

    // Apply filters
    if (filters.query) {
      query = query.or(`name.ilike.%${filters.query}%,neighborhood.ilike.%${filters.query}%,tags.cs.{${filters.query}}`);
    }
    
    if (filters.neighborhoods && filters.neighborhoods.length > 0) {
      query = query.in('neighborhood', filters.neighborhoods);
    }
    
    if (filters.tags && filters.tags.length > 0) {
      query = query.overlaps('tags', filters.tags);
    }
    
    if (filters.rating) {
      query = query.gte('rating', filters.rating);
    }

    const { data, error } = await query;

    if (error) {
      throw new Error(error.message);
    }

    console.log(`Fetched ${data?.length || 0} cafes from Supabase`);
    
    // Transform database format to app format
    const cafes: Cafe[] = (data || []).map(transformCafeData);

    return {
      data: cafes,
      success: true
    };
  } catch (error) {
    return {
      data: [],
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch cafes'
    };
  }
}

/**
 * Fetch specific cafe details by place ID
 */
export async function fetchCafeDetails(placeId: string): Promise<ApiResponse<Cafe | null>> {
  try {
    const { data, error } = await supabase
      .from('cafes')
      .select('*')
      .eq('place_id', placeId)
      .eq('is_active', true)
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        // No rows returned
        return { data: null, success: true };
      }
      throw new Error(error.message);
    }

    // Transform database format to app format
    const cafe: Cafe = transformCafeData(data);
    
    return {
      data: cafe,
      success: true
    };
  } catch (error) {
    return {
      data: null,
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch cafe details'
    };
  }
}

/**
 * Search cafes with advanced filtering
 */
export async function searchCafes(query: string, filters: SearchFilters = {}): Promise<ApiResponse<Cafe[]>> {
  return await fetchCafes({ ...filters, query });
}

/**
 * Get nearby cafes based on user location
 */
export async function fetchNearbyCafes(
  latitude: number, 
  longitude: number, 
  radiusMiles: number = 10
): Promise<ApiResponse<Cafe[]>> {
  try {
    const { data: allCafes } = await fetchCafes();
    
    const nearbyCafes = allCafes
      .map(cafe => ({
        ...cafe,
        distance: calculateDistance(latitude, longitude, cafe.latitude, cafe.longitude)
      }))
      .filter(cafe => cafe.distance <= radiusMiles)
      .sort((a, b) => a.distance - b.distance);
    
    return {
      data: nearbyCafes,
      success: true
    };
  } catch (error) {
    return {
      data: [],
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch nearby cafes'
    };
  }
}

// Note: saveCafeToDatabase function moved to server-side API routes
// Client-side code should not directly save to database with Google Places data

/**
 * Sync Houston cafes from Google Places API - Server-side only
 * This function calls the server-side API route instead of making direct Google Places calls
 */
export async function syncGooglePlacesCafes(): Promise<ApiResponse<number>> {
  try {
    // Call the server-side API route
    const response = await fetch('/api/seed-cafes', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-admin-key': 'admin-key-placeholder' // This should be set by the admin
      }
    });
    
    const result = await response.json();
    
    if (!response.ok) {
      throw new Error(result.error || 'Failed to sync cafes');
    }
    
    return {
      data: result.result?.totalSynced || 0,
      success: true
    };
  } catch (error) {
    console.error('Sync error:', error);
    return {
      data: 0,
      success: false,
      error: error instanceof Error ? error.message : 'Sync failed'
    };
  }
}

/**
 * Migration function to fix existing cafes with broken photo URLs
 * Run this once to fix your existing 165 cafes
 */
/**
 * Migration function to fix existing cafes with broken photo URLs
 * This function calls the server-side API route instead of making direct database calls
 */
export async function fixExistingCafePhotos(): Promise<ApiResponse<number>> {
  try {
    // Call the server-side API route
    const response = await fetch('/api/fix-cafe-photos', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-admin-key': 'admin-key-placeholder' // This should be set by the admin
      }
    });
    
    const result = await response.json();
    
    if (!response.ok) {
      throw new Error(result.error || 'Failed to fix cafe photos');
    }
    
    return {
      data: result.fixedCount || 0,
      success: true
    };
    
  } catch (error) {
    console.error('‚ùå Error fixing cafe photos:', error);
    return {
      data: 0,
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fix cafe photos'
    };
  }
}

================
File: src/services/cloudinaryService.ts
================
import { ApiResponse } from './types';

// Environment variables with graceful fallbacks
const CLOUDINARY_CLOUD_NAME = import.meta.env.VITE_CLOUDINARY_CLOUD_NAME;
const CLOUDINARY_UPLOAD_PRESET = import.meta.env.VITE_CLOUDINARY_UPLOAD_PRESET;

// Check if environment variables are available
const hasCloudinaryCredentials = CLOUDINARY_CLOUD_NAME && CLOUDINARY_UPLOAD_PRESET && 
  CLOUDINARY_CLOUD_NAME !== 'undefined' && CLOUDINARY_UPLOAD_PRESET !== 'undefined';

function apiErrorResponse<T>(defaultValue: T): ApiResponse<T> {
  return {
    data: defaultValue,
    success: false,
    error: 'Failed to call API'
  };
}

export interface CloudinaryUploadResult {
  public_id: string;
  version: number;
  signature: string;
  width: number;
  height: number;
  format: string;
  resource_type: string;
  created_at: string;
  tags: string[];
  bytes: number;
  type: string;
  url: string;
  secure_url: string;
}

/**
 * Upload image to Cloudinary with coffee-optimized transformations
 */
export async function uploadImage(file: File): Promise<ApiResponse<CloudinaryUploadResult>> {
  if (!hasCloudinaryCredentials) {
    return apiErrorResponse({} as CloudinaryUploadResult);
  }
  
  try {
    // Validate file type
    if (!file.type.startsWith('image/')) {
      throw new Error('Please select a valid image file');
    }
    
    // Validate file size (max 10MB)
    if (file.size > 10 * 1024 * 1024) {
      throw new Error('Image size must be less than 10MB');
    }
    
    const formData = new FormData();
    formData.append('file', file);
    formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
    
    // Coffee shop optimized transformations
    formData.append('transformation', JSON.stringify([
      { width: 800, height: 800, crop: 'limit', quality: 'auto:good' },
      { effect: 'sharpen:100' }, // Enhance coffee details
      { format: 'auto' } // Automatic format optimization
    ]));
    
    // Add contextual tags for better organization
    formData.append('tags', 'coffee,houston,checkin,bean-scene');
    formData.append('context', `user_id=${getCurrentUserId()}`);
    
    const response = await fetch(
      `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/upload`,
      {
        method: 'POST',
        body: formData,
      }
    );
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error?.message || 'Failed to upload image');
    }
    
    const result: CloudinaryUploadResult = await response.json();
    
    return {
      data: result,
      success: true
    };
  } catch (error) {
    return {
      data: {} as CloudinaryUploadResult,
      success: false,
      error: error instanceof Error ? error.message : 'Failed to upload image'
    };
  }
}

/**
 * Generate optimized image URL with transformations
 */
export function getOptimizedImageUrl(
  publicId: string, 
  options: {
    width?: number;
    height?: number;
    crop?: 'fill' | 'fit' | 'scale' | 'limit';
    quality?: 'auto' | 'auto:low' | 'auto:good' | 'auto:best';
    format?: 'auto' | 'webp' | 'jpg' | 'png';
  } = {}
): string {
  if (!hasCloudinaryCredentials) {
    return '/placeholder.svg'; // Fallback for development
  }
  
  const {
    width = 400,
    height = 400,
    crop = 'fill',
    quality = 'auto:good',
    format = 'auto'
  } = options;
  
  return `https://res.cloudinary.com/${CLOUDINARY_CLOUD_NAME}/image/upload/w_${width},h_${height},c_${crop},q_${quality},f_${format}/${publicId}`;
}

/**
 * Upload multiple images (for cafe galleries)
 */
export async function uploadMultipleImages(files: File[]): Promise<ApiResponse<CloudinaryUploadResult[]>> {
  try {
    const uploadPromises = files.map(file => uploadImage(file));
    const results = await Promise.all(uploadPromises);
    
    // Check if any uploads failed
    const failedUploads = results.filter(result => !result.success);
    if (failedUploads.length > 0) {
      throw new Error(`Failed to upload ${failedUploads.length} images`);
    }
    
    const successfulUploads = results
      .filter(result => result.success)
      .map(result => result.data!);
    
    return {
      data: successfulUploads,
      success: true
    };
  } catch (error) {
    return {
      data: [],
      success: false,
      error: error instanceof Error ? error.message : 'Failed to upload multiple images'
    };
  }
}

/**
 * Delete image from Cloudinary
 */
export async function deleteImage(publicId: string): Promise<ApiResponse<boolean>> {
  if (!hasCloudinaryCredentials) {
    return apiErrorResponse(false);
  }
  
  try {
    // Note: Deletion requires API secret, so this should be done server-side
    // TODO: Implement via Supabase Edge Function when connected
    
    return {
      data: true,
      success: true
    };
  } catch (error) {
    return {
      data: false,
      success: false,
      error: error instanceof Error ? error.message : 'Failed to delete image'
    };
  }
}

/**
 * Generate image upload widget configuration
 * Useful for more advanced upload scenarios
 */
export function getUploadWidgetConfig() {
  return {
    cloudName: CLOUDINARY_CLOUD_NAME,
    uploadPreset: CLOUDINARY_UPLOAD_PRESET,
    sources: ['local', 'camera'],
    multiple: false,
    maxFileSize: 10000000, // 10MB
    acceptedFiles: '.jpg,.jpeg,.png,.webp',
    transformation: [
      { width: 800, height: 800, crop: 'limit', quality: 'auto:good' },
      { effect: 'sharpen:100' },
      { format: 'auto' }
    ],
    tags: ['coffee', 'houston', 'checkin', 'bean-scene'],
    context: {
      user_id: getCurrentUserId()
    }
  };
}

/**
 * Get current user ID (placeholder for auth integration)
 */
function getCurrentUserId(): string {
  // Note: This will be replaced with actual user ID from auth context
  return 'anonymous_user';
}

/**
 * Generate thumbnail URL for image previews
 */
export function getThumbnailUrl(publicId: string, size: 'small' | 'medium' | 'large' = 'medium'): string {
  const sizeMap = {
    small: { width: 150, height: 150 },
    medium: { width: 300, height: 300 },
    large: { width: 500, height: 500 }
  };
  
  const { width, height } = sizeMap[size];
  
  return getOptimizedImageUrl(publicId, {
    width,
    height,
    crop: 'fill',
    quality: 'auto:good'
  });
}

================
File: src/services/favoritesService.ts
================
import { supabase } from "@/integrations/supabase/client";
import { ApiResponse, Favorite } from "./types";
import { getDeviceId } from "./userService";

export async function addFavorite(cafeId: string): Promise<ApiResponse<Favorite>> {
  const deviceId = getDeviceId();
  const { data: { user } } = await supabase.auth.getUser();
  
  // Ensure we have either a user_id or device_id
  if (!user && !deviceId) {
    return { success: false, error: "No user or device ID available", data: null };
  }
  
  const { data, error } = await supabase
    .from("favorites")
    .insert([
      {
        user_id: user?.id || null,
        device_id: deviceId,
        cafe_id: cafeId,
      }
    ])
    .select()
    .single();
  if (error) return { success: false, error: error.message, data: null };
  return { success: true, data };
}

export async function removeFavorite(cafeId: string): Promise<ApiResponse<null>> {
  const deviceId = getDeviceId();
  const { data: { user } } = await supabase.auth.getUser();
  
  // Build the OR condition properly
  let orCondition = "";
  if (user?.id) {
    orCondition = `user_id.eq.${user.id}`;
  }
  if (deviceId) {
    if (orCondition) orCondition += `,device_id.eq.${deviceId}`;
    else orCondition = `device_id.eq.${deviceId}`;
  }
  
  if (!orCondition) {
    return { success: false, error: "No user or device ID available", data: null };
  }
  
  const { error } = await supabase
    .from("favorites")
    .delete()
    .or(orCondition)
    .eq("cafe_id", cafeId);
  if (error) return { success: false, error: error.message, data: null };
  return { success: true, data: null };
}

export async function getFavorites(): Promise<ApiResponse<Favorite[]>> {
  const deviceId = getDeviceId();
  const { data: { user } } = await supabase.auth.getUser();
  
  // Build the OR condition properly
  let orCondition = "";
  if (user?.id) {
    orCondition = `user_id.eq.${user.id}`;
  }
  if (deviceId) {
    if (orCondition) orCondition += `,device_id.eq.${deviceId}`;
    else orCondition = `device_id.eq.${deviceId}`;
  }
  
  if (!orCondition) {
    return { success: true, data: [] };
  }
  
  const { data, error } = await supabase
    .from("favorites")
    .select("*")
    .or(orCondition);
  if (error) return { success: false, error: error.message, data: [] };
  return { success: true, data };
}

export async function isFavorited(cafeId: string): Promise<ApiResponse<boolean>> {
  const deviceId = getDeviceId();
  const { data: { user } } = await supabase.auth.getUser();
  
  // Build the OR condition properly
  let orCondition = "";
  if (user?.id) {
    orCondition = `user_id.eq.${user.id}`;
  }
  if (deviceId) {
    if (orCondition) orCondition += `,device_id.eq.${deviceId}`;
    else orCondition = `device_id.eq.${deviceId}`;
  }
  
  if (!orCondition) {
    return { success: true, data: false };
  }
  
  const { data, error } = await supabase
    .from("favorites")
    .select("id")
    .or(orCondition)
    .eq("cafe_id", cafeId)
    .maybeSingle();
  if (error) return { success: false, error: error.message, data: false };
  return { success: true, data: !!data };
}

================
File: src/services/feedbackService.ts
================
import { supabase } from '@/integrations/supabase/client';
import { getDeviceId } from './userService';
import { ApiResponse } from './types';

export interface FeedbackData {
  feedback_type: 'bug' | 'feature' | 'general' | 'support';
  subject: string;
  details: string;
  allow_followup: boolean;
  contact_email?: string;
}

export interface Feedback {
  id: string;
  feedback_type: string;
  subject: string;
  details: string;
  allow_followup: boolean;
  contact_email?: string;
  user_id?: string;
  device_id?: string;
  created_at: string;
  updated_at: string;
}

function apiErrorResponse<T>(defaultValue: T): ApiResponse<T> {
  return {
    data: defaultValue,
    success: false,
    error: 'Failed to call API'
  };
}

/**
 * Submit feedback form
 */
export async function submitFeedback(feedbackData: FeedbackData): Promise<ApiResponse<Feedback>> {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    const deviceId = getDeviceId();

    // Get or create user profile (only for authenticated users)
    let userProfile = null;
    if (user) {
      let { data: profile } = await supabase
        .from('users')
        .select('id')
        .eq('auth_user_id', user.id)
        .single();

      if (!profile) {
        // Create user profile if it doesn't exist
        const { data: newProfile, error: profileError } = await supabase
          .from('users')
          .insert({
            auth_user_id: user.id,
            name: user.user_metadata?.name || 'Anonymous User',
            email: user.email || ''
          })
          .select('id')
          .single();

        if (profileError) throw new Error(profileError.message);
        profile = newProfile;
      }
      userProfile = profile;
    }

    // Prepare feedback data
    const feedbackPayload = {
      feedback_type: feedbackData.feedback_type,
      subject: feedbackData.subject,
      details: feedbackData.details,
      allow_followup: feedbackData.allow_followup,
      contact_email: feedbackData.allow_followup ? feedbackData.contact_email : null,
      user_id: userProfile?.id || null,
      device_id: deviceId
    };

    const { data, error } = await supabase
      .from('feedback')
      .insert(feedbackPayload)
      .select()
      .single();

    if (error) {
      throw new Error(error.message);
    }

    return {
      data,
      success: true
    };
  } catch (error) {
    return {
      data: {} as Feedback,
      success: false,
      error: error instanceof Error ? error.message : 'Failed to submit feedback'
    };
  }
}

/**
 * Get user's feedback history
 */
export async function getUserFeedback(): Promise<ApiResponse<Feedback[]>> {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    const deviceId = getDeviceId();

    let query = supabase
      .from('feedback')
      .select('*')
      .order('created_at', { ascending: false });

    if (user) {
      // Get user's feedback
      const { data: profile } = await supabase
        .from('users')
        .select('id')
        .eq('auth_user_id', user.id)
        .single();

      if (profile) {
        query = query.eq('user_id', profile.id);
      }
    } else if (deviceId) {
      // Get anonymous user's feedback by device_id
      query = query.eq('device_id', deviceId);
    } else {
      return {
        data: [],
        success: true
      };
    }

    const { data, error } = await query;

    if (error) {
      throw new Error(error.message);
    }

    return {
      data: data || [],
      success: true
    };
  } catch (error) {
    return {
      data: [],
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch feedback'
    };
  }
}

/**
 * Update feedback (for follow-up email changes)
 */
export async function updateFeedback(
  feedbackId: string, 
  updates: Partial<FeedbackData>
): Promise<ApiResponse<Feedback>> {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    const deviceId = getDeviceId();

    // Prepare update data
    const updateData: any = {
      ...updates,
      updated_at: new Date().toISOString()
    };

    // Only include contact_email if allow_followup is true
    if (!updates.allow_followup) {
      updateData.contact_email = null;
    }

    let query = supabase
      .from('feedback')
      .update(updateData)
      .eq('id', feedbackId)
      .select()
      .single();

    // Apply RLS - user can only update their own feedback
    if (user) {
      const { data: profile } = await supabase
        .from('users')
        .select('id')
        .eq('auth_user_id', user.id)
        .single();

      if (profile) {
        query = query.eq('user_id', profile.id);
      }
    } else if (deviceId) {
      query = query.eq('device_id', deviceId);
    } else {
      throw new Error('No user or device ID available');
    }

    const { data, error } = await query;

    if (error) {
      throw new Error(error.message);
    }

    return {
      data,
      success: true
    };
  } catch (error) {
    return {
      data: {} as Feedback,
      success: false,
      error: error instanceof Error ? error.message : 'Failed to update feedback'
    };
  }
}

================
File: src/services/feedService.ts
================
import { FeedItem, SearchFilters, ApiResponse } from './types';
import { fetchCafes } from './cafeService';
import { fetchPosts } from './postService';

/**
 * Fetch and merge cafes and posts into unified feed items
 * Sorted by createdAt in descending order (newest first)
 */
export async function fetchFeedItems(filters: SearchFilters = {}): Promise<ApiResponse<FeedItem[]>> {
  try {
    // Fetch both cafes and posts
    const [cafesResult, postsResult] = await Promise.all([
      fetchCafes(filters),
      fetchPosts(filters)
    ]);

    if (!cafesResult.success) {
      return {
        data: [],
        success: false,
        error: cafesResult.error || 'Failed to fetch cafes'
      };
    }

    if (!postsResult.success) {
      return {
        data: [],
        success: false,
        error: postsResult.error || 'Failed to fetch posts'
      };
    }

    // Normalize cafes into FeedItem format
    const cafeItems: FeedItem[] = cafesResult.data.map(cafe => ({
      type: "cafe" as const,
      id: `cafe_${cafe.id}`,
      createdAt: cafe.createdAt,
      cafe
    }));

    // Normalize posts into FeedItem format  
    const postItems: FeedItem[] = postsResult.data.map(post => ({
      type: "post" as const,
      id: `post_${post.id}`,
      createdAt: post.createdAt,
      post
    }));

    // Merge and sort by createdAt (newest first)
    const allItems = [...cafeItems, ...postItems]
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

    // Apply tag filtering across both cafe and post tags
    let filteredItems = allItems;
    if (filters.tags && filters.tags.length > 0) {
      filteredItems = allItems.filter(item => {
        if (item.type === "cafe" && item.cafe) {
          return item.cafe.tags.some(tag => filters.tags!.includes(tag));
        }
        if (item.type === "post" && item.post) {
          return item.post.tags.some(tag => filters.tags!.includes(tag));
        }
        return false;
      });
    }

    return {
      data: filteredItems,
      success: true
    };
  } catch (error) {
    return {
      data: [],
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch feed items'
    };
  }
}

/**
 * Filter feed by specific tag
 */
export async function filterFeedByTag(tag: string): Promise<ApiResponse<FeedItem[]>> {
  return await fetchFeedItems({ tags: [tag] });
}

================
File: src/services/googleAnalyticsService.ts
================
/**
 * Google Analytics Service for BeanScene
 * Provides utilities for tracking custom events and user interactions
 */

declare global {
  interface Window {
    gtag: (...args: any[]) => void;
    dataLayer: any[];
  }
}

class GoogleAnalyticsService {
  private isInitialized = false;
  private trackingId = 'G-RFNKYG6WL5';

  constructor() {
    this.checkInitialization();
  }

  private checkInitialization() {
    // Check if gtag is available
    if (typeof window !== 'undefined' && window.gtag) {
      this.isInitialized = true;
    } else {
      // Wait for gtag to load
      setTimeout(() => this.checkInitialization(), 100);
    }
  }

  /**
   * Track page views
   */
  trackPageView(pagePath: string, pageTitle?: string) {
    if (!this.isInitialized) return;

    window.gtag('config', this.trackingId, {
      page_path: pagePath,
      page_title: pageTitle,
    });
  }

  /**
   * Track custom events
   */
  trackEvent(eventName: string, parameters?: Record<string, any>) {
    if (!this.isInitialized) return;

    window.gtag('event', eventName, {
      event_category: 'BeanScene',
      ...parameters,
    });
  }

  /**
   * Track cafe-related events
   */
  trackCafeEvent(action: string, cafeName: string, cafeId?: string, additionalData?: Record<string, any>) {
    this.trackEvent('cafe_interaction', {
      event_category: 'Cafe',
      action,
      cafe_name: cafeName,
      cafe_id: cafeId,
      ...additionalData,
    });
  }

  /**
   * Track check-in events
   */
  trackCheckIn(cafeName: string, cafeId: string, rating?: number, hasImage?: boolean, tagCount?: number) {
    this.trackEvent('check_in', {
      event_category: 'Check-in',
      cafe_name: cafeName,
      cafe_id: cafeId,
      rating,
      has_image: hasImage,
      tag_count: tagCount,
    });
  }

  /**
   * Track quick post events
   */
  trackQuickPost(cafeName?: string, cafeId?: string, hasImage?: boolean) {
    this.trackEvent('quick_post', {
      event_category: 'Quick Post',
      cafe_name: cafeName,
      cafe_id: cafeId,
      has_image: hasImage,
    });
  }

  /**
   * Track search events
   */
  trackSearch(searchTerm: string, resultsCount?: number, filters?: Record<string, any>) {
    this.trackEvent('search', {
      event_category: 'Search',
      search_term: searchTerm,
      results_count: resultsCount,
      filters: JSON.stringify(filters),
    });
  }

  /**
   * Track cafe detail views
   */
  trackCafeDetailView(cafeName: string, cafeId: string, source?: string) {
    this.trackEvent('cafe_detail_view', {
      event_category: 'Cafe Detail',
      cafe_name: cafeName,
      cafe_id: cafeId,
      source,
    });
  }

  /**
   * Track feed interactions
   */
  trackFeedInteraction(action: string, postId?: string, cafeName?: string) {
    this.trackEvent('feed_interaction', {
      event_category: 'Feed',
      action,
      post_id: postId,
      cafe_name: cafeName,
    });
  }

  /**
   * Track user engagement
   */
  trackEngagement(action: string, details?: Record<string, any>) {
    this.trackEvent('user_engagement', {
      event_category: 'Engagement',
      action,
      ...details,
    });
  }

  /**
   * Track error events
   */
  trackError(errorType: string, errorMessage: string, context?: Record<string, any>) {
    this.trackEvent('error', {
      event_category: 'Error',
      error_type: errorType,
      error_message: errorMessage,
      ...context,
    });
  }

  /**
   * Track admin actions
   */
  trackAdminAction(action: string, details?: Record<string, any>) {
    this.trackEvent('admin_action', {
      event_category: 'Admin',
      action,
      ...details,
    });
  }
}

// Create and export a singleton instance
export const googleAnalytics = new GoogleAnalyticsService();

// Export the class for testing purposes
export { GoogleAnalyticsService };

================
File: src/services/googlePlacesService.ts
================
import { ApiResponse } from './types';
import { MonitoringService } from './monitoringService';

// Google Places API calls should be made server-side
// Client-side code will call our API endpoints instead of Google directly

function apiErrorResponse<T>(defaultValue: T): ApiResponse<T> {
  return {
    data: defaultValue,
    success: false,
    error: 'Failed to call API'
  };
}

interface PlacePhoto {
  photo_reference: string;
  width: number;
  height: number;
}

interface PlaceDetails {
  place_id: string;
  photos?: PlacePhoto[];
  name: string;
}

/**
 * Real Google Places API service - OPTIMIZED FOR SINGLE PHOTOS
 */
export class GooglePlacesService {

  /**
   * Fetch place details with SINGLE optimized photo
   */
  static async fetchPlaceDetails(placeId: string): Promise<ApiResponse<PlaceDetails | null>> {

    try {
      await MonitoringService.logApiUsage('google_places', 'place_details');

      // Call our server-side API endpoint instead of Google directly
      const url = `/api/place/details?place_id=${placeId}&fields=name,photos`;
      
      const response = await fetch(url);
      const data = await response.json();

      if (data.status !== 'OK') {
        throw new Error(data.error_message || 'Failed to fetch place details');
      }

      const result = data.result;
      const placeDetails: PlaceDetails = {
        place_id: placeId,
        name: result.name,
        // Only include first photo for optimization
        photos: result.photos ? [{
          photo_reference: result.photos[0].photo_reference,
          width: result.photos[0].width,
          height: result.photos[0].height
        }] : undefined
      };

      return {
        data: placeDetails,
        success: true
      };
    } catch (error) {
      return apiErrorResponse(null);
    }
  }

  /**
   * Get OPTIMIZED hero photo URL for a place (800x600 max)
   */
  static async getHeroPhotoUrl(placeId: string): Promise<ApiResponse<string | null>> {

    try {
      await MonitoringService.logApiUsage('google_places', 'hero_photo');

      // First get place details to get photo reference
      const placeDetails = await this.fetchPlaceDetails(placeId);
      
      if (!placeDetails.success || !placeDetails.data?.photos?.[0]) {
        return { data: null, success: true };
      }

      const photoRef = placeDetails.data.photos[0].photo_reference;
      
      // Generate optimized photo URL - single photo only
      // Use server-side API endpoint for photos
      const heroUrl = `/api/place/photo?maxwidth=800&maxheight=600&photoreference=${photoRef}`;

      return {
        data: heroUrl,
        success: true
      };
    } catch (error) {
      return apiErrorResponse(null);
    }
  }

  /**
   * Batch fetch SINGLE hero photos for multiple cafes - COST OPTIMIZED
   */
  static async batchFetchHeroPhotos(placeIds: string[]): Promise<ApiResponse<Record<string, string>>> {

    try {
      const results: Record<string, string> = {};
      
      // Process in smaller batches to respect rate limits
      const BATCH_SIZE = 3; // Reduced batch size for better rate limiting
      
      for (let i = 0; i < placeIds.length; i += BATCH_SIZE) {
        const batch = placeIds.slice(i, i + BATCH_SIZE);
        
        // Process batch in parallel for efficiency
        const batchPromises = batch.map(async (placeId) => {
          const photoResult = await this.getHeroPhotoUrl(placeId);
          if (photoResult.success && photoResult.data) {
            results[placeId] = photoResult.data;
          }
        });
        
        await Promise.all(batchPromises);
        
        // Rate limiting delay between batches
        if (i + BATCH_SIZE < placeIds.length) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }

      await MonitoringService.logApiUsage('google_places', 'batch_hero_photos', placeIds.length);

      return {
        data: results,
        success: true
      };
    } catch (error) {
      return apiErrorResponse({});
    }
  }
}

================
File: src/services/imageOptimizationService.ts
================
import { ApiResponse } from './types';

interface OptimizationOptions {
  width?: number;
  height?: number;
  format?: 'webp' | 'jpeg' | 'png';
  quality?: number;
}

interface OptimizedImage {
  url: string;
  width: number;
  height: number;
  format: string;
  size: number; // bytes
}

/**
 * Placeholder image optimization service
 * Note: This will be replaced with real Cloudinary integration
 */
export class ImageOptimizationService {
  private static mockOptimizedUrls = [
    'https://images.unsplash.com/photo-1501339847302-ac426a4a7cbb?w=1200&h=1200&fit=crop&fm=webp',
    'https://images.unsplash.com/photo-1554118811-1e0d58224f24?w=1200&h=1200&fit=crop&fm=webp',
    'https://images.unsplash.com/photo-1559496417-e7f25cb247cd?w=1200&h=1200&fit=crop&fm=webp'
  ];

  /**
   * Optimize uploaded image (placeholder implementation)
   */
  static async optimizeImage(
    imageFile: File,
    options: OptimizationOptions = {}
  ): Promise<ApiResponse<OptimizedImage>> {
    try {
      // Simulate upload and optimization time
      await new Promise(resolve => setTimeout(resolve, 2000));

      const {
        width = 1200,
        height = 1200,
        format = 'webp',
        quality = 80
      } = options;

      // Mock optimized result
      const randomIndex = Math.floor(Math.random() * this.mockOptimizedUrls.length);
      const optimizedImage: OptimizedImage = {
        url: this.mockOptimizedUrls[randomIndex],
        width,
        height,
        format,
        size: Math.floor(imageFile.size * 0.7) // Simulate 30% size reduction
      };

      return {
        data: optimizedImage,
        success: true
      };
    } catch (error) {
      return {
        data: {} as OptimizedImage,
        success: false,
        error: error instanceof Error ? error.message : 'Failed to optimize image'
      };
    }
  }

  /**
   * Generate responsive image variants
   */
  static async generateResponsiveVariants(
    imageUrl: string
  ): Promise<ApiResponse<Record<string, string>>> {
    try {
      // Simulate processing time
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Generate mock responsive variants
      const variants = {
        thumbnail: `${imageUrl}&w=300&h=300`,
        small: `${imageUrl}&w=600&h=600`,
        medium: `${imageUrl}&w=800&h=800`,
        large: `${imageUrl}&w=1200&h=1200`
      };

      return {
        data: variants,
        success: true
      };
    } catch (error) {
      return {
        data: {},
        success: false,
        error: error instanceof Error ? error.message : 'Failed to generate variants'
      };
    }
  }

  /**
   * Upload and optimize hero photo for cafe
   */
  static async optimizeHeroPhoto(imageUrl: string): Promise<ApiResponse<string>> {
    try {
      // Simulate optimization processing
      await new Promise(resolve => setTimeout(resolve, 1500));

      // Return optimized hero photo URL (800x600 WebP)
      const optimizedUrl = `${imageUrl}&w=800&h=600&fm=webp&q=85`;

      return {
        data: optimizedUrl,
        success: true
      };
    } catch (error) {
      return {
        data: '',
        success: false,
        error: error instanceof Error ? error.message : 'Failed to optimize hero photo'
      };
    }
  }

  /**
   * Upload and optimize user check-in photo
   */
  static async optimizeCheckinPhoto(imageFile: File): Promise<ApiResponse<string>> {
    try {
      // Simulate upload and optimization
      await new Promise(resolve => setTimeout(resolve, 2500));

      // Return optimized check-in photo URL (1200x1200 WebP)
      const randomIndex = Math.floor(Math.random() * this.mockOptimizedUrls.length);
      const optimizedUrl = this.mockOptimizedUrls[randomIndex];

      return {
        data: optimizedUrl,
        success: true
      };
    } catch (error) {
      return {
        data: '',
        success: false,
        error: error instanceof Error ? error.message : 'Failed to optimize check-in photo'
      };
    }
  }
}

================
File: src/services/monitoringService.ts
================
import { supabase } from '@/integrations/supabase/client';
import { ApiResponse } from './types';

interface ApiUsageLog {
  id: string;
  api_service: string;
  endpoint: string;
  request_count: number;
  date: string;
  created_at: string;
}

interface UsageStats {
  today: number;
  thisWeek: number;
  thisMonth: number;
  dailyLimit: number;
  isNearLimit: boolean;
  remainingCalls: number;
}

/**
 * API usage monitoring service with placeholder functionality
 */
export class MonitoringService {
  private static DAILY_LIMITS = {
    google_places: 1000,
    cloudinary: 2000,
    general: 5000
  };

  /**
   * Log API usage (placeholder implementation)
   */
  static async logApiUsage(
    service: string,
    endpoint: string,
    count: number = 1
  ): Promise<ApiResponse<boolean>> {
    try {
      const today = new Date().toISOString().split('T')[0];

      // Check if log exists for today
      const { data: existingLog, error: selectError } = await supabase
        .from('api_usage_logs')
        .select('*')
        .eq('api_service', service)
        .eq('endpoint', endpoint)
        .eq('date', today)
        .single();

      if (selectError && selectError.code !== 'PGRST116') {
        throw selectError;
      }

      if (existingLog) {
        // Update existing log
        const { error: updateError } = await supabase
          .from('api_usage_logs')
          .update({ 
            request_count: existingLog.request_count + count 
          })
          .eq('id', existingLog.id);

        if (updateError) throw updateError;
      } else {
        // Create new log entry
        const { error: insertError } = await supabase
          .from('api_usage_logs')
          .insert({
            api_service: service,
            endpoint,
            request_count: count,
            date: today
          });

        if (insertError) throw insertError;
      }

      return {
        data: true,
        success: true
      };
    } catch (error) {
      return {
        data: false,
        success: false,
        error: error instanceof Error ? error.message : 'Failed to log API usage'
      };
    }
  }

  /**
   * Get usage statistics for a service
   */
  static async getUsageStats(service: string): Promise<ApiResponse<UsageStats>> {
    try {
      const today = new Date().toISOString().split('T')[0];
      const weekAgo = new Date();
      weekAgo.setDate(weekAgo.getDate() - 7);
      const monthAgo = new Date();
      monthAgo.setMonth(monthAgo.getMonth() - 1);

      // Get usage data
      const { data: logs, error } = await supabase
        .from('api_usage_logs')
        .select('request_count, date')
        .eq('api_service', service)
        .gte('date', monthAgo.toISOString().split('T')[0]);

      if (error) throw error;

      const todayUsage = logs
        .filter(log => log.date === today)
        .reduce((sum, log) => sum + log.request_count, 0);

      const weekUsage = logs
        .filter(log => log.date >= weekAgo.toISOString().split('T')[0])
        .reduce((sum, log) => sum + log.request_count, 0);

      const monthUsage = logs
        .reduce((sum, log) => sum + log.request_count, 0);

      const dailyLimit = this.DAILY_LIMITS[service as keyof typeof this.DAILY_LIMITS] || this.DAILY_LIMITS.general;
      const remainingCalls = Math.max(0, dailyLimit - todayUsage);
      const isNearLimit = (todayUsage / dailyLimit) >= 0.8; // 80% threshold

      const stats: UsageStats = {
        today: todayUsage,
        thisWeek: weekUsage,
        thisMonth: monthUsage,
        dailyLimit,
        isNearLimit,
        remainingCalls
      };

      return {
        data: stats,
        success: true
      };
    } catch (error) {
      return {
        data: {} as UsageStats,
        success: false,
        error: error instanceof Error ? error.message : 'Failed to get usage stats'
      };
    }
  }

  /**
   * Check if service is within usage limits
   */
  static async checkUsageLimits(service: string): Promise<ApiResponse<{ canProceed: boolean; reason?: string }>> {
    try {
      const statsResult = await this.getUsageStats(service);
      if (!statsResult.success) {
        throw new Error(statsResult.error);
      }

      const stats = statsResult.data;
      
      if (stats.remainingCalls <= 0) {
        return {
          data: {
            canProceed: false,
            reason: `Daily limit of ${stats.dailyLimit} calls exceeded for ${service}`
          },
          success: true
        };
      }

      if (stats.isNearLimit) {
        console.warn(`${service} API usage near limit: ${stats.today}/${stats.dailyLimit} calls used`);
      }

      return {
        data: { canProceed: true },
        success: true
      };
    } catch (error) {
      return {
        data: { canProceed: false, reason: 'Unable to check usage limits' },
        success: false,
        error: error instanceof Error ? error.message : 'Limit check failed'
      };
    }
  }

  /**
   * Get daily usage trend for dashboard
   */
  static async getDailyUsageTrend(service: string, days: number = 30): Promise<ApiResponse<Array<{ date: string; usage: number }>>> {
    try {
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const { data: logs, error } = await supabase
        .from('api_usage_logs')
        .select('request_count, date')
        .eq('api_service', service)
        .gte('date', startDate.toISOString().split('T')[0])
        .order('date', { ascending: true });

      if (error) throw error;

      // Group by date and sum usage
      const trendData = logs.reduce((acc, log) => {
        const existing = acc.find(item => item.date === log.date);
        if (existing) {
          existing.usage += log.request_count;
        } else {
          acc.push({ date: log.date, usage: log.request_count });
        }
        return acc;
      }, [] as Array<{ date: string; usage: number }>);

      return {
        data: trendData,
        success: true
      };
    } catch (error) {
      return {
        data: [],
        success: false,
        error: error instanceof Error ? error.message : 'Failed to get usage trend'
      };
    }
  }
}

================
File: src/services/parkingService.ts
================
import { ApiResponse } from './types';

// Mock parking data - in real implementation, this would come from Google Places Details API
const MOCK_PARKING_DATA: Record<string, ParkingInfo> = {
  'ChIJd8BlQ2BZwokRAFQEcDlJRAI': { // Example place ID
    available: true,
    type: 'street' as const,
    cost: 'Free',
    notes: 'Street parking available'
  },
  'ChIJN1t_tDeuEmsRUsoyG83frY4': {
    available: true,
    type: 'lot' as const,
    cost: '$2/hour',
    notes: 'Paid parking lot nearby'
  }
};

export interface ParkingInfo {
  available: boolean;
  type: 'street' | 'lot' | 'garage' | 'valet' | 'none';
  cost: string;
  notes?: string;
}

/**
 * Get parking information for a cafe
 * In real implementation, this would call Google Places Details API server-side
 */
export async function getParkingInfo(placeId: string): Promise<ApiResponse<ParkingInfo | null>> {
  try {
    // Mock implementation - in real app, this would call server-side API
    const parkingInfo = MOCK_PARKING_DATA[placeId as keyof typeof MOCK_PARKING_DATA];
    
    if (parkingInfo) {
      return {
        data: parkingInfo as ParkingInfo,
        success: true
      };
    }

    // Default parking info for cafes without specific data
    return {
      data: {
        available: true,
        type: 'street',
        cost: 'Varies',
        notes: 'Street parking typically available'
      } as ParkingInfo,
      success: true
    };
  } catch (error) {
    return {
      data: null,
      success: false,
      error: error instanceof Error ? error.message : 'Failed to get parking info'
    };
  }
}

/**
 * Get parking availability status
 */
export function getParkingStatus(parkingInfo: ParkingInfo): {
  status: 'available' | 'limited' | 'paid' | 'none';
  color: string;
  icon: string;
} {
  if (!parkingInfo.available) {
    return { status: 'none', color: 'text-red-500', icon: 'üö´' };
  }

  switch (parkingInfo.type) {
    case 'street':
      return { status: 'available', color: 'text-green-500', icon: 'üÖøÔ∏è' };
    case 'lot':
    case 'garage':
      return { status: 'paid', color: 'text-yellow-500', icon: 'üí∞' };
    case 'valet':
      return { status: 'paid', color: 'text-blue-500', icon: 'üöó' };
    default:
      return { status: 'limited', color: 'text-orange-500', icon: '‚ö†Ô∏è' };
  }
}

================
File: src/services/postService.ts
================
import { Post, SearchFilters, ApiResponse, CheckInData } from './types';
import { fetchCafeDetails } from './cafeService';
import { uploadImage } from './cloudinaryService';
import { generateId, formatTimeAgo } from './utils';
import { ImageOptimizationService } from './imageOptimizationService';
import { MonitoringService } from './monitoringService';
import { supabase } from '@/integrations/supabase/client';
import { getUsername, getDeviceId } from './userService';
import { logActivity } from './activityService';

function apiErrorResponse<T>(defaultValue: T): ApiResponse<T> {
  return {
    data: defaultValue,
    success: false,
    error: 'Failed to call API'
  };
}

/**
 * Fetch posts for the main feed with optional filters
 */
export async function fetchPosts(filters: SearchFilters = {}): Promise<ApiResponse<Post[]>> {
  try {
    let query = supabase
      .from('posts')
      .select(`
        *,
        cafes (name, neighborhood, place_id)
      `)
      .order('created_at', { ascending: false });

    // Apply filters
    if (filters.tags && filters.tags.length > 0) {
      query = query.overlaps('tags', filters.tags);
    }
    
    if (filters.neighborhoods && filters.neighborhoods.length > 0) {
      query = query.in('cafes.neighborhood', filters.neighborhoods);
    }
    
    if (filters.query) {
      query = query.or(`text_review.ilike.%${filters.query}%,cafes.name.ilike.%${filters.query}%,tags.cs.{${filters.query}}`);
    }

    const { data, error } = await query;

    if (error) {
      throw new Error(error.message);
    }

    // Transform database format to app format
    const posts: Post[] = (data || []).map(post => ({
      id: post.id,
      userId: post.user_id,
      cafeId: post.cafe_id,
      placeId: post.place_id,
      imageUrl: post.image_url,
      rating: post.rating,
      textReview: post.text_review,
      tags: post.tags || [],
      likes: post.likes,
      comments: post.comments,
      createdAt: post.created_at,
      cafe: post.cafes ? {
        name: post.cafes.name,
        neighborhood: post.cafes.neighborhood,
        placeId: post.cafes.place_id
      } : undefined
    }));

    return {
      data: posts,
      success: true
    };
  } catch (error) {
    return {
      data: [],
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch posts'
    };
  }
}

/**
 * Fetch posts for a specific cafe
 */
export async function fetchCafePostsById(placeId: string): Promise<ApiResponse<Post[]>> {
  try {
    const { data, error } = await supabase
      .from('posts')
      .select(`
        *,
        cafes (name, neighborhood, place_id)
      `)
      .or(`place_id.eq.${placeId},cafe_id.eq.${placeId}`)
      .order('created_at', { ascending: false });

    if (error) {
      throw new Error(error.message);
    }

    // Transform database format to app format
    const posts: Post[] = (data || []).map(post => ({
      id: post.id,
      userId: post.user_id,
      cafeId: post.cafe_id,
      placeId: post.place_id,
      imageUrl: post.image_url,
      rating: post.rating,
      textReview: post.text_review,
      tags: post.tags || [],
      likes: post.likes,
      comments: post.comments,
      createdAt: post.created_at,
      cafe: post.cafes ? {
        name: post.cafes.name,
        neighborhood: post.cafes.neighborhood,
        placeId: post.cafes.place_id
      } : undefined
    }));
    
    return {
      data: posts,
      success: true
    };
  } catch (error) {
    return {
      data: [],
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch cafe posts'
    };
  }
}

/**
 * Filter feed posts by specific tag
 */
export async function filterFeedByTag(tag: string): Promise<ApiResponse<Post[]>> {
  return await fetchPosts({ tags: [tag] });
}

/**
 * Submit a new check-in post
 */
export async function submitCheckin(checkinData: CheckInData): Promise<ApiResponse<Post>> {
  try {
    let imageUrl = checkinData.imageUrl || '';
    
    // Upload image to Cloudinary if file provided
    if (checkinData.imageFile) {
      const uploadResult = await uploadImage(checkinData.imageFile);
      if (uploadResult.success && uploadResult.data) {
        imageUrl = uploadResult.data.secure_url;
      } else {
        console.warn('Image upload failed, continuing without image:', uploadResult.error);
        // Don't throw error, just continue without image
      }
    }
    
    // Get current user and username
    const { data: { user } } = await supabase.auth.getUser();
    const deviceId = getDeviceId();
    let username = null;
    
    // Get username (works for both authenticated and anonymous users)
    const usernameRes = await getUsername();
    username = usernameRes.success ? usernameRes.data : null;

    // Get or create user profile (only for authenticated users)
    let userProfile = null;
    if (user) {
      let { data: profile } = await supabase
        .from('users')
        .select('id')
        .eq('auth_user_id', user.id)
        .single();

      if (!profile) {
        // Create user profile if it doesn't exist
        const { data: newProfile, error: profileError } = await supabase
          .from('users')
          .insert({
            auth_user_id: user.id,
            name: user.user_metadata?.name || 'Anonymous User',
            email: user.email || ''
          })
          .select('id')
          .single();

        if (profileError) throw new Error(profileError.message);
        profile = newProfile;
      }
      userProfile = profile;
    }
    
    // Create post data
    const postData = {
      user_id: userProfile?.id || null,
      cafe_id: checkinData.cafeId,
      place_id: checkinData.placeId,
      image_url: imageUrl,
      rating: checkinData.rating,
      text_review: checkinData.review,
      tags: checkinData.tags,
      username: username,
      device_id: deviceId
    };
    
    const { data, error } = await supabase
      .from('posts')
      .insert(postData)
      .select(`
        *,
        cafes (name, neighborhood, place_id)
      `)
      .single();
    
    if (error) {
      throw new Error(error.message);
    }

    // Transform to app format
    const newPost: Post = {
      id: data.id,
      userId: data.user_id,
      cafeId: data.cafe_id,
      placeId: data.place_id,
      imageUrl: data.image_url,
      rating: data.rating,
      textReview: data.text_review,
      tags: data.tags || [],
      likes: data.likes,
      comments: data.comments,
      createdAt: data.created_at,
      cafe: data.cafes ? {
        name: data.cafes.name,
        neighborhood: data.cafes.neighborhood,
        placeId: data.cafes.place_id
      } : undefined
    };
    
    // Log activity
    try {
      await logActivity('check-in', checkinData.cafeId, { 
        cafeName: data.cafes?.name,
        rating: checkinData.rating,
        hasImage: !!checkinData.imageFile
      });
    } catch (error) {
      console.error('Failed to log activity:', error);
    }
    
    return {
      data: newPost,
      success: true
    };
  } catch (error) {
    return {
      data: {} as Post,
      success: false,
      error: error instanceof Error ? error.message : 'Failed to submit check-in'
    };
  }
}

/**
 * Like a post
 */
export async function likePost(postId: string): Promise<ApiResponse<boolean>> {
  try {
    // First get current likes count
    const { data: currentPost, error: fetchError } = await supabase
      .from('posts')
      .select('likes')
      .eq('id', postId)
      .single();

    if (fetchError) throw new Error(fetchError.message);

    const { error } = await supabase
      .from('posts')
      .update({ likes: (currentPost?.likes || 0) + 1 })
      .eq('id', postId);
    
    if (error) {
      throw new Error(error.message);
    }
    
    return {
      data: true,
      success: true
    };
  } catch (error) {
    return {
      data: false,
      success: false,
      error: error instanceof Error ? error.message : 'Failed to like post'
    };
  }
}

/**
 * Unlike a post
 */
export async function unlikePost(postId: string): Promise<ApiResponse<boolean>> {
  try {
    // First get current likes count
    const { data: currentPost, error: fetchError } = await supabase
      .from('posts')
      .select('likes')
      .eq('id', postId)
      .single();

    if (fetchError) throw new Error(fetchError.message);

    const newLikes = Math.max((currentPost?.likes || 0) - 1, 0);

    const { error } = await supabase
      .from('posts')
      .update({ likes: newLikes })
      .eq('id', postId);
    
    if (error) {
      throw new Error(error.message);
    }
    
    return {
      data: true,
      success: true
    };
  } catch (error) {
    return {
      data: false,
      success: false,
      error: error instanceof Error ? error.message : 'Failed to unlike post'
    };
  }
}

/**
 * Get posts by search query across all fields
 */
export async function searchPosts(query: string): Promise<ApiResponse<Post[]>> {
  return await fetchPosts({ query });
}

/**
 * Get trending posts (most liked in last 7 days)
 */
export async function fetchTrendingPosts(): Promise<ApiResponse<Post[]>> {
  try {
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const { data, error } = await supabase
      .from('posts')
      .select(`
        *,
        cafes (name, neighborhood, place_id)
      `)
      .gte('created_at', sevenDaysAgo.toISOString())
      .order('likes', { ascending: false })
      .limit(10);

    if (error) {
      throw new Error(error.message);
    }

    // Transform database format to app format
    const posts: Post[] = (data || []).map(post => ({
      id: post.id,
      userId: post.user_id,
      cafeId: post.cafe_id,
      placeId: post.place_id,
      imageUrl: post.image_url,
      rating: post.rating,
      textReview: post.text_review,
      tags: post.tags || [],
      likes: post.likes,
      comments: post.comments,
      createdAt: post.created_at,
      cafe: post.cafes ? {
        name: post.cafes.name,
        neighborhood: post.cafes.neighborhood,
        placeId: post.cafes.place_id
      } : undefined
    }));
    
    return {
      data: posts,
      success: true
    };
  } catch (error) {
    return {
      data: [],
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch trending posts'
    };
  }
}

================
File: src/services/recentlyViewedService.ts
================
import { Cafe } from './types';

const RECENTLY_VIEWED_KEY = 'recently_viewed_cafes';
const MAX_RECENT_ITEMS = 10;

interface RecentlyViewedCafe extends Pick<Cafe, 'id' | 'placeId' | 'name' | 'neighborhood' | 'photos' | 'rating' | 'tags'> {
  viewedAt: string;
}

/**
 * Get recently viewed cafes from localStorage
 */
export function getRecentlyViewed(): RecentlyViewedCafe[] {
  try {
    const stored = localStorage.getItem(RECENTLY_VIEWED_KEY);
    if (!stored) return [];
    
    const parsed = JSON.parse(stored);
    return Array.isArray(parsed) ? parsed : [];
  } catch (error) {
    console.error('Error reading recently viewed cafes:', error);
    return [];
  }
}

/**
 * Add a cafe to recently viewed list
 * Removes duplicates and maintains chronological order (newest first)
 */
export function addToRecentlyViewed(cafe: Cafe): void {
  try {
    const recentItem: RecentlyViewedCafe = {
      id: cafe.id,
      placeId: cafe.placeId,
      name: cafe.name,
      neighborhood: cafe.neighborhood,
      photos: cafe.photos,
      rating: cafe.rating,
      tags: cafe.tags,
      viewedAt: new Date().toISOString()
    };

    let recent = getRecentlyViewed();
    
    // Remove existing entry if present
    recent = recent.filter(item => item.placeId !== cafe.placeId);
    
    // Add to beginning of array
    recent.unshift(recentItem);
    
    // Keep only the most recent items
    recent = recent.slice(0, MAX_RECENT_ITEMS);
    
    localStorage.setItem(RECENTLY_VIEWED_KEY, JSON.stringify(recent));
  } catch (error) {
    console.error('Error saving recently viewed cafe:', error);
  }
}

/**
 * Clear all recently viewed cafes
 */
export function clearRecentlyViewed(): void {
  try {
    localStorage.removeItem(RECENTLY_VIEWED_KEY);
  } catch (error) {
    console.error('Error clearing recently viewed cafes:', error);
  }
}

/**
 * Remove a specific cafe from recently viewed
 */
export function removeFromRecentlyViewed(placeId: string): void {
  try {
    const recent = getRecentlyViewed();
    const filtered = recent.filter(item => item.placeId !== placeId);
    localStorage.setItem(RECENTLY_VIEWED_KEY, JSON.stringify(filtered));
  } catch (error) {
    console.error('Error removing from recently viewed cafes:', error);
  }
}

================
File: src/services/reviewService.ts
================
import { supabase } from '@/integrations/supabase/client';
import type { ApiResponse } from './types';

export interface GoogleReview {
  cafe_id: string;
  author_name: string;
  review_text: string;
  rating: number;
  time: number;
  profile_photo_url?: string;
}

/**
 * Upsert reviews, deduplicating by (cafe_id, author_name, review_text)
 * Enforces SQL constraint:
 *   ALTER TABLE google_reviews ADD CONSTRAINT unique_review UNIQUE(cafe_id, author_name, review_text);
 */
export async function upsertReviews(reviews: GoogleReview[]): Promise<ApiResponse<number>> {
  try {
    const { error } = await supabase
      .from('google_reviews' as any)
      .upsert(reviews as any, { onConflict: 'cafe_id,author_name,review_text' });
    if (error) throw new Error(error.message);
    return { data: reviews.length, success: true };
  } catch (error: any) {
    return { data: 0, success: false, error: error.message };
  }
}

// Ensure the following SQL constraint exists in your DB:
// ALTER TABLE google_reviews ADD CONSTRAINT unique_review UNIQUE(cafe_id, author_name, review_text);

================
File: src/services/scheduledService.ts
================
import { syncGooglePlacesCafes } from './cafeService';
import { ApiResponse } from './types';

/**
 * Main sync function for Houston cafes - runs on API key setup and monthly
 * This function should be called from a Supabase Edge Function with cron scheduling
 */
export async function runGooglePlacesSync(): Promise<ApiResponse<number>> {
  try {
    const syncResult = await syncGooglePlacesCafes();
    
    if (!syncResult.success) {
      throw new Error(syncResult.error || 'Sync failed');
    }
    
    const syncedCount = syncResult.data;
    
    // TODO: Store sync metrics in Supabase when connected
    // await logSyncMetrics({
    //   syncDate: new Date().toISOString(),
    //   cafesProcessed: syncedCount,
    //   status: 'success'
    // });
    
    return {
      data: syncedCount,
      success: true
    };
  } catch (error) {
    console.error('Cafe sync failed:', error);
    
    // TODO: Store error in analytics table
    // await logSyncMetrics({
    //   syncDate: new Date().toISOString(),
    //   cafesProcessed: 0,
    //   status: 'error',
    //   error: error instanceof Error ? error.message : 'Unknown error'
    // });
    
    return {
      data: 0,
      success: false,
      error: error instanceof Error ? error.message : 'Sync failed'
    };
  }
}

/**
 * Initial data load when Google Places API key is first configured
 * This should run immediately when the API key is added to environment variables
 */
export async function onFirstApiKeySetup(): Promise<ApiResponse<string>> {
  try {
    
    const syncResult = await runGooglePlacesSync();
    
    if (!syncResult.success) {
      throw new Error(syncResult.error || 'Initial sync failed');
    }
    
    const message = `Bean Scene is now live! Successfully imported ${syncResult.data} Houston cafes from Google Places. Monthly updates are scheduled automatically.`;
    
    return {
      data: message,
      success: true
    };
  } catch (error) {
    return {
      data: '',
      success: false,
      error: error instanceof Error ? error.message : 'Initial setup failed'
    };
  }
}

/**
 * Monthly data refresh function
 * Should be called on the 1st of every month via Supabase Edge Function cron job
 */
export async function monthlyDataRefresh(): Promise<ApiResponse<string>> {
  try {
    
    const syncResult = await runGooglePlacesSync();
    
    if (!syncResult.success) {
      throw new Error(syncResult.error || 'Monthly refresh failed');
    }
    
    const message = `Monthly refresh completed: ${syncResult.data} cafes updated with latest Google Places data`;
    
    // TODO: Send notification to admin users when Supabase is connected
    
    return {
      data: message,
      success: true
    };
  } catch (error) {
    return {
      data: '',
      success: false,
      error: error instanceof Error ? error.message : 'Monthly refresh failed'
    };
  }
}

/**
 * Check if initial sync has been completed
 */
export async function hasInitialSyncCompleted(): Promise<boolean> {
  try {
    // TODO: Check sync history table in Supabase when connected
    // const { data, error } = await supabase
    //   .from('sync_history')
    //   .select('id')
    //   .eq('sync_type', 'initial')
    //   .eq('status', 'success')
    //   .limit(1);
    
    // return data && data.length > 0;
    
    // For now, return false to indicate sync is needed
    return false;
  } catch (error) {
    console.error('Failed to check sync status:', error);
    return false;
  }
}

/**
 * Get last sync date and status
 */
export async function getLastSyncInfo(): Promise<ApiResponse<{
  lastSync: string | null;
  status: 'success' | 'error' | 'never';
  cafesCount: number;
}>> {
  try {
    // TODO: Query sync history from Supabase when connected
    // const { data, error } = await supabase
    //   .from('sync_history')
    //   .select('*')
    //   .order('created_at', { ascending: false })
    //   .limit(1);
    
    // Mock data for development
    return {
      data: {
        lastSync: null,
        status: 'never',
        cafesCount: 0
      },
      success: true
    };
  } catch (error) {
    return {
      data: {
        lastSync: null,
        status: 'error',
        cafesCount: 0
      },
      success: false,
      error: error instanceof Error ? error.message : 'Failed to get sync info'
    };
  }
}

/**
 * Manual sync trigger (for admin use)
 */
export async function triggerManualSync(): Promise<ApiResponse<string>> {
  try {
    
    const syncResult = await runGooglePlacesSync();
    
    if (!syncResult.success) {
      throw new Error(syncResult.error || 'Manual sync failed');
    }
    
    const message = `Manual sync completed: ${syncResult.data} Houston cafes processed`;
    
    return {
      data: message,
      success: true
    };
  } catch (error) {
    return {
      data: '',
      success: false,
      error: error instanceof Error ? error.message : 'Manual sync failed'
    };
  }
}

/**
 * Utility function to log sync metrics
 * TODO: Implement when Supabase is connected
 */
async function logSyncMetrics(metrics: {
  syncDate: string;
  cafesProcessed: number;
  status: 'success' | 'error';
  error?: string;
}): Promise<void> {
  try {
    // TODO: Insert into Supabase analytics table
    // const { error } = await supabase
    //   .from('sync_history')
    //   .insert(metrics);
  } catch (error) {
    console.error('Failed to log sync metrics:', error);
  }
}

/*
 * Supabase Edge Function Example for Scheduled Sync
 * 
 * Create this as sync-houston-cafes.ts in Supabase Edge Functions:
 * 
 * import { runGooglePlacesSync } from '../services/scheduledService.ts';
 * 
 * Deno.serve(async (req) => {
 *   const { method } = req;
 *   
 *   if (method !== 'POST') {
 *     return new Response('Method not allowed', { status: 405 });
 *   }
 *   
 *   try {
 *     const result = await runGooglePlacesSync();
 *     return Response.json(result);
 *   } catch (error) {
 *     return Response.json({ 
 *       success: false, 
 *       error: error.message 
 *     }, { status: 500 });
 *   }
 * });
 * 
 * Add to supabase/functions/cron/cron.ts for monthly scheduling:
 * 
 * import { Cron } from 'https://deno.land/x/cron/cron.ts';
 * 
 * const cron = new Cron();
 * 
 * // Run on 1st of every month at midnight
 * cron.monthly(() => {
 *   fetch('https://your-project.supabase.co/functions/v1/sync-houston-cafes', {
 *     method: 'POST',
 *     headers: { 'Authorization': `Bearer ${Deno.env.get('SUPABASE_ANON_KEY')}` }
 *   });
 * }, { date: 1, hour: 0, minute: 0 });
 * 
 * cron.start();
 */

================
File: src/services/types.ts
================
// TypeScript interfaces for Bean Scene Houston Cafe App

export interface Cafe {
  id: string;
  placeId: string;
  name: string;
  address: string;
  neighborhood: string;
  latitude: number;
  longitude: number;
  rating?: number;
  googleRating?: number;
  priceLevel?: number;
  phoneNumber?: string;
  website?: string;
  openingHours?: string[];
  parkingInfo?: string;
  photos?: string[];
  heroPhotoUrl?: string;
  tags: string[];
  createdAt: string;
  updatedAt: string;
  isActive: boolean;
}

export interface Post {
  id: string;
  userId: string;
  cafeId: string;
  placeId: string;
  imageUrl: string;
  rating: number;
  textReview: string;
  tags: string[];
  likes: number;
  comments: number;
  createdAt: string;
  username?: string;
  deviceId?: string;
  cafe?: Pick<Cafe, 'name' | 'neighborhood' | 'placeId'>;
}

export interface User {
  id: string;
  name: string;
  email: string;
  username?: string;
  avatar?: string;
  createdAt: string;
}

export interface CheckInData {
  cafeId: string;
  placeId: string;
  rating: number;
  imageFile?: File;
  imageUrl?: string;
  tags: string[];
  review: string;
  location?: {
    latitude: number;
    longitude: number;
  };
}

export interface FeedItem {
  type: "cafe" | "post" | "check-in";
  id: string;
  createdAt: string;
  // Cafe-specific fields (when type === "cafe")
  cafe?: Cafe;
  // Post-specific fields (when type === "post")
  post?: Post;
  // Check-in-specific fields (when type === "check-in")
  checkIn?: {
    cafeId: string;
    coords: { lat: number; lng: number };
    timestamp: number;
    image?: string;
    caption?: string;
    tags?: string[];
    anonId: string;
  };
}

export interface GooglePlacesResult {
  place_id: string;
  name: string;
  formatted_address: string;
  geometry: {
    location: {
      lat: number;
      lng: number;
    };
  };
  rating?: number;
  price_level?: number;
  formatted_phone_number?: string;
  website?: string;
  opening_hours?: {
    weekday_text: string[];
  };
  photos?: Array<{
    photo_reference: string;
  }>;
}

export interface SearchFilters {
  query?: string;
  neighborhoods?: string[];
  tags?: string[];
  rating?: number;
  distance?: number;
  priceLevel?: number[];
}

export interface ApiResponse<T> {
  data: T;
  success: boolean;
  error?: string;
}

// Houston Metro Area Bounds
export const HOUSTON_BOUNDS = {
  north: 30.110732,
  south: 29.523624,
  east: -95.014648,
  west: -95.669403
};

// Houston Neighborhoods
export const HOUSTON_NEIGHBORHOODS = [
  "Montrose", "Heights", "Downtown", "Midtown", "Rice Village",
  "West University", "River Oaks", "Memorial", "Galleria", "East End",
  "Museum District", "Washington Avenue", "EaDo", "Third Ward", "Fifth Ward"
];

// Popular Coffee Tags
export const COFFEE_TAGS = [
  "latte-art", "cozy-vibes", "laptop-friendly", "third-wave", "cold-brew",
  "pastries", "rooftop", "instagram-worthy", "pet-friendly", "outdoor-seating",
  "wifi", "quiet", "busy", "date-spot", "group-friendly", "drive-thru"
];

// Favorites and Activity Types
export interface Favorite {
  id: string;
  userId?: string;
  deviceId?: string;
  cafeId: string;
  createdAt: string;
}

export type ActivityType = 'check-in' | 'review' | 'photo-upload' | 'favorite';

export interface UserActivity {
  id: string;
  userId?: string;
  username?: string;
  activityType: ActivityType;
  cafeId?: string;
  createdAt: string;
  metadata?: any;
}

================
File: src/services/userService.ts
================
import { supabase } from "@/integrations/supabase/client";
import { ApiResponse } from "./types";

export const getDeviceId = (): string => {
  let deviceId = localStorage.getItem("deviceId");
  if (!deviceId) {
    deviceId = crypto.randomUUID();
    localStorage.setItem("deviceId", deviceId);
  }
  return deviceId;
};

export const setUsername = async (username: string): Promise<ApiResponse<null>> => {
  const { data: { user } } = await supabase.auth.getUser();
  const deviceId = getDeviceId();
  
  if (!user) {
    // For anonymous users, we'll store the username in localStorage
    // and use it in posts and activities
    localStorage.setItem("anonymousUsername", username);
    return { success: true, data: null };
  }
  
  // For authenticated users, update the database
  const { error } = await supabase
    .from("users")
    .update({ username })
    .eq("id", user.id);
  if (error) return { success: false, error: error.message, data: null };
  return { success: true, data: null };
};

export const getUsername = async (): Promise<ApiResponse<string | null>> => {
  const { data: { user } } = await supabase.auth.getUser();
  
  if (!user) {
    // For anonymous users, get username from localStorage
    const anonymousUsername = localStorage.getItem("anonymousUsername");
    return { success: true, data: anonymousUsername };
  }
  
  // For authenticated users, get from database
  const { data, error } = await supabase
    .from("users")
    .select("username")
    .eq("id", user.id)
    .single();
  if (error) return { success: false, error: error.message, data: null };
  return { success: true, data: data?.username || null };
};

export const getUserByUsername = async (username: string): Promise<ApiResponse<any>> => {
  const { data, error } = await supabase
    .from("users")
    .select("*")
    .eq("username", username)
    .single();
  if (error) return { success: false, error: error.message, data: null };
  return { success: true, data };
};

================
File: src/services/utils.ts
================
import { HOUSTON_BOUNDS } from './types';

/**
 * Calculate distance between two points using Haversine formula
 * Returns distance in miles
 */
export function calculateDistance(
  lat1: number, 
  lng1: number, 
  lat2: number, 
  lng2: number
): number {
  const R = 3959; // Earth's radius in miles
  const dLat = toRad(lat2 - lat1);
  const dLng = toRad(lng2 - lng1);
  
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLng / 2) * Math.sin(dLng / 2);
  
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function toRad(degrees: number): number {
  return degrees * (Math.PI / 180);
}

/**
 * Check if coordinates are within Houston Metro area
 */
export function isWithinHoustonMetro(lat: number, lng: number): boolean {
  return lat >= HOUSTON_BOUNDS.south &&
         lat <= HOUSTON_BOUNDS.north &&
         lng >= HOUSTON_BOUNDS.west &&
         lng <= HOUSTON_BOUNDS.east;
}

/**
 * Parse URL parameters for filtering
 */
export function parseUrlParams(url: string): Record<string, string> {
  const params: Record<string, string> = {};
  const urlObj = new URL(url);
  
  urlObj.searchParams.forEach((value, key) => {
    params[key] = value;
  });
  
  return params;
}

/**
 * Get current user location with error handling
 */
export function getCurrentLocation(): Promise<GeolocationPosition> {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('Geolocation is not supported by this browser'));
      return;
    }
    
    navigator.geolocation.getCurrentPosition(
      (position) => resolve(position),
      (error) => reject(error),
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 300000 // 5 minutes
      }
    );
  });
}

/**
 * Format time ago from date string
 */
export function formatTimeAgo(dateString: string): string {
  const date = new Date(dateString);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);
  
  if (diffMins < 60) {
    return `${diffMins}m ago`;
  } else if (diffHours < 24) {
    return `${diffHours}h ago`;
  } else if (diffDays < 7) {
    return `${diffDays}d ago`;
  } else {
    return date.toLocaleDateString();
  }
}

/**
 * Format distance for display
 */
export function formatDistance(miles: number): string {
  if (miles < 1) {
    const feet = Math.round(miles * 5280);
    return `${feet} ft`;
  }
  return `${miles.toFixed(1)} mi`;
}

/**
 * Detect neighborhood from coordinates
 * This is a simplified version - in production you'd use more precise boundaries
 */
export function detectNeighborhood(lat: number, lng: number): string {
  // Simplified neighborhood detection based on rough coordinates
  // In production, use proper geofencing with detailed boundaries
  
  if (lat > 29.75 && lng > -95.4) return "Heights";
  if (lat > 29.73 && lat < 29.77 && lng > -95.4 && lng < -95.35) return "Montrose";
  if (lat > 29.7 && lat < 29.77 && lng > -95.38 && lng < -95.35) return "Downtown";
  if (lat > 29.7 && lat < 29.75 && lng > -95.4 && lng < -95.35) return "Midtown";
  if (lat > 29.68 && lat < 29.72 && lng > -95.45 && lng < -95.4) return "Rice Village";
  if (lat > 29.72 && lat < 29.78 && lng > -95.45 && lng < -95.4) return "River Oaks";
  if (lat > 29.75 && lng < -95.4) return "Memorial";
  if (lat > 29.7 && lat < 29.75 && lng < -95.45) return "Galleria";
  if (lat > 29.7 && lat < 29.75 && lng > -95.35) return "East End";
  
  return "Houston"; // Default
}

/**
 * Debounce function for search inputs
 */
export function debounce<T extends (...args: any[]) => void>(
  func: T,
  delay: number
): T {
  let timeoutId: NodeJS.Timeout;
  
  return ((...args: Parameters<T>) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func(...args), delay);
  }) as T;
}

/**
 * Generate a random ID
 */
export function generateId(): string {
  return Math.random().toString(36).substr(2, 9);
}

================
File: src/services/validationService.ts
================
import { ApiResponse } from './types';
import { supabase } from '@/integrations/supabase/client';

export interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

export interface CafeValidationData {
  id: string;
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  phone?: string;
  website?: string;
  rating?: number;
  priceLevel?: number;
}

/**
 * Validate cafe data for completeness and accuracy
 */
export async function validateCafeData(cafe: CafeValidationData): Promise<ValidationResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Required field validation
  if (!cafe.name || cafe.name.trim().length === 0) {
    errors.push('Cafe name is required');
  }

  if (!cafe.address || cafe.address.trim().length === 0) {
    errors.push('Cafe address is required');
  }

  if (!cafe.latitude || !cafe.longitude) {
    errors.push('Cafe coordinates are required');
  }

  // Coordinate validation (Houston area bounds)
  if (cafe.latitude && cafe.longitude) {
    if (cafe.latitude < 29.0 || cafe.latitude > 30.5) {
      warnings.push('Latitude seems outside Houston metro area');
    }
    if (cafe.longitude < -96.0 || cafe.longitude > -94.5) {
      warnings.push('Longitude seems outside Houston metro area');
    }
  }

  // Phone number validation
  if (cafe.phone) {
    const phoneRegex = /^[\+]?[1-9][\d]{0,15}$/;
    if (!phoneRegex.test(cafe.phone.replace(/[\s\-\(\)]/g, ''))) {
      warnings.push('Phone number format may be invalid');
    }
  }

  // Website validation
  if (cafe.website) {
    try {
      new URL(cafe.website);
    } catch {
      warnings.push('Website URL format may be invalid');
    }
  }

  // Rating validation
  if (cafe.rating !== undefined) {
    if (cafe.rating < 0 || cafe.rating > 5) {
      errors.push('Rating must be between 0 and 5');
    }
  }

  // Price level validation
  if (cafe.priceLevel !== undefined) {
    if (cafe.priceLevel < 1 || cafe.priceLevel > 4) {
      errors.push('Price level must be between 1 and 4');
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Check for duplicate cafes based on name and location
 */
export async function checkForDuplicates(cafe: CafeValidationData): Promise<ApiResponse<string[]>> {
  try {
    const { data, error } = await supabase
      .from('cafes')
      .select('id, name, latitude, longitude')
      .neq('id', cafe.id);

    if (error) {
      throw new Error(error.message);
    }

    const duplicates: string[] = [];
    const threshold = 0.01; // ~0.6 miles

    for (const existingCafe of data || []) {
      // Check name similarity
      const nameSimilarity = calculateStringSimilarity(
        cafe.name.toLowerCase(),
        existingCafe.name.toLowerCase()
      );

      // Check location proximity
      const distance = calculateDistance(
        cafe.latitude,
        cafe.longitude,
        existingCafe.latitude,
        existingCafe.longitude
      );

      if (nameSimilarity > 0.8 && distance < threshold) {
        duplicates.push(existingCafe.id);
      }
    }

    return {
      data: duplicates,
      success: true
    };
  } catch (error) {
    return {
      data: [],
      success: false,
      error: error instanceof Error ? error.message : 'Failed to check for duplicates'
    };
  }
}

/**
 * Calculate string similarity using Levenshtein distance
 */
function calculateStringSimilarity(str1: string, str2: string): number {
  const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));

  for (let i = 0; i <= str1.length; i++) {
    matrix[0][i] = i;
  }

  for (let j = 0; j <= str2.length; j++) {
    matrix[j][0] = j;
  }

  for (let j = 1; j <= str2.length; j++) {
    for (let i = 1; i <= str1.length; i++) {
      const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
      matrix[j][i] = Math.min(
        matrix[j][i - 1] + 1,
        matrix[j - 1][i] + 1,
        matrix[j - 1][i - 1] + indicator
      );
    }
  }

  const maxLength = Math.max(str1.length, str2.length);
  return maxLength === 0 ? 1 : (maxLength - matrix[str2.length][str1.length]) / maxLength;
}

/**
 * Calculate distance between two coordinates in miles
 */
function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 3959; // Earth's radius in miles
  const dLat = (lat2 - lat1) * (Math.PI / 180);
  const dLon = (lon2 - lon1) * (Math.PI / 180);
  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

/**
 * Validate all cafes in the database
 */
export async function validateAllCafes(): Promise<ApiResponse<{
  total: number;
  valid: number;
  invalid: number;
  warnings: number;
  duplicates: number;
}>> {
  try {
    const { data: cafes, error } = await supabase
      .from('cafes')
      .select('*');

    if (error) {
      throw new Error(error.message);
    }

    let valid = 0;
    let invalid = 0;
    let warnings = 0;
    let duplicates = 0;

    for (const cafe of cafes || []) {
      const validation = await validateCafeData(cafe);
      const duplicateCheck = await checkForDuplicates(cafe);

      if (validation.isValid) {
        valid++;
      } else {
        invalid++;
      }

      if (validation.warnings.length > 0) {
        warnings++;
      }

      if (duplicateCheck.success && duplicateCheck.data.length > 0) {
        duplicates++;
      }
    }

    return {
      data: {
        total: cafes?.length || 0,
        valid,
        invalid,
        warnings,
        duplicates
      },
      success: true
    };
  } catch (error) {
    return {
      data: {
        total: 0,
        valid: 0,
        invalid: 0,
        warnings: 0,
        duplicates: 0
      },
      success: false,
      error: error instanceof Error ? error.message : 'Failed to validate cafes'
    };
  }
}

================
File: src/services/weatherService.ts
================
import { ApiResponse } from './types';

export interface WeatherData {
  temperature: number;
  condition: string;
  icon: string;
  humidity: number;
  windSpeed: number;
  precipitation: number;
  summary: string;
  cachedAt: string;
}

// In-memory cache (per session)
const weatherCache: Record<string, { data: WeatherData; expires: number }> = {};

const OPEN_METEO_URL = 'https://api.open-meteo.com/v1/forecast';

function getCacheKey(lat: number, lng: number) {
  return `${lat.toFixed(3)},${lng.toFixed(3)}`;
}

export async function getWeatherForLatLng(lat: number, lng: number): Promise<ApiResponse<WeatherData>> {
  const cacheKey = getCacheKey(lat, lng);
  const now = Date.now();
  if (weatherCache[cacheKey] && weatherCache[cacheKey].expires > now) {
    return { data: weatherCache[cacheKey].data, success: true };
  }
  try {
    // Open-Meteo API with Fahrenheit temperature unit
    const url = `${OPEN_METEO_URL}?latitude=${lat}&longitude=${lng}&current_weather=true&hourly=precipitation&timezone=auto&temperature_unit=fahrenheit`;
    const resp = await fetch(url);
    if (!resp.ok) throw new Error('Failed to fetch weather');
    const json = await resp.json();
    const current = json.current_weather;
    const precipitation = json.hourly?.precipitation?.[0] ?? 0;
    const summary = getWeatherSummary(current.weathercode);
    const icon = getWeatherIcon(summary);
    const data: WeatherData = {
      temperature: current.temperature,
      condition: summary,
      icon,
      humidity: current.relative_humidity ?? 0,
      windSpeed: current.windspeed,
      precipitation,
      summary,
      cachedAt: new Date().toISOString(),
    };
    weatherCache[cacheKey] = { data, expires: now + 60 * 60 * 1000 };
    return { data, success: true };
  } catch (error: any) {
    return {
      data: weatherCache[cacheKey]?.data || {
        temperature: 0,
        condition: 'Unavailable',
        icon: '',
        humidity: 0,
        windSpeed: 0,
        precipitation: 0,
        summary: 'Unavailable',
        cachedAt: new Date().toISOString(),
      },
      success: false,
      error: error.message || 'Failed to fetch weather',
    };
  }
}

export async function getHoustonWeather(): Promise<ApiResponse<WeatherData>> {
  // Houston center: 29.7604, -95.3698
  return getWeatherForLatLng(29.7604, -95.3698);
}

// Open-Meteo weathercode to summary
function getWeatherSummary(code: number): string {
  // See https://open-meteo.com/en/docs#api_form for codes
  if ([0].includes(code)) return 'Clear';
  if ([1, 2, 3].includes(code)) return 'Partly Cloudy';
  if ([45, 48].includes(code)) return 'Fog';
  if ([51, 53, 55, 56, 57].includes(code)) return 'Drizzle';
  if ([61, 63, 65, 66, 67, 80, 81, 82].includes(code)) return 'Rain';
  if ([71, 73, 75, 77, 85, 86].includes(code)) return 'Snow';
  if ([95, 96, 99].includes(code)) return 'Thunderstorm';
  return 'Unknown';
}

export function getWeatherIcon(condition: string): string {
  const conditionLower = condition.toLowerCase();
  if (conditionLower.includes('sunny') || conditionLower.includes('clear')) return '\u2600\ufe0f';
  if (conditionLower.includes('cloudy')) return '\u26c5';
  if (conditionLower.includes('rain')) return '\ud83c\udf27\ufe0f';
  if (conditionLower.includes('storm')) return '\u26c8\ufe0f';
  if (conditionLower.includes('snow')) return '\u2744\ufe0f';
  if (conditionLower.includes('fog')) return '\ud83c\udf2b\ufe0f';
  return '\ud83c\udf24\ufe0f'; // Default
}

export function getWeatherColor(temperature: number): string {
  if (temperature < 50) return 'text-blue-500';
  if (temperature < 70) return 'text-green-500';
  if (temperature < 85) return 'text-yellow-500';
  return 'text-red-500';
}

================
File: src/styles/coffee-theme.css
================
/* Coffee Theme - Global Styling */

/* CSS Variables for Coffee Color Palette */
:root {
  /* Primary browns */
  --espresso-dark: #4a3728;
  --espresso: #6b4423;
  --medium-brown: #8b5a3c;
  
  /* Medium tones */
  --coffee-medium: #8b6f47;
  --warm-brown: #7a6651;
  
  /* Light tones */
  --latte: #a08774;
  --cream: #d9cdb8;
  --light-cream: #f5efe8;
  
  /* Backgrounds */
  --bg-warm: #faf8f5;
  --bg-peach: #fff5f0;
  
  /* Accents */
  --caramel: #d4a574;
  --terracotta: #c4613a;
  --rust: #c4613a;
}

/* Global Animations */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes starGlow {
  0%, 100% {
    filter: drop-shadow(0 0 2px rgba(212, 165, 116, 0.4));
  }
  50% {
    filter: drop-shadow(0 0 6px rgba(212, 165, 116, 0.7));
  }
}

/* Header & Top Section Styling */
.coffee-header {
  background: linear-gradient(135deg, #6b4423 0%, #8b5a3c 100%);
  color: white;
}

.coffee-search-bar {
  box-shadow: 0 4px 16px rgba(107, 68, 35, 0.12), 0 2px 4px rgba(107, 68, 35, 0.08);
  transition: all 0.3s ease;
}

.coffee-search-bar:focus {
  box-shadow: 0 6px 20px rgba(107, 68, 35, 0.18), 0 4px 8px rgba(107, 68, 35, 0.12);
  transform: translateY(-1px);
}

.coffee-search-bar::placeholder {
  font-size: 0.9375rem; /* 15px */
  font-weight: 400;
  color: #8b6f47;
}

.coffee-weather-text {
  color: white;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.coffee-location-text {
  color: white;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* Tags Styling */
.coffee-tag {
  background: linear-gradient(135deg, #fff5f0 0%, #ffe8db 100%);
  color: #8b7355;
  border: 1.5px solid #e8dfd5;
  transition: all 0.3s ease;
  cursor: pointer;
}

.coffee-tag:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

/* Cafe Cards Styling */
.coffee-card {
  border-radius: 16px;
  background: white;
  border: 1px solid #f5efe8;
  box-shadow: 0 2px 8px rgba(107, 68, 35, 0.08), 0 1px 3px rgba(107, 68, 35, 0.06);
  transition: all 0.3s ease;
  animation: fadeIn 0.5s ease;
}

.coffee-card:hover {
  box-shadow: 0 8px 24px rgba(107, 68, 35, 0.15), 0 4px 8px rgba(107, 68, 35, 0.1);
  transform: translateY(-2px);
  border-color: #e8dfd5;
}

/* Typography */
.coffee-heading {
  font-size: 2rem; /* 32px */
  font-weight: 700;
  letter-spacing: -0.5px;
  color: white;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.coffee-section-heading {
  font-weight: 600;
  color: #4a3728;
  letter-spacing: -0.3px;
}

.coffee-cafe-name {
  font-weight: 600;
  color: #2d2115;
  letter-spacing: -0.2px;
}

.coffee-text-medium {
  color: #8b6f47;
}

.coffee-text-light {
  color: #a08774;
}

/* Star Ratings */
.coffee-star {
  color: #d4a574;
  animation: starGlow 3s ease-in-out infinite;
}

/* Bottom Navigation */
.coffee-bottom-nav {
  background: white;
  box-shadow: 0 -4px 12px rgba(107, 68, 35, 0.1);
  border-top: 1px solid #f5efe8;
}

.coffee-nav-inactive {
  color: #a08774;
}

.coffee-nav-active {
  color: #6b4423;
}

.coffee-nav-item:hover {
  color: #6b4423;
  transform: translateY(-2px);
  transition: all 0.3s ease;
}

/* Global Shadows - Brown Tinted */
.coffee-shadow-sm {
  box-shadow: 0 1px 2px rgba(107, 68, 35, 0.05);
}

.coffee-shadow {
  box-shadow: 0 1px 3px rgba(107, 68, 35, 0.1), 0 1px 2px rgba(107, 68, 35, 0.06);
}

.coffee-shadow-md {
  box-shadow: 0 4px 6px rgba(107, 68, 35, 0.07), 0 2px 4px rgba(107, 68, 35, 0.06);
}

.coffee-shadow-lg {
  box-shadow: 0 10px 15px rgba(107, 68, 35, 0.1), 0 4px 6px rgba(107, 68, 35, 0.05);
}

.coffee-shadow-xl {
  box-shadow: 0 20px 25px rgba(107, 68, 35, 0.1), 0 10px 10px rgba(107, 68, 35, 0.04);
}

/* Button Styling */
.coffee-button {
  background: linear-gradient(135deg, #6b4423 0%, #8b5a3c 100%);
  color: white;
  border: none;
  transition: all 0.3s ease;
}

.coffee-button:hover {
  background: linear-gradient(135deg, #5a3a1f 0%, #7a4f2f 100%);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(107, 68, 35, 0.2);
}

/* Input Styling */
.coffee-input {
  border: 1px solid #e8dfd5;
  background: #faf8f5;
  transition: all 0.3s ease;
}

.coffee-input:focus {
  border-color: #8b5a3c;
  box-shadow: 0 0 0 3px rgba(139, 90, 60, 0.1);
  background: white;
}

/* Background Variations */
.coffee-bg-warm {
  background-color: #faf8f5;
}

.coffee-bg-peach {
  background-color: #fff5f0;
}

.coffee-bg-cream {
  background-color: #f5efe8;
}

/* Location Pin Icon */
.coffee-location-pin {
  color: #8b6f47;
}

/* Micro-interactions */
.coffee-interactive {
  transition: all 0.3s ease;
  cursor: pointer;
}

.coffee-interactive:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(107, 68, 35, 0.15);
}

/* Page Transitions */
.coffee-page-transition {
  transition: opacity 0.3s ease, transform 0.3s ease;
}

/* Filter Dropdown - Keep existing styling */
.coffee-filter-dropdown {
  /* Preserve existing filter dropdown styling as requested */
}

================
File: src/utils/distanceUtils.ts
================
/**
 * Distance calculation utilities for geo-based check-ins
 */

/**
 * Calculate distance between two points using Haversine formula
 * @param lat1 - Latitude of first point
 * @param lng1 - Longitude of first point
 * @param lat2 - Latitude of second point
 * @param lng2 - Longitude of second point
 * @returns Distance in miles
 */
export function calculateDistance(
  lat1: number,
  lng1: number,
  lat2: number,
  lng2: number
): number {
  const R = 3959; // Earth's radius in miles
  const dLat = toRadians(lat2 - lat1);
  const dLng = toRadians(lng2 - lng1);
  
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *
    Math.sin(dLng / 2) * Math.sin(dLng / 2);
  
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const distance = R * c;
  
  return distance;
}

/**
 * Convert degrees to radians
 */
function toRadians(degrees: number): number {
  return degrees * (Math.PI / 180);
}

/**
 * Format distance for display
 * @param distance - Distance in miles
 * @returns Formatted distance string
 */
export function formatDistance(distance: number): string {
  if (distance < 0.1) {
    return `${Math.round(distance * 5280)} ft away`;
  } else if (distance < 1) {
    return `${(distance * 10).toFixed(1)} mi away`;
  } else {
    return `${distance.toFixed(1)} mi away`;
  }
}

/**
 * Get cafes within a certain radius and sort by distance
 * @param userLat - User's latitude
 * @param userLng - User's longitude
 * @param cafes - Array of all cafes
 * @param maxDistance - Maximum distance in miles (default: 50)
 * @param limit - Maximum number of cafes to return (default: 10)
 * @returns Array of cafes sorted by distance with distance property added
 */
export function getNearbyCafes(
  userLat: number,
  userLng: number,
  cafes: any[],
  maxDistance: number = 50,
  limit: number = 10
): (any & { distance: number })[] {
  const cafesWithDistance = cafes
    .map(cafe => ({
      ...cafe,
      distance: calculateDistance(userLat, userLng, cafe.latitude, cafe.longitude)
    }))
    .filter(cafe => cafe.distance <= maxDistance)
    .sort((a, b) => a.distance - b.distance)
    .slice(0, limit);

  return cafesWithDistance;
}

================
File: src/utils/emojiPlaceholders.ts
================
/**
 * Emoji placeholders for cafe images
 * Provides deterministic emoji selection based on cafe ID
 */

const EMOJI_OPTIONS = ['‚òï', 'ü•ê', 'üç∞', 'ü•Ø', 'üßÅ', 'üç™', 'ü•§'];

/**
 * Get a deterministic emoji for a cafe based on its ID
 * @param cafeId - The cafe's unique identifier
 * @returns A coffee-themed emoji
 */
export function getCafeEmoji(cafeId: string | number): string {
  const id = typeof cafeId === 'string' ? cafeId : cafeId.toString();
  
  // Create a simple hash from the cafe ID
  let hash = 0;
  for (let i = 0; i < id.length; i++) {
    const char = id.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  
  // Use absolute value and modulo to get emoji index
  const emojiIndex = Math.abs(hash) % EMOJI_OPTIONS.length;
  return EMOJI_OPTIONS[emojiIndex];
}

/**
 * Generate emoji placeholder component props
 * @param cafeId - The cafe's unique identifier
 * @param cafeName - The cafe's name (for alt text)
 * @returns Props for rendering emoji placeholder
 */
export function getEmojiPlaceholderProps(cafeId: string | number, cafeName: string) {
  const emoji = getCafeEmoji(cafeId);
  
  return {
    emoji,
    altText: `${cafeName} - Coffee emoji placeholder`,
    className: "w-full h-full flex items-center justify-center bg-gradient-to-br from-[#8b5a3c] to-[#6b4423] text-white text-6xl rounded-lg shadow-lg"
  };
}

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: supabase/config.toml
================
project_id = "hhdcequsdmosxzjebdyj"

[functions.add-reviews]
verify_jwt = false

[functions.refresh-amenities]
verify_jwt = false

[functions.enrich-cafes]
verify_jwt = false

================
File: supabase/functions/add-reviews/index.ts
================
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.57.4';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface GoogleReview {
  author_name: string;
  text: string;
  rating: number;
  time: number;
  profile_photo_url?: string;
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const googleApiKey = Deno.env.get('GOOGLE_PLACES_API_KEY');

    if (!googleApiKey) {
      throw new Error('GOOGLE_PLACES_API_KEY not configured');
    }

    const supabase = createClient(supabaseUrl, supabaseKey);

    // Fetch all active cafes
    const { data: cafes, error: cafesError } = await supabase
      .from('cafes')
      .select('id, place_id, name, neighborhood')
      .eq('is_active', true);

    if (cafesError) throw cafesError;

    console.log(`Starting review enrichment for ${cafes.length} cafes`);

    let totalReviews = 0;
    let apiCalls = 0;
    let failed = 0;
    const MAX_API_CALLS = 2000;
    const reviewSet = new Set();

    for (const cafe of cafes) {
      if (apiCalls >= MAX_API_CALLS) break;

      try {
        const url = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${cafe.place_id}&fields=reviews&key=${googleApiKey}`;
        
        apiCalls++;
        const response = await fetch(url);
        
        if (!response.ok) {
          console.error(`Failed to fetch reviews for ${cafe.name}`);
          failed++;
          continue;
        }

        const data = await response.json();
        const googleReviews: GoogleReview[] = data.result?.reviews || [];

        // Take top 3 reviews
        const reviewsToInsert = [];
        for (const review of googleReviews.slice(0, 3)) {
          const key = `${cafe.place_id}|${review.author_name}|${review.text}`;
          if (!reviewSet.has(key)) {
            reviewSet.add(key);
            reviewsToInsert.push({
              cafe_id: cafe.id,
              reviewer_name: review.author_name,
              review_text: review.text,
              rating: review.rating,
              time: new Date(review.time * 1000).toISOString(),
              profile_photo_url: review.profile_photo_url,
            });
          }
        }

        if (reviewsToInsert.length > 0) {
          const { error: insertError } = await supabase
            .from('cafe_reviews')
            .upsert(reviewsToInsert, { 
              onConflict: 'cafe_id,reviewer_name,review_text',
              ignoreDuplicates: true 
            });

          if (insertError) {
            console.error(`Error inserting reviews for ${cafe.name}:`, insertError);
            failed++;
          } else {
            totalReviews += reviewsToInsert.length;
            console.log(`‚úÖ ${cafe.name}: ${reviewsToInsert.length} reviews added`);
          }

          // Rate limiting: 100ms delay
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      } catch (error) {
        console.error(`Failed to process ${cafe.name}:`, error);
        failed++;
      }
    }

    const message = `‚úÖ Added ${totalReviews} reviews from ${cafes.length} caf√©s. API calls used: ${apiCalls} of ${MAX_API_CALLS}`;
    console.log(message);

    return new Response(JSON.stringify({ 
      success: true, 
      message,
      stats: {
        processed: cafes.length,
        succeeded: cafes.length - failed,
        failed: failed,
        reviewsAdded: totalReviews,
        apiCalls: apiCalls,
        estimatedCost: apiCalls * 0.017
      }
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  } catch (error: any) {
    console.error('Error in add-reviews function:', error);
    return new Response(JSON.stringify({ 
      success: false,
      message: error.message || 'Failed to add reviews',
      error: error.message
    }), {
      status: 200, // Return 200 to match expected format
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});

================
File: supabase/functions/enrich-cafes/index.ts
================
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.57.4';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface PlaceDetails {
  opening_hours?: { weekday_text: string[] };
  formatted_phone_number?: string;
  website?: string;
  reviews?: Array<{
    author_name: string;
    text: string;
    rating: number;
    time: number;
    profile_photo_url?: string;
  }>;
  editorial_summary?: { overview: string };
}

function inferParkingInfo(editorial?: string, reviews?: PlaceDetails['reviews']): string {
  const text = `${editorial || ''} ${reviews?.map(r => r.text).join(' ') || ''}`.toLowerCase();
  
  if (text.includes('no parking') || text.includes('limited parking')) {
    return 'Limited or no parking available';
  } else if (text.includes('parking') || text.includes('garage') || text.includes('lot')) {
    return 'Parking available nearby';
  } else if (text.includes('street parking')) {
    return 'Street parking available';
  }
  
  return 'Parking information not available';
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const googleApiKey = Deno.env.get('GOOGLE_PLACES_API_KEY');

    if (!googleApiKey) {
      throw new Error('GOOGLE_PLACES_API_KEY not configured');
    }

    const supabase = createClient(supabaseUrl, supabaseKey);

    // Fetch cafes missing opening_hours
    const { data: cafes, error: cafesError } = await supabase
      .from('cafes')
      .select('id, place_id, name, neighborhood')
      .eq('is_active', true)
      .is('opening_hours', null);

    if (cafesError) throw cafesError;

    console.log(`Starting enrichment for ${cafes.length} cafes missing data`);

    let enriched = 0;
    let totalReviewsInserted = 0;
    let failed = 0;

    for (let i = 0; i < cafes.length; i++) {
      const cafe = cafes[i];
      
      try {
        const url = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${cafe.place_id}&fields=opening_hours,formatted_phone_number,website,reviews,editorial_summary&key=${googleApiKey}`;
        
        const response = await fetch(url);
        if (!response.ok) {
          failed++;
          continue;
        }

        const data = await response.json();
        const details: PlaceDetails = data.result;

        if (details) {
          // Update cafe
          const updateData: any = {
            updated_at: new Date().toISOString(),
          };

          if (details.opening_hours?.weekday_text) {
            updateData.opening_hours = details.opening_hours.weekday_text;
          }
          if (details.formatted_phone_number) {
            updateData.phone_number = details.formatted_phone_number;
          }
          if (details.website) {
            updateData.website = details.website;
          }
          
          updateData.parking_info = inferParkingInfo(
            details.editorial_summary?.overview,
            details.reviews
          );

          await supabase.from('cafes').update(updateData).eq('id', cafe.id);

          // Insert reviews (top 5)
          if (details.reviews && details.reviews.length > 0) {
            const reviewsToInsert = details.reviews.slice(0, 5).map(review => ({
              cafe_id: cafe.id,
              reviewer_name: review.author_name,
              review_text: review.text,
              rating: review.rating,
              time: new Date(review.time * 1000).toISOString(),
              profile_photo_url: review.profile_photo_url,
            }));

            const { error: reviewError } = await supabase
              .from('cafe_reviews')
              .upsert(reviewsToInsert, {
                onConflict: 'cafe_id,reviewer_name,review_text',
                ignoreDuplicates: true
              });

            if (!reviewError) {
              totalReviewsInserted += reviewsToInsert.length;
              console.log(`üìù Inserted ${reviewsToInsert.length} reviews for ${cafe.name}`);
            }
          }

          enriched++;
          console.log(`[${i + 1}/${cafes.length}] ‚úÖ ${cafe.name} (${cafe.neighborhood})`);
        }

        // Rate limiting: 100ms between requests
        await new Promise(resolve => setTimeout(resolve, 100));
      } catch (error) {
        console.error(`Failed to enrich ${cafe.name}:`, error);
        failed++;
      }
    }

    const message = `‚úÖ Enriched ${enriched} caf√©s, inserted ${totalReviewsInserted} reviews. Failed: ${failed}`;
    console.log(message);

    return new Response(JSON.stringify({ 
      success: true, 
      message,
      stats: {
        processed: cafes.length,
        succeeded: enriched,
        failed: failed,
        reviewsAdded: totalReviewsInserted,
        apiCalls: cafes.length,
        estimatedCost: cafes.length * 0.017
      }
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  } catch (error: any) {
    console.error('Error in enrich-cafes function:', error);
    return new Response(JSON.stringify({ 
      success: false,
      message: error.message || 'Failed to run enrichment',
      error: error.message
    }), {
      status: 200, // Return 200 to match expected format
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});

================
File: supabase/functions/refresh-amenities/index.ts
================
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.57.4';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const googleApiKey = Deno.env.get('GOOGLE_PLACES_API_KEY');

    if (!googleApiKey) {
      throw new Error('GOOGLE_PLACES_API_KEY not configured');
    }

    const supabase = createClient(supabaseUrl, supabaseKey);

    // Fetch all active cafes
    const { data: cafes, error: cafesError } = await supabase
      .from('cafes')
      .select('id, place_id, name')
      .eq('is_active', true);

    if (cafesError) throw cafesError;

    console.log(`Starting amenities refresh for ${cafes.length} cafes`);

    let updated = 0;
    let apiCalls = 0;
    let failed = 0;
    const MAX_API_CALLS = 2000;

    for (const cafe of cafes) {
      if (apiCalls >= MAX_API_CALLS) break;

      try {
        const url = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${cafe.place_id}&fields=opening_hours,formatted_phone_number,website&key=${googleApiKey}`;
        
        apiCalls++;
        const response = await fetch(url);
        
        if (!response.ok) {
          console.error(`Failed to fetch details for ${cafe.name}`);
          failed++;
          continue;
        }

        const data = await response.json();
        const details = data.result;

        if (details) {
          const updateData: any = {
            updated_at: new Date().toISOString(),
          };

          if (details.opening_hours?.weekday_text) {
            updateData.opening_hours = details.opening_hours.weekday_text;
          }

          if (details.formatted_phone_number) {
            updateData.phone_number = details.formatted_phone_number;
          }

          if (details.website) {
            updateData.website = details.website;
          }

          const { error: updateError } = await supabase
            .from('cafes')
            .update(updateData)
            .eq('id', cafe.id);

          if (updateError) {
            console.error(`Error updating ${cafe.name}:`, updateError);
            failed++;
          } else {
            updated++;
            console.log(`‚úÖ ${cafe.name}: Updated amenities`);
          }

          // Rate limiting: 100ms delay
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      } catch (error) {
        console.error(`Failed to process ${cafe.name}:`, error);
        failed++;
      }
    }

    const message = `‚úÖ Updated ${updated} caf√©s. API calls used: ${apiCalls} of ${MAX_API_CALLS}`;
    console.log(message);

    return new Response(JSON.stringify({ 
      success: true, 
      message,
      stats: {
        processed: cafes.length,
        succeeded: updated,
        failed: cafes.length - updated,
        apiCalls: apiCalls,
        estimatedCost: apiCalls * 0.017
      }
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  } catch (error: any) {
    console.error('Error in refresh-amenities function:', error);
    return new Response(JSON.stringify({ 
      success: false,
      message: error.message || 'Failed to refresh amenities',
      error: error.message
    }), {
      status: 200, // Return 200 to match expected format
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});

================
File: supabase/migrations/20250106_create_feedback_table.sql
================
-- Create feedback table for user feedback and support requests
CREATE TABLE IF NOT EXISTS public.feedback (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  feedback_type TEXT NOT NULL CHECK (feedback_type IN ('bug', 'feature', 'general', 'support')),
  subject TEXT NOT NULL,
  details TEXT NOT NULL,
  allow_followup BOOLEAN DEFAULT false,
  contact_email TEXT,
  user_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
  device_id TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_feedback_type ON public.feedback(feedback_type);
CREATE INDEX IF NOT EXISTS idx_feedback_created_at ON public.feedback(created_at);
CREATE INDEX IF NOT EXISTS idx_feedback_user_id ON public.feedback(user_id);
CREATE INDEX IF NOT EXISTS idx_feedback_device_id ON public.feedback(device_id);

-- Enable RLS
ALTER TABLE public.feedback ENABLE ROW LEVEL SECURITY;

-- RLS Policies
-- Allow everyone to insert feedback (anonymous users can submit feedback)
CREATE POLICY "Anyone can submit feedback"
  ON public.feedback
  FOR INSERT
  WITH CHECK (true);

-- Allow users to view their own feedback
CREATE POLICY "Users can view their own feedback"
  ON public.feedback
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL AND user_id = (
      SELECT id FROM public.users WHERE auth_user_id = auth.uid()
    )
  );

-- Allow anonymous users to view their own feedback by device_id
CREATE POLICY "Anonymous users can view their own feedback by device_id"
  ON public.feedback
  FOR SELECT
  USING (
    auth.uid() IS NULL AND device_id IS NOT NULL
  );

-- Allow users to update their own feedback (for follow-up email changes)
CREATE POLICY "Users can update their own feedback"
  ON public.feedback
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL AND user_id = (
      SELECT id FROM public.users WHERE auth_user_id = auth.uid()
    )
  );

-- Allow anonymous users to update their own feedback by device_id
CREATE POLICY "Anonymous users can update their own feedback by device_id"
  ON public.feedback
  FOR UPDATE
  USING (
    auth.uid() IS NULL AND device_id IS NOT NULL
  );

-- Grant permissions
GRANT SELECT, INSERT, UPDATE ON public.feedback TO anon, authenticated;

-- Create trigger for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_feedback_updated_at 
  BEFORE UPDATE ON public.feedback 
  FOR EACH ROW 
  EXECUTE FUNCTION update_updated_at_column();

================
File: supabase/migrations/20250916232849_e59e0193-bf5e-4e98-b8fb-3d8957a31bcb.sql
================
-- Create cafes table
CREATE TABLE public.cafes (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  place_id TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  address TEXT NOT NULL,
  neighborhood TEXT NOT NULL,
  latitude DECIMAL NOT NULL,
  longitude DECIMAL NOT NULL,
  rating DECIMAL,
  google_rating DECIMAL,
  price_level INTEGER,
  phone_number TEXT,
  website TEXT,
  opening_hours TEXT[],
  photos TEXT[],
  hero_photo_url TEXT,
  google_photo_reference TEXT,
  tags TEXT[] NOT NULL DEFAULT '{}',
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create users table (profiles)
CREATE TABLE public.users (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  auth_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  avatar TEXT,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create posts table
CREATE TABLE public.posts (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  cafe_id UUID REFERENCES public.cafes(id) ON DELETE CASCADE NOT NULL,
  place_id TEXT NOT NULL,
  image_url TEXT NOT NULL,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  text_review TEXT NOT NULL,
  tags TEXT[] NOT NULL DEFAULT '{}',
  likes INTEGER NOT NULL DEFAULT 0,
  comments INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create API usage logs table
CREATE TABLE public.api_usage_logs (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  api_service TEXT NOT NULL, -- 'google_places', 'cloudinary'
  endpoint TEXT NOT NULL,
  request_count INTEGER NOT NULL DEFAULT 1,
  response_status INTEGER,
  error_message TEXT,
  date DATE NOT NULL DEFAULT CURRENT_DATE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Create validation logs table
CREATE TABLE public.validation_logs (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID,
  action_type TEXT NOT NULL, -- 'check_in', 'photo_upload', 'cafe_access'
  cafe_id UUID,
  place_id TEXT,
  validation_result BOOLEAN NOT NULL,
  error_reason TEXT,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Enable Row Level Security
ALTER TABLE public.cafes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.api_usage_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.validation_logs ENABLE ROW LEVEL SECURITY;

-- RLS Policies for cafes (public read access)
CREATE POLICY "Cafes are viewable by everyone" 
ON public.cafes 
FOR SELECT 
USING (true);

CREATE POLICY "Only authenticated users can modify cafes" 
ON public.cafes 
FOR ALL 
USING (auth.uid() IS NOT NULL);

-- RLS Policies for users
CREATE POLICY "Users can view their own profile" 
ON public.users 
FOR SELECT 
USING (auth.uid() = auth_user_id);

CREATE POLICY "Users can update their own profile" 
ON public.users 
FOR UPDATE 
USING (auth.uid() = auth_user_id);

CREATE POLICY "Users can insert their own profile" 
ON public.users 
FOR INSERT 
WITH CHECK (auth.uid() = auth_user_id);

-- RLS Policies for posts (public read, authenticated write)
CREATE POLICY "Posts are viewable by everyone" 
ON public.posts 
FOR SELECT 
USING (true);

CREATE POLICY "Users can create their own posts" 
ON public.posts 
FOR INSERT 
WITH CHECK (auth.uid() IN (SELECT auth_user_id FROM public.users WHERE id = user_id));

CREATE POLICY "Users can update their own posts" 
ON public.posts 
FOR UPDATE 
USING (auth.uid() IN (SELECT auth_user_id FROM public.users WHERE id = user_id));

CREATE POLICY "Users can delete their own posts" 
ON public.posts 
FOR DELETE 
USING (auth.uid() IN (SELECT auth_user_id FROM public.users WHERE id = user_id));

-- RLS Policies for API usage logs (admin only)
CREATE POLICY "API logs viewable by authenticated users" 
ON public.api_usage_logs 
FOR SELECT 
USING (auth.uid() IS NOT NULL);

-- RLS Policies for validation logs (admin only)
CREATE POLICY "Validation logs viewable by authenticated users" 
ON public.validation_logs 
FOR SELECT 
USING (auth.uid() IS NOT NULL);

-- Create indexes for performance
CREATE INDEX idx_cafes_place_id ON public.cafes(place_id);
CREATE INDEX idx_cafes_neighborhood ON public.cafes(neighborhood);
CREATE INDEX idx_cafes_location ON public.cafes(latitude, longitude);
CREATE INDEX idx_posts_user_id ON public.posts(user_id);
CREATE INDEX idx_posts_cafe_id ON public.posts(cafe_id);
CREATE INDEX idx_posts_created_at ON public.posts(created_at DESC);
CREATE INDEX idx_api_usage_date ON public.api_usage_logs(date, api_service);
CREATE INDEX idx_validation_logs_created_at ON public.validation_logs(created_at DESC);

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SET search_path = public;

-- Create triggers for automatic timestamp updates
CREATE TRIGGER update_cafes_updated_at
  BEFORE UPDATE ON public.cafes
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_posts_updated_at
  BEFORE UPDATE ON public.posts
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- Create function to prevent duplicate check-ins (same user/cafe/day)
CREATE OR REPLACE FUNCTION public.check_duplicate_checkin()
RETURNS TRIGGER AS $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM public.posts 
    WHERE user_id = NEW.user_id 
    AND cafe_id = NEW.cafe_id 
    AND DATE(created_at) = DATE(NEW.created_at)
  ) THEN
    RAISE EXCEPTION 'Duplicate check-in: User has already checked in to this cafe today';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SET search_path = public;

-- Create trigger for duplicate check-in prevention
CREATE TRIGGER prevent_duplicate_checkins
  BEFORE INSERT ON public.posts
  FOR EACH ROW
  EXECUTE FUNCTION public.check_duplicate_checkin();

================
File: supabase/migrations/20250930034553_b8e4c817-9eab-43b4-829a-3dfe638d8ce4.sql
================
-- Create cafe_reviews table for Google Reviews data
CREATE TABLE IF NOT EXISTS public.cafe_reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cafe_id UUID NOT NULL REFERENCES public.cafes(id) ON DELETE CASCADE,
  reviewer_name TEXT NOT NULL,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  review_text TEXT NOT NULL,
  profile_photo_url TEXT,
  time TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  UNIQUE(cafe_id, reviewer_name, review_text)
);

-- Add index for fast lookups by cafe
CREATE INDEX IF NOT EXISTS idx_cafe_reviews_cafe_id ON public.cafe_reviews(cafe_id);

-- Add index for sorting by rating
CREATE INDEX IF NOT EXISTS idx_cafe_reviews_rating ON public.cafe_reviews(rating DESC);

-- Add index for sorting by time
CREATE INDEX IF NOT EXISTS idx_cafe_reviews_time ON public.cafe_reviews(time DESC);

-- Enable RLS
ALTER TABLE public.cafe_reviews ENABLE ROW LEVEL SECURITY;

-- Allow everyone to read reviews
CREATE POLICY "Reviews are viewable by everyone"
ON public.cafe_reviews
FOR SELECT
USING (true);

-- Only authenticated users can insert/update/delete reviews (for admin operations)
CREATE POLICY "Only authenticated users can modify reviews"
ON public.cafe_reviews
FOR ALL
USING (auth.uid() IS NOT NULL);

-- Add trigger to update updated_at
CREATE TRIGGER update_cafe_reviews_updated_at
BEFORE UPDATE ON public.cafe_reviews
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();

================
File: supabase/migrations/20250930034745_5fca4937-3697-4265-aa27-41cc99bdbcf1.sql
================
-- Enable RLS on tables that don't have it enabled
ALTER TABLE public.cafe_photos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sync_history ENABLE ROW LEVEL SECURITY;

-- Add public read policies for tables that need them
CREATE POLICY "Cafe photos are viewable by everyone"
ON public.cafe_photos
FOR SELECT
USING (true);

CREATE POLICY "Sync history viewable by authenticated users"
ON public.sync_history
FOR SELECT
USING (auth.uid() IS NOT NULL);

-- Fix function search paths (set to public for all custom functions)
ALTER FUNCTION public.calculate_cafe_user_rating(uuid) SET search_path = public;
ALTER FUNCTION public.update_cafe_user_rating() SET search_path = public;
ALTER FUNCTION public.update_cafe_hero_image(uuid) SET search_path = public;
ALTER FUNCTION public.trigger_update_hero_image() SET search_path = public;
ALTER FUNCTION public.update_cafe_hero_photo() SET search_path = public;

================
File: supabase/migrations/20251006_add_favorites_and_user_activities.sql
================
-- Favorites table
CREATE TABLE IF NOT EXISTS public.favorites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.users(id) ON DELETE CASCADE,
  device_id TEXT,
  cafe_id UUID REFERENCES public.cafes(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  UNIQUE(user_id, cafe_id),
  UNIQUE(device_id, cafe_id)
);

-- User Activities table
CREATE TABLE IF NOT EXISTS public.user_activities (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
  username TEXT,
  activity_type TEXT NOT NULL CHECK (activity_type IN ('check-in', 'review', 'photo-upload', 'favorite')),
  cafe_id UUID REFERENCES public.cafes(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  metadata JSONB
);

-- Indexes for fast lookups
CREATE INDEX IF NOT EXISTS idx_favorites_user_id ON public.favorites(user_id);
CREATE INDEX IF NOT EXISTS idx_favorites_device_id ON public.favorites(device_id);
CREATE INDEX IF NOT EXISTS idx_favorites_cafe_id ON public.favorites(cafe_id);
CREATE INDEX IF NOT EXISTS idx_user_activities_user_id ON public.user_activities(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activities_cafe_id ON public.user_activities(cafe_id);
CREATE INDEX IF NOT EXISTS idx_user_activities_type ON public.user_activities(activity_type);

-- RLS
ALTER TABLE public.favorites ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_activities ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Favorites are viewable by everyone"
  ON public.favorites
  FOR SELECT
  USING (true);

CREATE POLICY "Users can manage their own favorites"
  ON public.favorites
  FOR ALL
  USING (auth.uid() IS NOT NULL);

CREATE POLICY "User activities are viewable by everyone"
  ON public.user_activities
  FOR SELECT
  USING (true);

CREATE POLICY "Users can insert their own activities"
  ON public.user_activities
  FOR INSERT
  WITH CHECK (auth.uid() IS NOT NULL);

================
File: supabase/migrations/20251006_add_username_device_to_posts.sql
================
-- Add username and device_id to posts table
ALTER TABLE public.posts ADD COLUMN IF NOT EXISTS username TEXT;
ALTER TABLE public.posts ADD COLUMN IF NOT EXISTS device_id TEXT;

-- Create index for device_id lookups
CREATE INDEX IF NOT EXISTS idx_posts_device_id ON public.posts(device_id);
CREATE INDEX IF NOT EXISTS idx_posts_username ON public.posts(username);

================
File: supabase/migrations/20251006_add_username_to_users.sql
================
-- Add username column to users table
ALTER TABLE public.users ADD COLUMN IF NOT EXISTS username TEXT UNIQUE;

-- Create index for fast username lookups
CREATE INDEX IF NOT EXISTS idx_users_username ON public.users(username);

-- Update RLS policy to allow username lookups
CREATE POLICY "Usernames are viewable by everyone"
ON public.users
FOR SELECT
USING (true);

================
File: supabase/migrations/20251006_complete_feature_implementation.sql
================
-- Complete Feature Implementation Migration
-- This migration implements all the features from the BeanScene implementation plan

-- 1. Add username column to users table
ALTER TABLE public.users ADD COLUMN IF NOT EXISTS username TEXT UNIQUE;

-- 2. Add username and device_id to posts table
ALTER TABLE public.posts ADD COLUMN IF NOT EXISTS username TEXT;
ALTER TABLE public.posts ADD COLUMN IF NOT EXISTS device_id TEXT;

-- 3. Create favorites table
CREATE TABLE IF NOT EXISTS public.favorites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.users(id) ON DELETE CASCADE,
  device_id TEXT,
  cafe_id UUID REFERENCES public.cafes(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  UNIQUE(user_id, cafe_id),
  UNIQUE(device_id, cafe_id)
);

-- 4. Create user_activities table
CREATE TABLE IF NOT EXISTS public.user_activities (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
  username TEXT,
  activity_type TEXT NOT NULL CHECK (activity_type IN ('check-in', 'review', 'photo-upload', 'favorite')),
  cafe_id UUID REFERENCES public.cafes(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  metadata JSONB
);

-- 5. Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_users_username ON public.users(username);
CREATE INDEX IF NOT EXISTS idx_posts_device_id ON public.posts(device_id);
CREATE INDEX IF NOT EXISTS idx_posts_username ON public.posts(username);
CREATE INDEX IF NOT EXISTS idx_favorites_user_id ON public.favorites(user_id);
CREATE INDEX IF NOT EXISTS idx_favorites_device_id ON public.favorites(device_id);
CREATE INDEX IF NOT EXISTS idx_favorites_cafe_id ON public.favorites(cafe_id);
CREATE INDEX IF NOT EXISTS idx_user_activities_user_id ON public.user_activities(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activities_cafe_id ON public.user_activities(cafe_id);
CREATE INDEX IF NOT EXISTS idx_user_activities_type ON public.user_activities(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activities_created_at ON public.user_activities(created_at DESC);

-- 6. Enable Row Level Security
ALTER TABLE public.favorites ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_activities ENABLE ROW LEVEL SECURITY;

-- 7. Create RLS policies for favorites
DROP POLICY IF EXISTS "Favorites are viewable by everyone" ON public.favorites;
CREATE POLICY "Favorites are viewable by everyone"
  ON public.favorites
  FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "Users can manage their own favorites" ON public.favorites;
CREATE POLICY "Users can manage their own favorites"
  ON public.favorites
  FOR ALL
  USING (auth.uid() IS NOT NULL);

-- 8. Create RLS policies for user_activities
DROP POLICY IF EXISTS "User activities are viewable by everyone" ON public.user_activities;
CREATE POLICY "User activities are viewable by everyone"
  ON public.user_activities
  FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "Users can insert their own activities" ON public.user_activities;
CREATE POLICY "Users can insert their own activities"
  ON public.user_activities
  FOR INSERT
  WITH CHECK (auth.uid() IS NOT NULL);

-- 9. Update existing RLS policies for users to allow username lookups
DROP POLICY IF EXISTS "Users can view their own profile" ON public.users;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.users;
DROP POLICY IF EXISTS "Users can insert their own profile" ON public.users;

CREATE POLICY "Users can view their own profile"
  ON public.users
  FOR SELECT
  USING (auth.uid() = auth_user_id);

CREATE POLICY "Users can update their own profile"
  ON public.users
  FOR UPDATE
  USING (auth.uid() = auth_user_id);

CREATE POLICY "Users can insert their own profile"
  ON public.users
  FOR INSERT
  WITH CHECK (auth.uid() = auth_user_id);

-- 10. Add public read policy for usernames (for public profiles)
DROP POLICY IF EXISTS "Usernames are viewable by everyone" ON public.users;
CREATE POLICY "Usernames are viewable by everyone"
  ON public.users
  FOR SELECT
  USING (true);

-- 11. Add amenities and parking_info columns to cafes table (for seeding)
ALTER TABLE public.cafes ADD COLUMN IF NOT EXISTS amenities JSONB;
ALTER TABLE public.cafes ADD COLUMN IF NOT EXISTS parking_info TEXT;

-- 12. Create indexes for new cafe columns
CREATE INDEX IF NOT EXISTS idx_cafes_amenities ON public.cafes USING GIN (amenities);

-- 13. Update the posts table to allow null user_id (for anonymous posts)
ALTER TABLE public.posts ALTER COLUMN user_id DROP NOT NULL;

-- 14. Create function to get user by username
DROP FUNCTION IF EXISTS public.get_user_by_username(TEXT);
CREATE OR REPLACE FUNCTION public.get_user_by_username(username_param TEXT)
RETURNS TABLE (
  id UUID,
  auth_user_id UUID,
  name TEXT,
  email TEXT,
  username TEXT,
  avatar TEXT,
  created_at TIMESTAMP WITH TIME ZONE,
  updated_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
  RETURN QUERY
  SELECT u.id, u.auth_user_id, u.name, u.email, u.username, u.avatar, u.created_at, u.updated_at
  FROM public.users u
  WHERE u.username = username_param;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 15. Create function to get user activity feed
DROP FUNCTION IF EXISTS public.get_user_activity_feed(INTEGER);
CREATE OR REPLACE FUNCTION public.get_user_activity_feed(limit_count INTEGER DEFAULT 50)
RETURNS TABLE (
  id UUID,
  user_id UUID,
  username TEXT,
  activity_type TEXT,
  cafe_id UUID,
  created_at TIMESTAMP WITH TIME ZONE,
  metadata JSONB
) AS $$
BEGIN
  RETURN QUERY
  SELECT ua.id, ua.user_id, ua.username, ua.activity_type, ua.cafe_id, ua.created_at, ua.metadata
  FROM public.user_activities ua
  ORDER BY ua.created_at DESC
  LIMIT limit_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 16. Create function to get user favorites
DROP FUNCTION IF EXISTS public.get_user_favorites(UUID, TEXT);
CREATE OR REPLACE FUNCTION public.get_user_favorites(user_id_param UUID, device_id_param TEXT)
RETURNS TABLE (
  id UUID,
  cafe_id UUID,
  created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
  RETURN QUERY
  SELECT f.id, f.cafe_id, f.created_at
  FROM public.favorites f
  WHERE (f.user_id = user_id_param OR f.device_id = device_id_param)
  ORDER BY f.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 17. Create function to check if cafe is favorited
DROP FUNCTION IF EXISTS public.is_cafe_favorited(UUID, UUID, TEXT);
CREATE OR REPLACE FUNCTION public.is_cafe_favorited(cafe_id_param UUID, user_id_param UUID, device_id_param TEXT)
RETURNS BOOLEAN AS $$
DECLARE
  favorite_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO favorite_count
  FROM public.favorites f
  WHERE f.cafe_id = cafe_id_param 
    AND (f.user_id = user_id_param OR f.device_id = device_id_param);
  
  RETURN favorite_count > 0;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 18. Create analytics functions for admin dashboard
DROP FUNCTION IF EXISTS public.get_daily_active_users(INTEGER);
CREATE OR REPLACE FUNCTION public.get_daily_active_users(days_back INTEGER DEFAULT 30)
RETURNS TABLE (
  date DATE,
  active_users INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    DATE(ua.created_at) as date,
    COUNT(DISTINCT COALESCE(ua.user_id::TEXT, ua.username)) as active_users
  FROM public.user_activities ua
  WHERE ua.created_at >= CURRENT_DATE - INTERVAL '1 day' * days_back
  GROUP BY DATE(ua.created_at)
  ORDER BY date DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP FUNCTION IF EXISTS public.get_monthly_active_users();
CREATE OR REPLACE FUNCTION public.get_monthly_active_users()
RETURNS INTEGER AS $$
DECLARE
  mau_count INTEGER;
BEGIN
  SELECT COUNT(DISTINCT COALESCE(ua.user_id::TEXT, ua.username)) INTO mau_count
  FROM public.user_activities ua
  WHERE ua.created_at >= CURRENT_DATE - INTERVAL '30 days';
  
  RETURN COALESCE(mau_count, 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP FUNCTION IF EXISTS public.get_engagement_metrics();
CREATE OR REPLACE FUNCTION public.get_engagement_metrics()
RETURNS TABLE (
  total_users INTEGER,
  total_posts INTEGER,
  total_checkins INTEGER,
  total_reviews INTEGER,
  average_rating NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    (SELECT COUNT(*) FROM public.users)::INTEGER as total_users,
    (SELECT COUNT(*) FROM public.posts)::INTEGER as total_posts,
    (SELECT COUNT(*) FROM public.user_activities WHERE activity_type = 'check-in')::INTEGER as total_checkins,
    (SELECT COUNT(*) FROM public.cafe_reviews)::INTEGER as total_reviews,
    COALESCE(
      (SELECT AVG(rating) FROM (
        SELECT rating FROM public.posts
        UNION ALL
        SELECT rating FROM public.cafe_reviews
      ) all_ratings), 0
    ) as average_rating;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 19. Grant necessary permissions
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT SELECT ON public.favorites TO anon, authenticated;
GRANT SELECT ON public.user_activities TO anon, authenticated;
GRANT SELECT ON public.users TO anon, authenticated;
GRANT INSERT, UPDATE, DELETE ON public.favorites TO authenticated;
GRANT INSERT ON public.user_activities TO authenticated;
GRANT UPDATE ON public.users TO authenticated;

-- 20. Grant execute permissions on functions
GRANT EXECUTE ON FUNCTION public.get_user_by_username(TEXT) TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.get_user_activity_feed(INTEGER) TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.get_user_favorites(UUID, TEXT) TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.is_cafe_favorited(UUID, UUID, TEXT) TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.get_daily_active_users(INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_monthly_active_users() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_engagement_metrics() TO authenticated;

-- 21. Add comments for documentation
COMMENT ON TABLE public.favorites IS 'User favorites for cafes, supports both authenticated users and anonymous device IDs';
COMMENT ON TABLE public.user_activities IS 'Activity log for user actions including check-ins, reviews, photo uploads, and favorites';
COMMENT ON COLUMN public.users.username IS 'Unique username for public profiles';
COMMENT ON COLUMN public.posts.username IS 'Username of the post author (for display purposes)';
COMMENT ON COLUMN public.posts.device_id IS 'Device ID for anonymous posts';
COMMENT ON COLUMN public.cafes.amenities IS 'JSON array of cafe amenities from Google Places';
COMMENT ON COLUMN public.cafes.parking_info IS 'Parking information for the cafe';

-- 22. Create triggers for automatic timestamp updates
DROP TRIGGER IF EXISTS update_favorites_updated_at ON public.favorites;
CREATE TRIGGER update_favorites_updated_at
  BEFORE UPDATE ON public.favorites
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_user_activities_updated_at ON public.user_activities;
CREATE TRIGGER update_user_activities_updated_at
  BEFORE UPDATE ON public.user_activities
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

================
File: supabase/migrations/20251006_fix_favorites_rls.sql
================
-- Fix favorites RLS policy to allow anonymous users with device_id
-- This migration fixes the "New row violates RLS policy for table favorites" error

-- First, make user_id nullable to support anonymous users
ALTER TABLE public.favorites ALTER COLUMN user_id DROP NOT NULL;

-- Drop all existing policies to avoid conflicts
DROP POLICY IF EXISTS "Users can manage their own favorites" ON public.favorites;
DROP POLICY IF EXISTS "Authenticated users can manage their favorites" ON public.favorites;
DROP POLICY IF EXISTS "Anonymous users can manage their favorites by device_id" ON public.favorites;
DROP POLICY IF EXISTS "Users can view all favorites" ON public.favorites;
DROP POLICY IF EXISTS "Favorites are viewable by everyone" ON public.favorites;

-- Create new policies that allow both authenticated and anonymous users
CREATE POLICY "Authenticated users can manage their favorites"
  ON public.favorites
  FOR ALL
  USING (auth.uid() IS NOT NULL AND user_id IS NOT NULL);

CREATE POLICY "Anonymous users can manage their favorites by device_id"
  ON public.favorites
  FOR ALL
  USING (auth.uid() IS NULL AND device_id IS NOT NULL);

-- Grant INSERT permission to anonymous users for favorites
GRANT INSERT ON public.favorites TO anon;

-- Policy for everyone to view favorites (for public profiles, etc.)
CREATE POLICY "Users can view all favorites"
  ON public.favorites
  FOR SELECT
  USING (true);

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./pages/**/*.{ts,tsx}", "./components/**/*.{ts,tsx}", "./app/**/*.{ts,tsx}", "./src/**/*.{ts,tsx}"],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
          glow: "hsl(var(--primary-glow))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        "fade-in": {
          "0%": {
            opacity: "0",
            transform: "translateY(10px)",
          },
          "100%": {
            opacity: "1",
            transform: "translateY(0)",
          },
        },
        "slide-up": {
          "0%": {
            transform: "translateY(100%)",
          },
          "100%": {
            transform: "translateY(0)",
          },
        },
        "bounce-in": {
          "0%": {
            transform: "scale(0.3)",
            opacity: "0",
          },
          "50%": {
            transform: "scale(1.05)",
          },
          "70%": {
            transform: "scale(0.9)",
          },
          "100%": {
            transform: "scale(1)",
            opacity: "1",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "fade-in": "fade-in 0.5s ease-out",
        "slide-up": "slide-up 0.3s ease-out",
        "bounce-in": "bounce-in 0.6s ease-out",
      },
      fontFamily: {
        sans: ["Inter", "system-ui", "sans-serif"],
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitAny": false,
    "noFallthroughCasesInSwitch": false,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [{ "path": "./tsconfig.app.json" }, { "path": "./tsconfig.node.json" }],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

================
File: vercel.json
================
{
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ]
}

================
File: vite.config.ts
================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";
import { componentTagger } from "lovable-tagger";

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => ({
  server: {
    host: "::",
    port: 8080,
  },
  plugins: [react(), mode === "development" && componentTagger()].filter(Boolean),
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
}));
